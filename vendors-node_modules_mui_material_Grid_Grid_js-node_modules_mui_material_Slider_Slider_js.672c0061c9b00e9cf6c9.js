"use strict";
(self["webpackChunkproj_42"] = self["webpackChunkproj_42"] || []).push([["vendors-node_modules_mui_material_Grid_Grid_js-node_modules_mui_material_Slider_Slider_js"],{

/***/ "./node_modules/@mui/base/SliderUnstyled/useSlider.js":
/*!************************************************************!*\
  !*** ./node_modules/@mui/base/SliderUnstyled/useSlider.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Identity": () => (/* binding */ Identity),
/* harmony export */   "default": () => (/* binding */ useSlider),
/* harmony export */   "valueToPercent": () => (/* binding */ valueToPercent)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var _mui_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @mui/utils */ "./node_modules/@mui/utils/esm/ownerDocument.js");
/* harmony import */ var _mui_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @mui/utils */ "./node_modules/@mui/utils/esm/useControlled.js");
/* harmony import */ var _mui_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @mui/utils */ "./node_modules/@mui/utils/esm/useIsFocusVisible.js");
/* harmony import */ var _mui_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @mui/utils */ "./node_modules/@mui/utils/esm/useForkRef.js");
/* harmony import */ var _mui_utils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @mui/utils */ "./node_modules/@mui/utils/esm/useEnhancedEffect.js");
/* harmony import */ var _mui_utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @mui/utils */ "./node_modules/@mui/utils/esm/useEventCallback.js");
/* harmony import */ var _mui_utils__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @mui/utils */ "./node_modules/@mui/utils/esm/visuallyHidden.js");



const INTENTIONAL_DRAG_COUNT_THRESHOLD = 2;
function asc(a, b) {
  return a - b;
}
function clamp(value, min, max) {
  if (value == null) {
    return min;
  }
  return Math.min(Math.max(min, value), max);
}
function findClosest(values, currentValue) {
  var _values$reduce;
  const {
    index: closestIndex
  } = (_values$reduce = values.reduce((acc, value, index) => {
    const distance = Math.abs(currentValue - value);
    if (acc === null || distance < acc.distance || distance === acc.distance) {
      return {
        distance,
        index
      };
    }
    return acc;
  }, null)) != null ? _values$reduce : {};
  return closestIndex;
}
function trackFinger(event, touchId) {
  // The event is TouchEvent
  if (touchId.current !== undefined && event.changedTouches) {
    const touchEvent = event;
    for (let i = 0; i < touchEvent.changedTouches.length; i += 1) {
      const touch = touchEvent.changedTouches[i];
      if (touch.identifier === touchId.current) {
        return {
          x: touch.clientX,
          y: touch.clientY
        };
      }
    }
    return false;
  }

  // The event is MouseEvent
  return {
    x: event.clientX,
    y: event.clientY
  };
}
function valueToPercent(value, min, max) {
  return (value - min) * 100 / (max - min);
}
function percentToValue(percent, min, max) {
  return (max - min) * percent + min;
}
function getDecimalPrecision(num) {
  // This handles the case when num is very small (0.00000001), js will turn this into 1e-8.
  // When num is bigger than 1 or less than -1 it won't get converted to this notation so it's fine.
  if (Math.abs(num) < 1) {
    const parts = num.toExponential().split('e-');
    const matissaDecimalPart = parts[0].split('.')[1];
    return (matissaDecimalPart ? matissaDecimalPart.length : 0) + parseInt(parts[1], 10);
  }
  const decimalPart = num.toString().split('.')[1];
  return decimalPart ? decimalPart.length : 0;
}
function roundValueToStep(value, step, min) {
  const nearest = Math.round((value - min) / step) * step + min;
  return Number(nearest.toFixed(getDecimalPrecision(step)));
}
function setValueIndex({
  values,
  newValue,
  index
}) {
  const output = values.slice();
  output[index] = newValue;
  return output.sort(asc);
}
function focusThumb({
  sliderRef,
  activeIndex,
  setActive
}) {
  var _sliderRef$current, _doc$activeElement;
  const doc = (0,_mui_utils__WEBPACK_IMPORTED_MODULE_2__["default"])(sliderRef.current);
  if (!((_sliderRef$current = sliderRef.current) != null && _sliderRef$current.contains(doc.activeElement)) || Number(doc == null ? void 0 : (_doc$activeElement = doc.activeElement) == null ? void 0 : _doc$activeElement.getAttribute('data-index')) !== activeIndex) {
    var _sliderRef$current2;
    (_sliderRef$current2 = sliderRef.current) == null ? void 0 : _sliderRef$current2.querySelector(`[type="range"][data-index="${activeIndex}"]`).focus();
  }
  if (setActive) {
    setActive(activeIndex);
  }
}
const axisProps = {
  horizontal: {
    offset: percent => ({
      left: `${percent}%`
    }),
    leap: percent => ({
      width: `${percent}%`
    })
  },
  'horizontal-reverse': {
    offset: percent => ({
      right: `${percent}%`
    }),
    leap: percent => ({
      width: `${percent}%`
    })
  },
  vertical: {
    offset: percent => ({
      bottom: `${percent}%`
    }),
    leap: percent => ({
      height: `${percent}%`
    })
  }
};
const Identity = x => x;

// TODO: remove support for Safari < 13.
// https://caniuse.com/#search=touch-action
//
// Safari, on iOS, supports touch action since v13.
// Over 80% of the iOS phones are compatible
// in August 2020.
// Utilizing the CSS.supports method to check if touch-action is supported.
// Since CSS.supports is supported on all but Edge@12 and IE and touch-action
// is supported on both Edge@12 and IE if CSS.supports is not available that means that
// touch-action will be supported
let cachedSupportsTouchActionNone;
function doesSupportTouchActionNone() {
  if (cachedSupportsTouchActionNone === undefined) {
    if (typeof CSS !== 'undefined' && typeof CSS.supports === 'function') {
      cachedSupportsTouchActionNone = CSS.supports('touch-action', 'none');
    } else {
      cachedSupportsTouchActionNone = true;
    }
  }
  return cachedSupportsTouchActionNone;
}
/**
 *
 * Demos:
 *
 * - [Unstyled Slider](https://mui.com/base/react-slider/#hook)
 *
 * API:
 *
 * - [useSlider API](https://mui.com/base/api/use-slider/)
 */
function useSlider(parameters) {
  const {
    'aria-labelledby': ariaLabelledby,
    defaultValue,
    disabled = false,
    disableSwap = false,
    isRtl = false,
    marks: marksProp = false,
    max = 100,
    min = 0,
    name,
    onChange,
    onChangeCommitted,
    orientation = 'horizontal',
    ref,
    scale = Identity,
    step = 1,
    tabIndex,
    value: valueProp
  } = parameters;
  const touchId = react__WEBPACK_IMPORTED_MODULE_1__.useRef();
  // We can't use the :active browser pseudo-classes.
  // - The active state isn't triggered when clicking on the rail.
  // - The active state isn't transferred when inversing a range slider.
  const [active, setActive] = react__WEBPACK_IMPORTED_MODULE_1__.useState(-1);
  const [open, setOpen] = react__WEBPACK_IMPORTED_MODULE_1__.useState(-1);
  const [dragging, setDragging] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);
  const moveCount = react__WEBPACK_IMPORTED_MODULE_1__.useRef(0);
  const [valueDerived, setValueState] = (0,_mui_utils__WEBPACK_IMPORTED_MODULE_3__["default"])({
    controlled: valueProp,
    default: defaultValue != null ? defaultValue : min,
    name: 'Slider'
  });
  const handleChange = onChange && ((event, value, thumbIndex) => {
    // Redefine target to allow name and value to be read.
    // This allows seamless integration with the most popular form libraries.
    // https://github.com/mui/material-ui/issues/13485#issuecomment-676048492
    // Clone the event to not override `target` of the original event.
    const nativeEvent = event.nativeEvent || event;
    // @ts-ignore The nativeEvent is function, not object
    const clonedEvent = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
    Object.defineProperty(clonedEvent, 'target', {
      writable: true,
      value: {
        value,
        name
      }
    });
    onChange(clonedEvent, value, thumbIndex);
  });
  const range = Array.isArray(valueDerived);
  let values = range ? valueDerived.slice().sort(asc) : [valueDerived];
  values = values.map(value => clamp(value, min, max));
  const marks = marksProp === true && step !== null ? [...Array(Math.floor((max - min) / step) + 1)].map((_, index) => ({
    value: min + step * index
  })) : marksProp || [];
  const marksValues = marks.map(mark => mark.value);
  const {
    isFocusVisibleRef,
    onBlur: handleBlurVisible,
    onFocus: handleFocusVisible,
    ref: focusVisibleRef
  } = (0,_mui_utils__WEBPACK_IMPORTED_MODULE_4__["default"])();
  const [focusedThumbIndex, setFocusedThumbIndex] = react__WEBPACK_IMPORTED_MODULE_1__.useState(-1);
  const sliderRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef();
  const handleFocusRef = (0,_mui_utils__WEBPACK_IMPORTED_MODULE_5__["default"])(focusVisibleRef, sliderRef);
  const handleRef = (0,_mui_utils__WEBPACK_IMPORTED_MODULE_5__["default"])(ref, handleFocusRef);
  const createHandleHiddenInputFocus = otherHandlers => event => {
    var _otherHandlers$onFocu;
    const index = Number(event.currentTarget.getAttribute('data-index'));
    handleFocusVisible(event);
    if (isFocusVisibleRef.current === true) {
      setFocusedThumbIndex(index);
    }
    setOpen(index);
    otherHandlers == null ? void 0 : (_otherHandlers$onFocu = otherHandlers.onFocus) == null ? void 0 : _otherHandlers$onFocu.call(otherHandlers, event);
  };
  const createHandleHiddenInputBlur = otherHandlers => event => {
    var _otherHandlers$onBlur;
    handleBlurVisible(event);
    if (isFocusVisibleRef.current === false) {
      setFocusedThumbIndex(-1);
    }
    setOpen(-1);
    otherHandlers == null ? void 0 : (_otherHandlers$onBlur = otherHandlers.onBlur) == null ? void 0 : _otherHandlers$onBlur.call(otherHandlers, event);
  };
  (0,_mui_utils__WEBPACK_IMPORTED_MODULE_6__["default"])(() => {
    if (disabled && sliderRef.current.contains(document.activeElement)) {
      var _document$activeEleme;
      // This is necessary because Firefox and Safari will keep focus
      // on a disabled element:
      // https://codesandbox.io/s/mui-pr-22247-forked-h151h?file=/src/App.js
      // @ts-ignore
      (_document$activeEleme = document.activeElement) == null ? void 0 : _document$activeEleme.blur();
    }
  }, [disabled]);
  if (disabled && active !== -1) {
    setActive(-1);
  }
  if (disabled && focusedThumbIndex !== -1) {
    setFocusedThumbIndex(-1);
  }
  const createHandleHiddenInputChange = otherHandlers => event => {
    var _otherHandlers$onChan;
    (_otherHandlers$onChan = otherHandlers.onChange) == null ? void 0 : _otherHandlers$onChan.call(otherHandlers, event);
    const index = Number(event.currentTarget.getAttribute('data-index'));
    const value = values[index];
    const marksIndex = marksValues.indexOf(value);

    // @ts-ignore
    let newValue = event.target.valueAsNumber;
    if (marks && step == null) {
      newValue = newValue < value ? marksValues[marksIndex - 1] : marksValues[marksIndex + 1];
    }
    newValue = clamp(newValue, min, max);
    if (marks && step == null) {
      const currentMarkIndex = marksValues.indexOf(values[index]);
      newValue = newValue < values[index] ? marksValues[currentMarkIndex - 1] : marksValues[currentMarkIndex + 1];
    }
    if (range) {
      // Bound the new value to the thumb's neighbours.
      if (disableSwap) {
        newValue = clamp(newValue, values[index - 1] || -Infinity, values[index + 1] || Infinity);
      }
      const previousValue = newValue;
      newValue = setValueIndex({
        values,
        newValue,
        index
      });
      let activeIndex = index;

      // Potentially swap the index if needed.
      if (!disableSwap) {
        activeIndex = newValue.indexOf(previousValue);
      }
      focusThumb({
        sliderRef,
        activeIndex
      });
    }
    setValueState(newValue);
    setFocusedThumbIndex(index);
    if (handleChange) {
      handleChange(event, newValue, index);
    }
    if (onChangeCommitted) {
      onChangeCommitted(event, newValue);
    }
  };
  const previousIndex = react__WEBPACK_IMPORTED_MODULE_1__.useRef();
  let axis = orientation;
  if (isRtl && orientation === 'horizontal') {
    axis += '-reverse';
  }
  const getFingerNewValue = ({
    finger,
    move = false
  }) => {
    const {
      current: slider
    } = sliderRef;
    const {
      width,
      height,
      bottom,
      left
    } = slider.getBoundingClientRect();
    let percent;
    if (axis.indexOf('vertical') === 0) {
      percent = (bottom - finger.y) / height;
    } else {
      percent = (finger.x - left) / width;
    }
    if (axis.indexOf('-reverse') !== -1) {
      percent = 1 - percent;
    }
    let newValue;
    newValue = percentToValue(percent, min, max);
    if (step) {
      newValue = roundValueToStep(newValue, step, min);
    } else {
      const closestIndex = findClosest(marksValues, newValue);
      newValue = marksValues[closestIndex];
    }
    newValue = clamp(newValue, min, max);
    let activeIndex = 0;
    if (range) {
      if (!move) {
        activeIndex = findClosest(values, newValue);
      } else {
        activeIndex = previousIndex.current;
      }

      // Bound the new value to the thumb's neighbours.
      if (disableSwap) {
        newValue = clamp(newValue, values[activeIndex - 1] || -Infinity, values[activeIndex + 1] || Infinity);
      }
      const previousValue = newValue;
      newValue = setValueIndex({
        values,
        newValue,
        index: activeIndex
      });

      // Potentially swap the index if needed.
      if (!(disableSwap && move)) {
        activeIndex = newValue.indexOf(previousValue);
        previousIndex.current = activeIndex;
      }
    }
    return {
      newValue,
      activeIndex
    };
  };
  const handleTouchMove = (0,_mui_utils__WEBPACK_IMPORTED_MODULE_7__["default"])(nativeEvent => {
    const finger = trackFinger(nativeEvent, touchId);
    if (!finger) {
      return;
    }
    moveCount.current += 1;

    // Cancel move in case some other element consumed a mouseup event and it was not fired.
    // @ts-ignore buttons doesn't not exists on touch event
    if (nativeEvent.type === 'mousemove' && nativeEvent.buttons === 0) {
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      handleTouchEnd(nativeEvent);
      return;
    }
    const {
      newValue,
      activeIndex
    } = getFingerNewValue({
      finger,
      move: true
    });
    focusThumb({
      sliderRef,
      activeIndex,
      setActive
    });
    setValueState(newValue);
    if (!dragging && moveCount.current > INTENTIONAL_DRAG_COUNT_THRESHOLD) {
      setDragging(true);
    }
    if (handleChange && newValue !== valueDerived) {
      handleChange(nativeEvent, newValue, activeIndex);
    }
  });
  const handleTouchEnd = (0,_mui_utils__WEBPACK_IMPORTED_MODULE_7__["default"])(nativeEvent => {
    const finger = trackFinger(nativeEvent, touchId);
    setDragging(false);
    if (!finger) {
      return;
    }
    const {
      newValue
    } = getFingerNewValue({
      finger,
      move: true
    });
    setActive(-1);
    if (nativeEvent.type === 'touchend') {
      setOpen(-1);
    }
    if (onChangeCommitted) {
      onChangeCommitted(nativeEvent, newValue);
    }
    touchId.current = undefined;

    // eslint-disable-next-line @typescript-eslint/no-use-before-define
    stopListening();
  });
  const handleTouchStart = (0,_mui_utils__WEBPACK_IMPORTED_MODULE_7__["default"])(nativeEvent => {
    if (disabled) {
      return;
    }
    // If touch-action: none; is not supported we need to prevent the scroll manually.
    if (!doesSupportTouchActionNone()) {
      nativeEvent.preventDefault();
    }
    const touch = nativeEvent.changedTouches[0];
    if (touch != null) {
      // A number that uniquely identifies the current finger in the touch session.
      touchId.current = touch.identifier;
    }
    const finger = trackFinger(nativeEvent, touchId);
    if (finger !== false) {
      const {
        newValue,
        activeIndex
      } = getFingerNewValue({
        finger
      });
      focusThumb({
        sliderRef,
        activeIndex,
        setActive
      });
      setValueState(newValue);
      if (handleChange) {
        handleChange(nativeEvent, newValue, activeIndex);
      }
    }
    moveCount.current = 0;
    const doc = (0,_mui_utils__WEBPACK_IMPORTED_MODULE_2__["default"])(sliderRef.current);
    doc.addEventListener('touchmove', handleTouchMove);
    doc.addEventListener('touchend', handleTouchEnd);
  });
  const stopListening = react__WEBPACK_IMPORTED_MODULE_1__.useCallback(() => {
    const doc = (0,_mui_utils__WEBPACK_IMPORTED_MODULE_2__["default"])(sliderRef.current);
    doc.removeEventListener('mousemove', handleTouchMove);
    doc.removeEventListener('mouseup', handleTouchEnd);
    doc.removeEventListener('touchmove', handleTouchMove);
    doc.removeEventListener('touchend', handleTouchEnd);
  }, [handleTouchEnd, handleTouchMove]);
  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {
    const {
      current: slider
    } = sliderRef;
    slider.addEventListener('touchstart', handleTouchStart, {
      passive: doesSupportTouchActionNone()
    });
    return () => {
      // @ts-ignore
      slider.removeEventListener('touchstart', handleTouchStart, {
        passive: doesSupportTouchActionNone()
      });
      stopListening();
    };
  }, [stopListening, handleTouchStart]);
  react__WEBPACK_IMPORTED_MODULE_1__.useEffect(() => {
    if (disabled) {
      stopListening();
    }
  }, [disabled, stopListening]);
  const createHandleMouseDown = otherHandlers => event => {
    var _otherHandlers$onMous;
    (_otherHandlers$onMous = otherHandlers.onMouseDown) == null ? void 0 : _otherHandlers$onMous.call(otherHandlers, event);
    if (disabled) {
      return;
    }
    if (event.defaultPrevented) {
      return;
    }

    // Only handle left clicks
    if (event.button !== 0) {
      return;
    }

    // Avoid text selection
    event.preventDefault();
    const finger = trackFinger(event, touchId);
    if (finger !== false) {
      const {
        newValue,
        activeIndex
      } = getFingerNewValue({
        finger
      });
      focusThumb({
        sliderRef,
        activeIndex,
        setActive
      });
      setValueState(newValue);
      if (handleChange) {
        handleChange(event, newValue, activeIndex);
      }
    }
    moveCount.current = 0;
    const doc = (0,_mui_utils__WEBPACK_IMPORTED_MODULE_2__["default"])(sliderRef.current);
    doc.addEventListener('mousemove', handleTouchMove);
    doc.addEventListener('mouseup', handleTouchEnd);
  };
  const trackOffset = valueToPercent(range ? values[0] : min, min, max);
  const trackLeap = valueToPercent(values[values.length - 1], min, max) - trackOffset;
  const getRootProps = (otherHandlers = {}) => {
    const ownEventHandlers = {
      onMouseDown: createHandleMouseDown(otherHandlers || {})
    };
    const mergedEventHandlers = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, otherHandlers, ownEventHandlers);
    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
      ref: handleRef
    }, mergedEventHandlers);
  };
  const createHandleMouseOver = otherHandlers => event => {
    var _otherHandlers$onMous2;
    (_otherHandlers$onMous2 = otherHandlers.onMouseOver) == null ? void 0 : _otherHandlers$onMous2.call(otherHandlers, event);
    const index = Number(event.currentTarget.getAttribute('data-index'));
    setOpen(index);
  };
  const createHandleMouseLeave = otherHandlers => event => {
    var _otherHandlers$onMous3;
    (_otherHandlers$onMous3 = otherHandlers.onMouseLeave) == null ? void 0 : _otherHandlers$onMous3.call(otherHandlers, event);
    setOpen(-1);
  };
  const getThumbProps = (otherHandlers = {}) => {
    const ownEventHandlers = {
      onMouseOver: createHandleMouseOver(otherHandlers || {}),
      onMouseLeave: createHandleMouseLeave(otherHandlers || {})
    };
    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, otherHandlers, ownEventHandlers);
  };
  const getHiddenInputProps = (otherHandlers = {}) => {
    var _parameters$step;
    const ownEventHandlers = {
      onChange: createHandleHiddenInputChange(otherHandlers || {}),
      onFocus: createHandleHiddenInputFocus(otherHandlers || {}),
      onBlur: createHandleHiddenInputBlur(otherHandlers || {})
    };
    const mergedEventHandlers = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, otherHandlers, ownEventHandlers);
    return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({
      tabIndex,
      'aria-labelledby': ariaLabelledby,
      'aria-orientation': orientation,
      'aria-valuemax': scale(max),
      'aria-valuemin': scale(min),
      name,
      type: 'range',
      min: parameters.min,
      max: parameters.max,
      step: (_parameters$step = parameters.step) != null ? _parameters$step : undefined,
      disabled
    }, mergedEventHandlers, {
      style: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, _mui_utils__WEBPACK_IMPORTED_MODULE_8__["default"], {
        direction: isRtl ? 'rtl' : 'ltr',
        // So that VoiceOver's focus indicator matches the thumb's dimensions
        width: '100%',
        height: '100%'
      })
    });
  };
  return {
    active,
    axis: axis,
    axisProps,
    dragging,
    focusedThumbIndex,
    getHiddenInputProps,
    getRootProps,
    getThumbProps,
    marks: marks,
    open,
    range,
    trackLeap,
    trackOffset,
    values
  };
}

/***/ }),

/***/ "./node_modules/@mui/base/utils/appendOwnerState.js":
/*!**********************************************************!*\
  !*** ./node_modules/@mui/base/utils/appendOwnerState.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ appendOwnerState)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _isHostComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./isHostComponent */ "./node_modules/@mui/base/utils/isHostComponent.js");



/**
 * Type of the ownerState based on the type of an element it applies to.
 * This resolves to the provided OwnerState for React components and `undefined` for host components.
 * Falls back to `OwnerState | undefined` when the exact type can't be determined in development time.
 */

/**
 * Appends the ownerState object to the props, merging with the existing one if necessary.
 *
 * @param elementType Type of the element that owns the `existingProps`. If the element is a DOM node or undefined, `ownerState` is not applied.
 * @param otherProps Props of the element.
 * @param ownerState
 */
function appendOwnerState(elementType, otherProps, ownerState) {
  if (elementType === undefined || (0,_isHostComponent__WEBPACK_IMPORTED_MODULE_1__["default"])(elementType)) {
    return otherProps;
  }
  return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, otherProps, {
    ownerState: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, otherProps.ownerState, ownerState)
  });
}

/***/ }),

/***/ "./node_modules/@mui/base/utils/extractEventHandlers.js":
/*!**************************************************************!*\
  !*** ./node_modules/@mui/base/utils/extractEventHandlers.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ extractEventHandlers)
/* harmony export */ });
/**
 * Extracts event handlers from a given object.
 * A prop is considered an event handler if it is a function and its name starts with `on`.
 *
 * @param object An object to extract event handlers from.
 * @param excludeKeys An array of keys to exclude from the returned object.
 */
function extractEventHandlers(object, excludeKeys = []) {
  if (object === undefined) {
    return {};
  }
  const result = {};
  Object.keys(object).filter(prop => prop.match(/^on[A-Z]/) && typeof object[prop] === 'function' && !excludeKeys.includes(prop)).forEach(prop => {
    result[prop] = object[prop];
  });
  return result;
}

/***/ }),

/***/ "./node_modules/@mui/base/utils/isHostComponent.js":
/*!*********************************************************!*\
  !*** ./node_modules/@mui/base/utils/isHostComponent.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/**
 * Determines if a given element is a DOM element name (i.e. not a React component).
 */
function isHostComponent(element) {
  return typeof element === 'string';
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (isHostComponent);

/***/ }),

/***/ "./node_modules/@mui/base/utils/mergeSlotProps.js":
/*!********************************************************!*\
  !*** ./node_modules/@mui/base/utils/mergeSlotProps.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ mergeSlotProps)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ "./node_modules/clsx/dist/clsx.m.js");
/* harmony import */ var _extractEventHandlers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./extractEventHandlers */ "./node_modules/@mui/base/utils/extractEventHandlers.js");
/* harmony import */ var _omitEventHandlers__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./omitEventHandlers */ "./node_modules/@mui/base/utils/omitEventHandlers.js");




/**
 * Merges the slot component internal props (usually coming from a hook)
 * with the externally provided ones.
 *
 * The merge order is (the latter overrides the former):
 * 1. The internal props (specified as a getter function to work with get*Props hook result)
 * 2. Additional props (specified internally on an unstyled component)
 * 3. External props specified on the owner component. These should only be used on a root slot.
 * 4. External props specified in the `slotProps.*` prop.
 * 5. The `className` prop - combined from all the above.
 * @param parameters
 * @returns
 */
function mergeSlotProps(parameters) {
  const {
    getSlotProps,
    additionalProps,
    externalSlotProps,
    externalForwardedProps,
    className
  } = parameters;
  if (!getSlotProps) {
    // The simpler case - getSlotProps is not defined, so no internal event handlers are defined,
    // so we can simply merge all the props without having to worry about extracting event handlers.
    const joinedClasses = (0,clsx__WEBPACK_IMPORTED_MODULE_1__["default"])(externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className, className, additionalProps == null ? void 0 : additionalProps.className);
    const mergedStyle = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
    const props = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, additionalProps, externalForwardedProps, externalSlotProps);
    if (joinedClasses.length > 0) {
      props.className = joinedClasses;
    }
    if (Object.keys(mergedStyle).length > 0) {
      props.style = mergedStyle;
    }
    return {
      props,
      internalRef: undefined
    };
  }

  // In this case, getSlotProps is responsible for calling the external event handlers.
  // We don't need to include them in the merged props because of this.

  const eventHandlers = (0,_extractEventHandlers__WEBPACK_IMPORTED_MODULE_2__["default"])((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, externalForwardedProps, externalSlotProps));
  const componentsPropsWithoutEventHandlers = (0,_omitEventHandlers__WEBPACK_IMPORTED_MODULE_3__["default"])(externalSlotProps);
  const otherPropsWithoutEventHandlers = (0,_omitEventHandlers__WEBPACK_IMPORTED_MODULE_3__["default"])(externalForwardedProps);
  const internalSlotProps = getSlotProps(eventHandlers);

  // The order of classes is important here.
  // Emotion (that we use in libraries consuming MUI Base) depends on this order
  // to properly override style. It requires the most important classes to be last
  // (see https://github.com/mui/material-ui/pull/33205) for the related discussion.
  const joinedClasses = (0,clsx__WEBPACK_IMPORTED_MODULE_1__["default"])(internalSlotProps == null ? void 0 : internalSlotProps.className, additionalProps == null ? void 0 : additionalProps.className, className, externalForwardedProps == null ? void 0 : externalForwardedProps.className, externalSlotProps == null ? void 0 : externalSlotProps.className);
  const mergedStyle = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, internalSlotProps == null ? void 0 : internalSlotProps.style, additionalProps == null ? void 0 : additionalProps.style, externalForwardedProps == null ? void 0 : externalForwardedProps.style, externalSlotProps == null ? void 0 : externalSlotProps.style);
  const props = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, internalSlotProps, additionalProps, otherPropsWithoutEventHandlers, componentsPropsWithoutEventHandlers);
  if (joinedClasses.length > 0) {
    props.className = joinedClasses;
  }
  if (Object.keys(mergedStyle).length > 0) {
    props.style = mergedStyle;
  }
  return {
    props,
    internalRef: internalSlotProps.ref
  };
}

/***/ }),

/***/ "./node_modules/@mui/base/utils/omitEventHandlers.js":
/*!***********************************************************!*\
  !*** ./node_modules/@mui/base/utils/omitEventHandlers.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ omitEventHandlers)
/* harmony export */ });
/**
 * Removes event handlers from the given object.
 * A field is considered an event handler if it is a function with a name beginning with `on`.
 *
 * @param object Object to remove event handlers from.
 * @returns Object with event handlers removed.
 */
function omitEventHandlers(object) {
  if (object === undefined) {
    return {};
  }
  const result = {};
  Object.keys(object).filter(prop => !(prop.match(/^on[A-Z]/) && typeof object[prop] === 'function')).forEach(prop => {
    result[prop] = object[prop];
  });
  return result;
}

/***/ }),

/***/ "./node_modules/@mui/base/utils/resolveComponentProps.js":
/*!***************************************************************!*\
  !*** ./node_modules/@mui/base/utils/resolveComponentProps.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ resolveComponentProps)
/* harmony export */ });
/**
 * If `componentProps` is a function, calls it with the provided `ownerState`.
 * Otherwise, just returns `componentProps`.
 */
function resolveComponentProps(componentProps, ownerState) {
  if (typeof componentProps === 'function') {
    return componentProps(ownerState);
  }
  return componentProps;
}

/***/ }),

/***/ "./node_modules/@mui/base/utils/useSlotProps.js":
/*!******************************************************!*\
  !*** ./node_modules/@mui/base/utils/useSlotProps.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ useSlotProps)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var _mui_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @mui/utils */ "./node_modules/@mui/utils/esm/useForkRef.js");
/* harmony import */ var _appendOwnerState__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./appendOwnerState */ "./node_modules/@mui/base/utils/appendOwnerState.js");
/* harmony import */ var _mergeSlotProps__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./mergeSlotProps */ "./node_modules/@mui/base/utils/mergeSlotProps.js");
/* harmony import */ var _resolveComponentProps__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./resolveComponentProps */ "./node_modules/@mui/base/utils/resolveComponentProps.js");


const _excluded = ["elementType", "externalSlotProps", "ownerState"];




/**
 * @ignore - do not document.
 * Builds the props to be passed into the slot of an unstyled component.
 * It merges the internal props of the component with the ones supplied by the user, allowing to customize the behavior.
 * If the slot component is not a host component, it also merges in the `ownerState`.
 *
 * @param parameters.getSlotProps - A function that returns the props to be passed to the slot component.
 */
function useSlotProps(parameters) {
  var _parameters$additiona;
  const {
      elementType,
      externalSlotProps,
      ownerState
    } = parameters,
    rest = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_1__["default"])(parameters, _excluded);
  const resolvedComponentsProps = (0,_resolveComponentProps__WEBPACK_IMPORTED_MODULE_2__["default"])(externalSlotProps, ownerState);
  const {
    props: mergedProps,
    internalRef
  } = (0,_mergeSlotProps__WEBPACK_IMPORTED_MODULE_3__["default"])((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, rest, {
    externalSlotProps: resolvedComponentsProps
  }));
  const ref = (0,_mui_utils__WEBPACK_IMPORTED_MODULE_4__["default"])(internalRef, resolvedComponentsProps == null ? void 0 : resolvedComponentsProps.ref, (_parameters$additiona = parameters.additionalProps) == null ? void 0 : _parameters$additiona.ref);
  const props = (0,_appendOwnerState__WEBPACK_IMPORTED_MODULE_5__["default"])(elementType, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, mergedProps, {
    ref
  }), ownerState);
  return props;
}

/***/ }),

/***/ "./node_modules/@mui/material/Grid/Grid.js":
/*!*************************************************!*\
  !*** ./node_modules/@mui/material/Grid/Grid.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "generateColumnGap": () => (/* binding */ generateColumnGap),
/* harmony export */   "generateDirection": () => (/* binding */ generateDirection),
/* harmony export */   "generateGrid": () => (/* binding */ generateGrid),
/* harmony export */   "generateRowGap": () => (/* binding */ generateRowGap),
/* harmony export */   "resolveSpacingClasses": () => (/* binding */ resolveSpacingClasses),
/* harmony export */   "resolveSpacingStyles": () => (/* binding */ resolveSpacingStyles)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! clsx */ "./node_modules/clsx/dist/clsx.m.js");
/* harmony import */ var _mui_system__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @mui/system */ "./node_modules/@mui/system/esm/breakpoints.js");
/* harmony import */ var _mui_system__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @mui/system */ "./node_modules/@mui/system/esm/styleFunctionSx/extendSxProp.js");
/* harmony import */ var _mui_base__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @mui/base */ "./node_modules/@mui/utils/esm/composeClasses/composeClasses.js");
/* harmony import */ var _utils_requirePropFactory__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ../utils/requirePropFactory */ "./node_modules/@mui/material/utils/requirePropFactory.js");
/* harmony import */ var _styles_styled__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../styles/styled */ "./node_modules/@mui/material/styles/styled.js");
/* harmony import */ var _styles_useThemeProps__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ../styles/useThemeProps */ "./node_modules/@mui/material/styles/useThemeProps.js");
/* harmony import */ var _styles_useTheme__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ../styles/useTheme */ "./node_modules/@mui/material/styles/useTheme.js");
/* harmony import */ var _GridContext__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./GridContext */ "./node_modules/@mui/material/Grid/GridContext.js");
/* harmony import */ var _gridClasses__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./gridClasses */ "./node_modules/@mui/material/Grid/gridClasses.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");


const _excluded = ["className", "columns", "columnSpacing", "component", "container", "direction", "item", "rowSpacing", "spacing", "wrap", "zeroMinWidth"];
// A grid component using the following libs as inspiration.
//
// For the implementation:
// - https://getbootstrap.com/docs/4.3/layout/grid/
// - https://github.com/kristoferjoseph/flexboxgrid/blob/master/src/css/flexboxgrid.css
// - https://github.com/roylee0704/react-flexbox-grid
// - https://material.angularjs.org/latest/layout/introduction
//
// Follow this flexbox Guide to better understand the underlying model:
// - https://css-tricks.com/snippets/css/a-guide-to-flexbox/












function getOffset(val) {
  const parse = parseFloat(val);
  return `${parse}${String(val).replace(String(parse), '') || 'px'}`;
}
function generateGrid({
  theme,
  ownerState
}) {
  let size;
  return theme.breakpoints.keys.reduce((globalStyles, breakpoint) => {
    // Use side effect over immutability for better performance.
    let styles = {};
    if (ownerState[breakpoint]) {
      size = ownerState[breakpoint];
    }
    if (!size) {
      return globalStyles;
    }
    if (size === true) {
      // For the auto layouting
      styles = {
        flexBasis: 0,
        flexGrow: 1,
        maxWidth: '100%'
      };
    } else if (size === 'auto') {
      styles = {
        flexBasis: 'auto',
        flexGrow: 0,
        flexShrink: 0,
        maxWidth: 'none',
        width: 'auto'
      };
    } else {
      const columnsBreakpointValues = (0,_mui_system__WEBPACK_IMPORTED_MODULE_5__.resolveBreakpointValues)({
        values: ownerState.columns,
        breakpoints: theme.breakpoints.values
      });
      const columnValue = typeof columnsBreakpointValues === 'object' ? columnsBreakpointValues[breakpoint] : columnsBreakpointValues;
      if (columnValue === undefined || columnValue === null) {
        return globalStyles;
      }
      // Keep 7 significant numbers.
      const width = `${Math.round(size / columnValue * 10e7) / 10e5}%`;
      let more = {};
      if (ownerState.container && ownerState.item && ownerState.columnSpacing !== 0) {
        const themeSpacing = theme.spacing(ownerState.columnSpacing);
        if (themeSpacing !== '0px') {
          const fullWidth = `calc(${width} + ${getOffset(themeSpacing)})`;
          more = {
            flexBasis: fullWidth,
            maxWidth: fullWidth
          };
        }
      }

      // Close to the bootstrap implementation:
      // https://github.com/twbs/bootstrap/blob/8fccaa2439e97ec72a4b7dc42ccc1f649790adb0/scss/mixins/_grid.scss#L41
      styles = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({
        flexBasis: width,
        flexGrow: 0,
        maxWidth: width
      }, more);
    }

    // No need for a media query for the first size.
    if (theme.breakpoints.values[breakpoint] === 0) {
      Object.assign(globalStyles, styles);
    } else {
      globalStyles[theme.breakpoints.up(breakpoint)] = styles;
    }
    return globalStyles;
  }, {});
}
function generateDirection({
  theme,
  ownerState
}) {
  const directionValues = (0,_mui_system__WEBPACK_IMPORTED_MODULE_5__.resolveBreakpointValues)({
    values: ownerState.direction,
    breakpoints: theme.breakpoints.values
  });
  return (0,_mui_system__WEBPACK_IMPORTED_MODULE_5__.handleBreakpoints)({
    theme
  }, directionValues, propValue => {
    const output = {
      flexDirection: propValue
    };
    if (propValue.indexOf('column') === 0) {
      output[`& > .${_gridClasses__WEBPACK_IMPORTED_MODULE_6__["default"].item}`] = {
        maxWidth: 'none'
      };
    }
    return output;
  });
}

/**
 * Extracts zero value breakpoint keys before a non-zero value breakpoint key.
 * @example { xs: 0, sm: 0, md: 2, lg: 0, xl: 0 } or [0, 0, 2, 0, 0]
 * @returns [xs, sm]
 */
function extractZeroValueBreakpointKeys({
  breakpoints,
  values
}) {
  let nonZeroKey = '';
  Object.keys(values).forEach(key => {
    if (nonZeroKey !== '') {
      return;
    }
    if (values[key] !== 0) {
      nonZeroKey = key;
    }
  });
  const sortedBreakpointKeysByValue = Object.keys(breakpoints).sort((a, b) => {
    return breakpoints[a] - breakpoints[b];
  });
  return sortedBreakpointKeysByValue.slice(0, sortedBreakpointKeysByValue.indexOf(nonZeroKey));
}
function generateRowGap({
  theme,
  ownerState
}) {
  const {
    container,
    rowSpacing
  } = ownerState;
  let styles = {};
  if (container && rowSpacing !== 0) {
    const rowSpacingValues = (0,_mui_system__WEBPACK_IMPORTED_MODULE_5__.resolveBreakpointValues)({
      values: rowSpacing,
      breakpoints: theme.breakpoints.values
    });
    let zeroValueBreakpointKeys;
    if (typeof rowSpacingValues === 'object') {
      zeroValueBreakpointKeys = extractZeroValueBreakpointKeys({
        breakpoints: theme.breakpoints.values,
        values: rowSpacingValues
      });
    }
    styles = (0,_mui_system__WEBPACK_IMPORTED_MODULE_5__.handleBreakpoints)({
      theme
    }, rowSpacingValues, (propValue, breakpoint) => {
      var _zeroValueBreakpointK;
      const themeSpacing = theme.spacing(propValue);
      if (themeSpacing !== '0px') {
        return {
          marginTop: `-${getOffset(themeSpacing)}`,
          [`& > .${_gridClasses__WEBPACK_IMPORTED_MODULE_6__["default"].item}`]: {
            paddingTop: getOffset(themeSpacing)
          }
        };
      }
      if ((_zeroValueBreakpointK = zeroValueBreakpointKeys) != null && _zeroValueBreakpointK.includes(breakpoint)) {
        return {};
      }
      return {
        marginTop: 0,
        [`& > .${_gridClasses__WEBPACK_IMPORTED_MODULE_6__["default"].item}`]: {
          paddingTop: 0
        }
      };
    });
  }
  return styles;
}
function generateColumnGap({
  theme,
  ownerState
}) {
  const {
    container,
    columnSpacing
  } = ownerState;
  let styles = {};
  if (container && columnSpacing !== 0) {
    const columnSpacingValues = (0,_mui_system__WEBPACK_IMPORTED_MODULE_5__.resolveBreakpointValues)({
      values: columnSpacing,
      breakpoints: theme.breakpoints.values
    });
    let zeroValueBreakpointKeys;
    if (typeof columnSpacingValues === 'object') {
      zeroValueBreakpointKeys = extractZeroValueBreakpointKeys({
        breakpoints: theme.breakpoints.values,
        values: columnSpacingValues
      });
    }
    styles = (0,_mui_system__WEBPACK_IMPORTED_MODULE_5__.handleBreakpoints)({
      theme
    }, columnSpacingValues, (propValue, breakpoint) => {
      var _zeroValueBreakpointK2;
      const themeSpacing = theme.spacing(propValue);
      if (themeSpacing !== '0px') {
        return {
          width: `calc(100% + ${getOffset(themeSpacing)})`,
          marginLeft: `-${getOffset(themeSpacing)}`,
          [`& > .${_gridClasses__WEBPACK_IMPORTED_MODULE_6__["default"].item}`]: {
            paddingLeft: getOffset(themeSpacing)
          }
        };
      }
      if ((_zeroValueBreakpointK2 = zeroValueBreakpointKeys) != null && _zeroValueBreakpointK2.includes(breakpoint)) {
        return {};
      }
      return {
        width: '100%',
        marginLeft: 0,
        [`& > .${_gridClasses__WEBPACK_IMPORTED_MODULE_6__["default"].item}`]: {
          paddingLeft: 0
        }
      };
    });
  }
  return styles;
}
function resolveSpacingStyles(spacing, breakpoints, styles = {}) {
  // undefined/null or `spacing` <= 0
  if (!spacing || spacing <= 0) {
    return [];
  }
  // in case of string/number `spacing`
  if (typeof spacing === 'string' && !Number.isNaN(Number(spacing)) || typeof spacing === 'number') {
    return [styles[`spacing-xs-${String(spacing)}`]];
  }
  // in case of object `spacing`
  const spacingStyles = [];
  breakpoints.forEach(breakpoint => {
    const value = spacing[breakpoint];
    if (Number(value) > 0) {
      spacingStyles.push(styles[`spacing-${breakpoint}-${String(value)}`]);
    }
  });
  return spacingStyles;
}

// Default CSS values
// flex: '0 1 auto',
// flexDirection: 'row',
// alignItems: 'flex-start',
// flexWrap: 'nowrap',
// justifyContent: 'flex-start',
const GridRoot = (0,_styles_styled__WEBPACK_IMPORTED_MODULE_7__["default"])('div', {
  name: 'MuiGrid',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    const {
      container,
      direction,
      item,
      spacing,
      wrap,
      zeroMinWidth,
      breakpoints
    } = ownerState;
    let spacingStyles = [];

    // in case of grid item
    if (container) {
      spacingStyles = resolveSpacingStyles(spacing, breakpoints, styles);
    }
    const breakpointsStyles = [];
    breakpoints.forEach(breakpoint => {
      const value = ownerState[breakpoint];
      if (value) {
        breakpointsStyles.push(styles[`grid-${breakpoint}-${String(value)}`]);
      }
    });
    return [styles.root, container && styles.container, item && styles.item, zeroMinWidth && styles.zeroMinWidth, ...spacingStyles, direction !== 'row' && styles[`direction-xs-${String(direction)}`], wrap !== 'wrap' && styles[`wrap-xs-${String(wrap)}`], ...breakpointsStyles];
  }
})(({
  ownerState
}) => (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({
  boxSizing: 'border-box'
}, ownerState.container && {
  display: 'flex',
  flexWrap: 'wrap',
  width: '100%'
}, ownerState.item && {
  margin: 0 // For instance, it's useful when used with a `figure` element.
}, ownerState.zeroMinWidth && {
  minWidth: 0
}, ownerState.wrap !== 'wrap' && {
  flexWrap: ownerState.wrap
}), generateDirection, generateRowGap, generateColumnGap, generateGrid);
function resolveSpacingClasses(spacing, breakpoints) {
  // undefined/null or `spacing` <= 0
  if (!spacing || spacing <= 0) {
    return [];
  }
  // in case of string/number `spacing`
  if (typeof spacing === 'string' && !Number.isNaN(Number(spacing)) || typeof spacing === 'number') {
    return [`spacing-xs-${String(spacing)}`];
  }
  // in case of object `spacing`
  const classes = [];
  breakpoints.forEach(breakpoint => {
    const value = spacing[breakpoint];
    if (Number(value) > 0) {
      const className = `spacing-${breakpoint}-${String(value)}`;
      classes.push(className);
    }
  });
  return classes;
}
const useUtilityClasses = ownerState => {
  const {
    classes,
    container,
    direction,
    item,
    spacing,
    wrap,
    zeroMinWidth,
    breakpoints
  } = ownerState;
  let spacingClasses = [];

  // in case of grid item
  if (container) {
    spacingClasses = resolveSpacingClasses(spacing, breakpoints);
  }
  const breakpointsClasses = [];
  breakpoints.forEach(breakpoint => {
    const value = ownerState[breakpoint];
    if (value) {
      breakpointsClasses.push(`grid-${breakpoint}-${String(value)}`);
    }
  });
  const slots = {
    root: ['root', container && 'container', item && 'item', zeroMinWidth && 'zeroMinWidth', ...spacingClasses, direction !== 'row' && `direction-xs-${String(direction)}`, wrap !== 'wrap' && `wrap-xs-${String(wrap)}`, ...breakpointsClasses]
  };
  return (0,_mui_base__WEBPACK_IMPORTED_MODULE_8__["default"])(slots, _gridClasses__WEBPACK_IMPORTED_MODULE_6__.getGridUtilityClass, classes);
};
const Grid = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(function Grid(inProps, ref) {
  const themeProps = (0,_styles_useThemeProps__WEBPACK_IMPORTED_MODULE_9__["default"])({
    props: inProps,
    name: 'MuiGrid'
  });
  const {
    breakpoints
  } = (0,_styles_useTheme__WEBPACK_IMPORTED_MODULE_10__["default"])();
  const props = (0,_mui_system__WEBPACK_IMPORTED_MODULE_11__["default"])(themeProps);
  const {
      className,
      columns: columnsProp,
      columnSpacing: columnSpacingProp,
      component = 'div',
      container = false,
      direction = 'row',
      item = false,
      rowSpacing: rowSpacingProp,
      spacing = 0,
      wrap = 'wrap',
      zeroMinWidth = false
    } = props,
    other = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(props, _excluded);
  const rowSpacing = rowSpacingProp || spacing;
  const columnSpacing = columnSpacingProp || spacing;
  const columnsContext = react__WEBPACK_IMPORTED_MODULE_2__.useContext(_GridContext__WEBPACK_IMPORTED_MODULE_12__["default"]);

  // columns set with default breakpoint unit of 12
  const columns = container ? columnsProp || 12 : columnsContext;
  const breakpointsValues = {};
  const otherFiltered = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, other);
  breakpoints.keys.forEach(breakpoint => {
    if (other[breakpoint] != null) {
      breakpointsValues[breakpoint] = other[breakpoint];
      delete otherFiltered[breakpoint];
    }
  });
  const ownerState = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, props, {
    columns,
    container,
    direction,
    item,
    rowSpacing,
    columnSpacing,
    wrap,
    zeroMinWidth,
    spacing
  }, breakpointsValues, {
    breakpoints: breakpoints.keys
  });
  const classes = useUtilityClasses(ownerState);
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(_GridContext__WEBPACK_IMPORTED_MODULE_12__["default"].Provider, {
    value: columns,
    children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(GridRoot, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({
      ownerState: ownerState,
      className: (0,clsx__WEBPACK_IMPORTED_MODULE_3__["default"])(classes.root, className),
      as: component,
      ref: ref
    }, otherFiltered))
  });
});
 true ? Grid.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The content of the component.
   */
  children: (prop_types__WEBPACK_IMPORTED_MODULE_13___default().node),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: (prop_types__WEBPACK_IMPORTED_MODULE_13___default().object),
  /**
   * @ignore
   */
  className: (prop_types__WEBPACK_IMPORTED_MODULE_13___default().string),
  /**
   * The number of columns.
   * @default 12
   */
  columns: prop_types__WEBPACK_IMPORTED_MODULE_13___default().oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_13___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_13___default().number)), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().number), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().object)]),
  /**
   * Defines the horizontal space between the type `item` components.
   * It overrides the value of the `spacing` prop.
   */
  columnSpacing: prop_types__WEBPACK_IMPORTED_MODULE_13___default().oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_13___default().arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_13___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_13___default().number), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().string)])), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().number), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().object), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().string)]),
  /**
   * The component used for the root node.
   * Either a string to use a HTML element or a component.
   */
  component: (prop_types__WEBPACK_IMPORTED_MODULE_13___default().elementType),
  /**
   * If `true`, the component will have the flex *container* behavior.
   * You should be wrapping *items* with a *container*.
   * @default false
   */
  container: (prop_types__WEBPACK_IMPORTED_MODULE_13___default().bool),
  /**
   * Defines the `flex-direction` style property.
   * It is applied for all screen sizes.
   * @default 'row'
   */
  direction: prop_types__WEBPACK_IMPORTED_MODULE_13___default().oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_13___default().oneOf(['column-reverse', 'column', 'row-reverse', 'row']), prop_types__WEBPACK_IMPORTED_MODULE_13___default().arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_13___default().oneOf(['column-reverse', 'column', 'row-reverse', 'row'])), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().object)]),
  /**
   * If `true`, the component will have the flex *item* behavior.
   * You should be wrapping *items* with a *container*.
   * @default false
   */
  item: (prop_types__WEBPACK_IMPORTED_MODULE_13___default().bool),
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for the `lg` breakpoint and wider screens if not overridden.
   * @default false
   */
  lg: prop_types__WEBPACK_IMPORTED_MODULE_13___default().oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_13___default().oneOf(['auto']), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().number), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().bool)]),
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for the `md` breakpoint and wider screens if not overridden.
   * @default false
   */
  md: prop_types__WEBPACK_IMPORTED_MODULE_13___default().oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_13___default().oneOf(['auto']), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().number), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().bool)]),
  /**
   * Defines the vertical space between the type `item` components.
   * It overrides the value of the `spacing` prop.
   */
  rowSpacing: prop_types__WEBPACK_IMPORTED_MODULE_13___default().oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_13___default().arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_13___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_13___default().number), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().string)])), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().number), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().object), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().string)]),
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for the `sm` breakpoint and wider screens if not overridden.
   * @default false
   */
  sm: prop_types__WEBPACK_IMPORTED_MODULE_13___default().oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_13___default().oneOf(['auto']), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().number), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().bool)]),
  /**
   * Defines the space between the type `item` components.
   * It can only be used on a type `container` component.
   * @default 0
   */
  spacing: prop_types__WEBPACK_IMPORTED_MODULE_13___default().oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_13___default().arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_13___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_13___default().number), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().string)])), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().number), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().object), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().string)]),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: prop_types__WEBPACK_IMPORTED_MODULE_13___default().oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_13___default().arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_13___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_13___default().func), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().object), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().bool)])), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().func), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().object)]),
  /**
   * Defines the `flex-wrap` style property.
   * It's applied for all screen sizes.
   * @default 'wrap'
   */
  wrap: prop_types__WEBPACK_IMPORTED_MODULE_13___default().oneOf(['nowrap', 'wrap-reverse', 'wrap']),
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for the `xl` breakpoint and wider screens if not overridden.
   * @default false
   */
  xl: prop_types__WEBPACK_IMPORTED_MODULE_13___default().oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_13___default().oneOf(['auto']), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().number), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().bool)]),
  /**
   * If a number, it sets the number of columns the grid item uses.
   * It can't be greater than the total number of columns of the container (12 by default).
   * If 'auto', the grid item's width matches its content.
   * If false, the prop is ignored.
   * If true, the grid item's width grows to use the space available in the grid container.
   * The value is applied for all the screen sizes with the lowest priority.
   * @default false
   */
  xs: prop_types__WEBPACK_IMPORTED_MODULE_13___default().oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_13___default().oneOf(['auto']), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().number), (prop_types__WEBPACK_IMPORTED_MODULE_13___default().bool)]),
  /**
   * If `true`, it sets `min-width: 0` on the item.
   * Refer to the limitations section of the documentation to better understand the use case.
   * @default false
   */
  zeroMinWidth: (prop_types__WEBPACK_IMPORTED_MODULE_13___default().bool)
} : 0;
if (true) {
  const requireProp = (0,_utils_requirePropFactory__WEBPACK_IMPORTED_MODULE_14__["default"])('Grid', Grid);
  // eslint-disable-next-line no-useless-concat
  Grid['propTypes' + ''] = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, Grid.propTypes, {
    direction: requireProp('container'),
    lg: requireProp('item'),
    md: requireProp('item'),
    sm: requireProp('item'),
    spacing: requireProp('container'),
    wrap: requireProp('container'),
    xs: requireProp('item'),
    zeroMinWidth: requireProp('item')
  });
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Grid);

/***/ }),

/***/ "./node_modules/@mui/material/Grid/GridContext.js":
/*!********************************************************!*\
  !*** ./node_modules/@mui/material/Grid/GridContext.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");


/**
 * @ignore - internal component.
 */
const GridContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.createContext();
if (true) {
  GridContext.displayName = 'GridContext';
}
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GridContext);

/***/ }),

/***/ "./node_modules/@mui/material/Grid/gridClasses.js":
/*!********************************************************!*\
  !*** ./node_modules/@mui/material/Grid/gridClasses.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "getGridUtilityClass": () => (/* binding */ getGridUtilityClass)
/* harmony export */ });
/* harmony import */ var _mui_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @mui/utils */ "./node_modules/@mui/utils/esm/generateUtilityClasses/generateUtilityClasses.js");
/* harmony import */ var _generateUtilityClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../generateUtilityClass */ "./node_modules/@mui/utils/esm/generateUtilityClass/generateUtilityClass.js");


function getGridUtilityClass(slot) {
  return (0,_generateUtilityClass__WEBPACK_IMPORTED_MODULE_0__["default"])('MuiGrid', slot);
}
const SPACINGS = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
const DIRECTIONS = ['column-reverse', 'column', 'row-reverse', 'row'];
const WRAPS = ['nowrap', 'wrap-reverse', 'wrap'];
const GRID_SIZES = ['auto', true, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
const gridClasses = (0,_mui_utils__WEBPACK_IMPORTED_MODULE_1__["default"])('MuiGrid', ['root', 'container', 'item', 'zeroMinWidth',
// spacings
...SPACINGS.map(spacing => `spacing-xs-${spacing}`),
// direction values
...DIRECTIONS.map(direction => `direction-xs-${direction}`),
// wrap values
...WRAPS.map(wrap => `wrap-xs-${wrap}`),
// grid sizes for all breakpoints
...GRID_SIZES.map(size => `grid-xs-${size}`), ...GRID_SIZES.map(size => `grid-sm-${size}`), ...GRID_SIZES.map(size => `grid-md-${size}`), ...GRID_SIZES.map(size => `grid-lg-${size}`), ...GRID_SIZES.map(size => `grid-xl-${size}`)]);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (gridClasses);

/***/ }),

/***/ "./node_modules/@mui/material/Slider/Slider.js":
/*!*****************************************************!*\
  !*** ./node_modules/@mui/material/Slider/Slider.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SliderMark": () => (/* binding */ SliderMark),
/* harmony export */   "SliderMarkLabel": () => (/* binding */ SliderMarkLabel),
/* harmony export */   "SliderRail": () => (/* binding */ SliderRail),
/* harmony export */   "SliderRoot": () => (/* binding */ SliderRoot),
/* harmony export */   "SliderThumb": () => (/* binding */ SliderThumb),
/* harmony export */   "SliderTrack": () => (/* binding */ SliderTrack),
/* harmony export */   "SliderValueLabel": () => (/* binding */ StyledSliderValueLabel),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/objectWithoutPropertiesLoose */ "./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js");
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_8__);
/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! clsx */ "./node_modules/clsx/dist/clsx.m.js");
/* harmony import */ var _mui_utils__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @mui/utils */ "./node_modules/@mui/utils/esm/chainPropTypes.js");
/* harmony import */ var _mui_base__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @mui/base */ "./node_modules/@mui/utils/esm/composeClasses/composeClasses.js");
/* harmony import */ var _mui_base__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @mui/base */ "./node_modules/@mui/base/utils/useSlotProps.js");
/* harmony import */ var _mui_base__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @mui/base */ "./node_modules/@mui/base/utils/isHostComponent.js");
/* harmony import */ var _mui_base_SliderUnstyled__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @mui/base/SliderUnstyled */ "./node_modules/@mui/base/SliderUnstyled/useSlider.js");
/* harmony import */ var _mui_system__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @mui/system */ "./node_modules/@mui/system/esm/colorManipulator.js");
/* harmony import */ var _styles_useThemeProps__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ../styles/useThemeProps */ "./node_modules/@mui/material/styles/useThemeProps.js");
/* harmony import */ var _styles_styled__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../styles/styled */ "./node_modules/@mui/material/styles/styled.js");
/* harmony import */ var _styles_useTheme__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../styles/useTheme */ "./node_modules/@mui/material/styles/useTheme.js");
/* harmony import */ var _utils_shouldSpreadAdditionalProps__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ../utils/shouldSpreadAdditionalProps */ "./node_modules/@mui/material/utils/shouldSpreadAdditionalProps.js");
/* harmony import */ var _utils_capitalize__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../utils/capitalize */ "./node_modules/@mui/material/utils/capitalize.js");
/* harmony import */ var _SliderValueLabel__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./SliderValueLabel */ "./node_modules/@mui/material/Slider/SliderValueLabel.js");
/* harmony import */ var _sliderClasses__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./sliderClasses */ "./node_modules/@mui/material/Slider/sliderClasses.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");


const _excluded = ["aria-label", "aria-valuetext", "aria-labelledby", "component", "components", "componentsProps", "color", "classes", "className", "disableSwap", "disabled", "getAriaLabel", "getAriaValueText", "marks", "max", "min", "name", "onChange", "onChangeCommitted", "orientation", "size", "step", "scale", "slotProps", "slots", "tabIndex", "track", "value", "valueLabelDisplay", "valueLabelFormat"];
















const valueToPercent = (value, min, max) => (value - min) * 100 / (max - min);
function Identity(x) {
  return x;
}
const SliderRoot = (0,_styles_styled__WEBPACK_IMPORTED_MODULE_5__["default"])('span', {
  name: 'MuiSlider',
  slot: 'Root',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, styles[`color${(0,_utils_capitalize__WEBPACK_IMPORTED_MODULE_6__["default"])(ownerState.color)}`], ownerState.size !== 'medium' && styles[`size${(0,_utils_capitalize__WEBPACK_IMPORTED_MODULE_6__["default"])(ownerState.size)}`], ownerState.marked && styles.marked, ownerState.orientation === 'vertical' && styles.vertical, ownerState.track === 'inverted' && styles.trackInverted, ownerState.track === false && styles.trackFalse];
  }
})(({
  theme,
  ownerState
}) => (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({
  borderRadius: 12,
  boxSizing: 'content-box',
  display: 'inline-block',
  position: 'relative',
  cursor: 'pointer',
  touchAction: 'none',
  color: (theme.vars || theme).palette[ownerState.color].main,
  WebkitTapHighlightColor: 'transparent'
}, ownerState.orientation === 'horizontal' && (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({
  height: 4,
  width: '100%',
  padding: '13px 0',
  // The primary input mechanism of the device includes a pointing device of limited accuracy.
  '@media (pointer: coarse)': {
    // Reach 42px touch target, about ~8mm on screen.
    padding: '20px 0'
  }
}, ownerState.size === 'small' && {
  height: 2
}, ownerState.marked && {
  marginBottom: 20
}), ownerState.orientation === 'vertical' && (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({
  height: '100%',
  width: 4,
  padding: '0 13px',
  // The primary input mechanism of the device includes a pointing device of limited accuracy.
  '@media (pointer: coarse)': {
    // Reach 42px touch target, about ~8mm on screen.
    padding: '0 20px'
  }
}, ownerState.size === 'small' && {
  width: 2
}, ownerState.marked && {
  marginRight: 44
}), {
  '@media print': {
    colorAdjust: 'exact'
  },
  [`&.${_sliderClasses__WEBPACK_IMPORTED_MODULE_7__["default"].disabled}`]: {
    pointerEvents: 'none',
    cursor: 'default',
    color: (theme.vars || theme).palette.grey[400]
  },
  [`&.${_sliderClasses__WEBPACK_IMPORTED_MODULE_7__["default"].dragging}`]: {
    [`& .${_sliderClasses__WEBPACK_IMPORTED_MODULE_7__["default"].thumb}, & .${_sliderClasses__WEBPACK_IMPORTED_MODULE_7__["default"].track}`]: {
      transition: 'none'
    }
  }
}));
 true ? SliderRoot.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * @ignore
   */
  children: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().node)
} : 0;

const SliderRail = (0,_styles_styled__WEBPACK_IMPORTED_MODULE_5__["default"])('span', {
  name: 'MuiSlider',
  slot: 'Rail',
  overridesResolver: (props, styles) => styles.rail
})(({
  ownerState
}) => (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({
  display: 'block',
  position: 'absolute',
  borderRadius: 'inherit',
  backgroundColor: 'currentColor',
  opacity: 0.38
}, ownerState.orientation === 'horizontal' && {
  width: '100%',
  height: 'inherit',
  top: '50%',
  transform: 'translateY(-50%)'
}, ownerState.orientation === 'vertical' && {
  height: '100%',
  width: 'inherit',
  left: '50%',
  transform: 'translateX(-50%)'
}, ownerState.track === 'inverted' && {
  opacity: 1
}));
 true ? SliderRail.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * @ignore
   */
  children: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().node)
} : 0;

const SliderTrack = (0,_styles_styled__WEBPACK_IMPORTED_MODULE_5__["default"])('span', {
  name: 'MuiSlider',
  slot: 'Track',
  overridesResolver: (props, styles) => styles.track
})(({
  theme,
  ownerState
}) => {
  const color =
  // Same logic as the LinearProgress track color
  theme.palette.mode === 'light' ? (0,_mui_system__WEBPACK_IMPORTED_MODULE_9__.lighten)(theme.palette[ownerState.color].main, 0.62) : (0,_mui_system__WEBPACK_IMPORTED_MODULE_9__.darken)(theme.palette[ownerState.color].main, 0.5);
  return (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({
    display: 'block',
    position: 'absolute',
    borderRadius: 'inherit',
    border: '1px solid currentColor',
    backgroundColor: 'currentColor',
    transition: theme.transitions.create(['left', 'width', 'bottom', 'height'], {
      duration: theme.transitions.duration.shortest
    })
  }, ownerState.size === 'small' && {
    border: 'none'
  }, ownerState.orientation === 'horizontal' && {
    height: 'inherit',
    top: '50%',
    transform: 'translateY(-50%)'
  }, ownerState.orientation === 'vertical' && {
    width: 'inherit',
    left: '50%',
    transform: 'translateX(-50%)'
  }, ownerState.track === false && {
    display: 'none'
  }, ownerState.track === 'inverted' && {
    backgroundColor: theme.vars ? theme.vars.palette.Slider[`${ownerState.color}Track`] : color,
    borderColor: theme.vars ? theme.vars.palette.Slider[`${ownerState.color}Track`] : color
  });
});
 true ? SliderTrack.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * @ignore
   */
  children: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().node)
} : 0;

const SliderThumb = (0,_styles_styled__WEBPACK_IMPORTED_MODULE_5__["default"])('span', {
  name: 'MuiSlider',
  slot: 'Thumb',
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.thumb, styles[`thumbColor${(0,_utils_capitalize__WEBPACK_IMPORTED_MODULE_6__["default"])(ownerState.color)}`], ownerState.size !== 'medium' && styles[`thumbSize${(0,_utils_capitalize__WEBPACK_IMPORTED_MODULE_6__["default"])(ownerState.size)}`]];
  }
})(({
  theme,
  ownerState
}) => (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({
  position: 'absolute',
  width: 20,
  height: 20,
  boxSizing: 'border-box',
  borderRadius: '50%',
  outline: 0,
  backgroundColor: 'currentColor',
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  transition: theme.transitions.create(['box-shadow', 'left', 'bottom'], {
    duration: theme.transitions.duration.shortest
  })
}, ownerState.size === 'small' && {
  width: 12,
  height: 12
}, ownerState.orientation === 'horizontal' && {
  top: '50%',
  transform: 'translate(-50%, -50%)'
}, ownerState.orientation === 'vertical' && {
  left: '50%',
  transform: 'translate(-50%, 50%)'
}, {
  '&:before': (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({
    position: 'absolute',
    content: '""',
    borderRadius: 'inherit',
    width: '100%',
    height: '100%',
    boxShadow: (theme.vars || theme).shadows[2]
  }, ownerState.size === 'small' && {
    boxShadow: 'none'
  }),
  '&::after': {
    position: 'absolute',
    content: '""',
    borderRadius: '50%',
    // 42px is the hit target
    width: 42,
    height: 42,
    top: '50%',
    left: '50%',
    transform: 'translate(-50%, -50%)'
  },
  [`&:hover, &.${_sliderClasses__WEBPACK_IMPORTED_MODULE_7__["default"].focusVisible}`]: {
    boxShadow: `0px 0px 0px 8px ${theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.16)` : (0,_mui_system__WEBPACK_IMPORTED_MODULE_9__.alpha)(theme.palette[ownerState.color].main, 0.16)}`,
    '@media (hover: none)': {
      boxShadow: 'none'
    }
  },
  [`&.${_sliderClasses__WEBPACK_IMPORTED_MODULE_7__["default"].active}`]: {
    boxShadow: `0px 0px 0px 14px ${theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.16)` : (0,_mui_system__WEBPACK_IMPORTED_MODULE_9__.alpha)(theme.palette[ownerState.color].main, 0.16)}`
  },
  [`&.${_sliderClasses__WEBPACK_IMPORTED_MODULE_7__["default"].disabled}`]: {
    '&:hover': {
      boxShadow: 'none'
    }
  }
}));
 true ? SliderThumb.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * @ignore
   */
  children: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().node)
} : 0;

const StyledSliderValueLabel = (0,_styles_styled__WEBPACK_IMPORTED_MODULE_5__["default"])(_SliderValueLabel__WEBPACK_IMPORTED_MODULE_10__["default"], {
  name: 'MuiSlider',
  slot: 'ValueLabel',
  overridesResolver: (props, styles) => styles.valueLabel
})(({
  theme,
  ownerState
}) => (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({
  [`&.${_sliderClasses__WEBPACK_IMPORTED_MODULE_7__["default"].valueLabelOpen}`]: {
    transform: 'translateY(-100%) scale(1)'
  },
  zIndex: 1,
  whiteSpace: 'nowrap'
}, theme.typography.body2, {
  fontWeight: 500,
  transition: theme.transitions.create(['transform'], {
    duration: theme.transitions.duration.shortest
  }),
  transform: 'translateY(-100%) scale(0)',
  position: 'absolute',
  backgroundColor: (theme.vars || theme).palette.grey[600],
  borderRadius: 2,
  color: (theme.vars || theme).palette.common.white,
  display: 'flex',
  alignItems: 'center',
  justifyContent: 'center',
  padding: '0.25rem 0.75rem'
}, ownerState.orientation === 'horizontal' && {
  top: '-10px',
  transformOrigin: 'bottom center',
  '&:before': {
    position: 'absolute',
    content: '""',
    width: 8,
    height: 8,
    transform: 'translate(-50%, 50%) rotate(45deg)',
    backgroundColor: 'inherit',
    bottom: 0,
    left: '50%'
  }
}, ownerState.orientation === 'vertical' && {
  right: '30px',
  top: '24px',
  transformOrigin: 'right center',
  '&:before': {
    position: 'absolute',
    content: '""',
    width: 8,
    height: 8,
    transform: 'translate(-50%, 50%) rotate(45deg)',
    backgroundColor: 'inherit',
    right: '-20%',
    top: '25%'
  }
}, ownerState.size === 'small' && {
  fontSize: theme.typography.pxToRem(12),
  padding: '0.25rem 0.5rem'
}));
 true ? StyledSliderValueLabel.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * @ignore
   */
  children: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().node)
} : 0;

const SliderMark = (0,_styles_styled__WEBPACK_IMPORTED_MODULE_5__["default"])('span', {
  name: 'MuiSlider',
  slot: 'Mark',
  shouldForwardProp: prop => (0,_styles_styled__WEBPACK_IMPORTED_MODULE_5__.slotShouldForwardProp)(prop) && prop !== 'markActive',
  overridesResolver: (props, styles) => {
    const {
      markActive
    } = props;
    return [styles.mark, markActive && styles.markActive];
  }
})(({
  theme,
  ownerState,
  markActive
}) => (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({
  position: 'absolute',
  width: 2,
  height: 2,
  borderRadius: 1,
  backgroundColor: 'currentColor'
}, ownerState.orientation === 'horizontal' && {
  top: '50%',
  transform: 'translate(-1px, -50%)'
}, ownerState.orientation === 'vertical' && {
  left: '50%',
  transform: 'translate(-50%, 1px)'
}, markActive && {
  backgroundColor: (theme.vars || theme).palette.background.paper,
  opacity: 0.8
}));
 true ? SliderMark.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * @ignore
   */
  children: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().node)
} : 0;

const SliderMarkLabel = (0,_styles_styled__WEBPACK_IMPORTED_MODULE_5__["default"])('span', {
  name: 'MuiSlider',
  slot: 'MarkLabel',
  shouldForwardProp: prop => (0,_styles_styled__WEBPACK_IMPORTED_MODULE_5__.slotShouldForwardProp)(prop) && prop !== 'markLabelActive',
  overridesResolver: (props, styles) => styles.markLabel
})(({
  theme,
  ownerState,
  markLabelActive
}) => (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, theme.typography.body2, {
  color: (theme.vars || theme).palette.text.secondary,
  position: 'absolute',
  whiteSpace: 'nowrap'
}, ownerState.orientation === 'horizontal' && {
  top: 30,
  transform: 'translateX(-50%)',
  '@media (pointer: coarse)': {
    top: 40
  }
}, ownerState.orientation === 'vertical' && {
  left: 36,
  transform: 'translateY(50%)',
  '@media (pointer: coarse)': {
    left: 44
  }
}, markLabelActive && {
  color: (theme.vars || theme).palette.text.primary
}));
 true ? SliderMarkLabel.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * @ignore
   */
  children: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().node)
} : 0;

const useUtilityClasses = ownerState => {
  const {
    disabled,
    dragging,
    marked,
    orientation,
    track,
    classes,
    color,
    size
  } = ownerState;
  const slots = {
    root: ['root', disabled && 'disabled', dragging && 'dragging', marked && 'marked', orientation === 'vertical' && 'vertical', track === 'inverted' && 'trackInverted', track === false && 'trackFalse', color && `color${(0,_utils_capitalize__WEBPACK_IMPORTED_MODULE_6__["default"])(color)}`, size && `size${(0,_utils_capitalize__WEBPACK_IMPORTED_MODULE_6__["default"])(size)}`],
    rail: ['rail'],
    track: ['track'],
    mark: ['mark'],
    markActive: ['markActive'],
    markLabel: ['markLabel'],
    markLabelActive: ['markLabelActive'],
    valueLabel: ['valueLabel'],
    thumb: ['thumb', disabled && 'disabled', size && `thumbSize${(0,_utils_capitalize__WEBPACK_IMPORTED_MODULE_6__["default"])(size)}`, color && `thumbColor${(0,_utils_capitalize__WEBPACK_IMPORTED_MODULE_6__["default"])(color)}`],
    active: ['active'],
    disabled: ['disabled'],
    focusVisible: ['focusVisible']
  };
  return (0,_mui_base__WEBPACK_IMPORTED_MODULE_11__["default"])(slots, _sliderClasses__WEBPACK_IMPORTED_MODULE_7__.getSliderUtilityClass, classes);
};
const Forward = ({
  children
}) => children;
const Slider = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(function Slider(inputProps, ref) {
  var _ref, _slots$root, _ref2, _slots$rail, _ref3, _slots$track, _ref4, _slots$thumb, _ref5, _slots$valueLabel, _ref6, _slots$mark, _ref7, _slots$markLabel, _ref8, _slots$input, _slotProps$root, _slotProps$rail, _slotProps$track, _slotProps$thumb, _slotProps$valueLabel, _slotProps$mark, _slotProps$markLabel, _slotProps$input;
  const props = (0,_styles_useThemeProps__WEBPACK_IMPORTED_MODULE_12__["default"])({
    props: inputProps,
    name: 'MuiSlider'
  });
  const theme = (0,_styles_useTheme__WEBPACK_IMPORTED_MODULE_13__["default"])();
  const isRtl = theme.direction === 'rtl';
  const {
      'aria-label': ariaLabel,
      'aria-valuetext': ariaValuetext,
      'aria-labelledby': ariaLabelledby,
      // eslint-disable-next-line react/prop-types
      component = 'span',
      components = {},
      componentsProps = {},
      color = 'primary',
      classes: classesProp,
      // eslint-disable-next-line react/prop-types
      className,
      disableSwap = false,
      disabled = false,
      getAriaLabel,
      getAriaValueText,
      marks: marksProp = false,
      max = 100,
      min = 0,
      orientation = 'horizontal',
      size = 'medium',
      step = 1,
      scale = Identity,
      slotProps,
      slots,
      track = 'normal',
      valueLabelDisplay = 'off',
      valueLabelFormat = Identity
    } = props,
    other = (0,_babel_runtime_helpers_esm_objectWithoutPropertiesLoose__WEBPACK_IMPORTED_MODULE_0__["default"])(props, _excluded);
  const ownerState = (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, props, {
    isRtl,
    max,
    min,
    classes: classesProp,
    disabled,
    disableSwap,
    orientation,
    marks: marksProp,
    color,
    size,
    step,
    scale,
    track,
    valueLabelDisplay,
    valueLabelFormat
  });
  const {
    axisProps,
    getRootProps,
    getHiddenInputProps,
    getThumbProps,
    open,
    active,
    axis,
    focusedThumbIndex,
    range,
    dragging,
    marks,
    values,
    trackOffset,
    trackLeap
  } = (0,_mui_base_SliderUnstyled__WEBPACK_IMPORTED_MODULE_14__["default"])((0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, ownerState, {
    ref
  }));
  ownerState.marked = marks.length > 0 && marks.some(mark => mark.label);
  ownerState.dragging = dragging;
  ownerState.focusedThumbIndex = focusedThumbIndex;
  const classes = useUtilityClasses(ownerState);

  // support both `slots` and `components` for backward compatibility
  const RootSlot = (_ref = (_slots$root = slots == null ? void 0 : slots.root) != null ? _slots$root : components.Root) != null ? _ref : SliderRoot;
  const RailSlot = (_ref2 = (_slots$rail = slots == null ? void 0 : slots.rail) != null ? _slots$rail : components.Rail) != null ? _ref2 : SliderRail;
  const TrackSlot = (_ref3 = (_slots$track = slots == null ? void 0 : slots.track) != null ? _slots$track : components.Track) != null ? _ref3 : SliderTrack;
  const ThumbSlot = (_ref4 = (_slots$thumb = slots == null ? void 0 : slots.thumb) != null ? _slots$thumb : components.Thumb) != null ? _ref4 : SliderThumb;
  const ValueLabelSlot = (_ref5 = (_slots$valueLabel = slots == null ? void 0 : slots.valueLabel) != null ? _slots$valueLabel : components.ValueLabel) != null ? _ref5 : StyledSliderValueLabel;
  const MarkSlot = (_ref6 = (_slots$mark = slots == null ? void 0 : slots.mark) != null ? _slots$mark : components.Mark) != null ? _ref6 : SliderMark;
  const MarkLabelSlot = (_ref7 = (_slots$markLabel = slots == null ? void 0 : slots.markLabel) != null ? _slots$markLabel : components.MarkLabel) != null ? _ref7 : SliderMarkLabel;
  const InputSlot = (_ref8 = (_slots$input = slots == null ? void 0 : slots.input) != null ? _slots$input : components.Input) != null ? _ref8 : 'input';
  const rootSlotProps = (_slotProps$root = slotProps == null ? void 0 : slotProps.root) != null ? _slotProps$root : componentsProps.root;
  const railSlotProps = (_slotProps$rail = slotProps == null ? void 0 : slotProps.rail) != null ? _slotProps$rail : componentsProps.rail;
  const trackSlotProps = (_slotProps$track = slotProps == null ? void 0 : slotProps.track) != null ? _slotProps$track : componentsProps.track;
  const thumbSlotProps = (_slotProps$thumb = slotProps == null ? void 0 : slotProps.thumb) != null ? _slotProps$thumb : componentsProps.thumb;
  const valueLabelSlotProps = (_slotProps$valueLabel = slotProps == null ? void 0 : slotProps.valueLabel) != null ? _slotProps$valueLabel : componentsProps.valueLabel;
  const markSlotProps = (_slotProps$mark = slotProps == null ? void 0 : slotProps.mark) != null ? _slotProps$mark : componentsProps.mark;
  const markLabelSlotProps = (_slotProps$markLabel = slotProps == null ? void 0 : slotProps.markLabel) != null ? _slotProps$markLabel : componentsProps.markLabel;
  const inputSlotProps = (_slotProps$input = slotProps == null ? void 0 : slotProps.input) != null ? _slotProps$input : componentsProps.input;
  const rootProps = (0,_mui_base__WEBPACK_IMPORTED_MODULE_15__["default"])({
    elementType: RootSlot,
    getSlotProps: getRootProps,
    externalSlotProps: rootSlotProps,
    externalForwardedProps: other,
    additionalProps: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, (0,_utils_shouldSpreadAdditionalProps__WEBPACK_IMPORTED_MODULE_16__["default"])(RootSlot) && {
      as: component
    }),
    ownerState: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, ownerState, rootSlotProps == null ? void 0 : rootSlotProps.ownerState),
    className: [classes.root, className]
  });
  const railProps = (0,_mui_base__WEBPACK_IMPORTED_MODULE_15__["default"])({
    elementType: RailSlot,
    externalSlotProps: railSlotProps,
    ownerState,
    className: classes.rail
  });
  const trackProps = (0,_mui_base__WEBPACK_IMPORTED_MODULE_15__["default"])({
    elementType: TrackSlot,
    externalSlotProps: trackSlotProps,
    additionalProps: {
      style: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, axisProps[axis].offset(trackOffset), axisProps[axis].leap(trackLeap))
    },
    ownerState: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, ownerState, trackSlotProps == null ? void 0 : trackSlotProps.ownerState),
    className: classes.track
  });
  const thumbProps = (0,_mui_base__WEBPACK_IMPORTED_MODULE_15__["default"])({
    elementType: ThumbSlot,
    getSlotProps: getThumbProps,
    externalSlotProps: thumbSlotProps,
    ownerState: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, ownerState, thumbSlotProps == null ? void 0 : thumbSlotProps.ownerState)
  });
  const valueLabelProps = (0,_mui_base__WEBPACK_IMPORTED_MODULE_15__["default"])({
    elementType: ValueLabelSlot,
    externalSlotProps: valueLabelSlotProps,
    ownerState: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, ownerState, valueLabelSlotProps == null ? void 0 : valueLabelSlotProps.ownerState),
    className: classes.valueLabel
  });
  const markProps = (0,_mui_base__WEBPACK_IMPORTED_MODULE_15__["default"])({
    elementType: MarkSlot,
    externalSlotProps: markSlotProps,
    ownerState,
    className: classes.mark
  });
  const markLabelProps = (0,_mui_base__WEBPACK_IMPORTED_MODULE_15__["default"])({
    elementType: MarkLabelSlot,
    externalSlotProps: markLabelSlotProps,
    ownerState
  });
  const inputSliderProps = (0,_mui_base__WEBPACK_IMPORTED_MODULE_15__["default"])({
    elementType: InputSlot,
    getSlotProps: getHiddenInputProps,
    externalSlotProps: inputSlotProps,
    ownerState
  });
  return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(RootSlot, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, rootProps, {
    children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(RailSlot, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, railProps)), /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(TrackSlot, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, trackProps)), marks.filter(mark => mark.value >= min && mark.value <= max).map((mark, index) => {
      const percent = valueToPercent(mark.value, min, max);
      const style = axisProps[axis].offset(percent);
      let markActive;
      if (track === false) {
        markActive = values.indexOf(mark.value) !== -1;
      } else {
        markActive = track === 'normal' && (range ? mark.value >= values[0] && mark.value <= values[values.length - 1] : mark.value <= values[0]) || track === 'inverted' && (range ? mark.value <= values[0] || mark.value >= values[values.length - 1] : mark.value >= values[0]);
      }
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxs)(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, {
        children: [/*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(MarkSlot, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({
          "data-index": index
        }, markProps, !(0,_mui_base__WEBPACK_IMPORTED_MODULE_17__["default"])(MarkSlot) && {
          markActive
        }, {
          style: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, style, markProps.style),
          className: (0,clsx__WEBPACK_IMPORTED_MODULE_3__["default"])(markProps.className, markActive && classes.markActive)
        })), mark.label != null ? /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(MarkLabelSlot, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({
          "aria-hidden": true,
          "data-index": index
        }, markLabelProps, !(0,_mui_base__WEBPACK_IMPORTED_MODULE_17__["default"])(MarkLabelSlot) && {
          markLabelActive: markActive
        }, {
          style: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, style, markLabelProps.style),
          className: (0,clsx__WEBPACK_IMPORTED_MODULE_3__["default"])(classes.markLabel, markLabelProps.className, markActive && classes.markLabelActive),
          children: mark.label
        })) : null]
      }, index);
    }), values.map((value, index) => {
      const percent = valueToPercent(value, min, max);
      const style = axisProps[axis].offset(percent);
      const ValueLabelComponent = valueLabelDisplay === 'off' ? Forward : ValueLabelSlot;
      return /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(react__WEBPACK_IMPORTED_MODULE_2__.Fragment, {
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(ValueLabelComponent, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, !(0,_mui_base__WEBPACK_IMPORTED_MODULE_17__["default"])(ValueLabelComponent) && {
          valueLabelFormat,
          valueLabelDisplay,
          value: typeof valueLabelFormat === 'function' ? valueLabelFormat(scale(value), index) : valueLabelFormat,
          index,
          open: open === index || active === index || valueLabelDisplay === 'on',
          disabled
        }, valueLabelProps, {
          children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(ThumbSlot, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({
            "data-index": index,
            "data-focusvisible": focusedThumbIndex === index
          }, thumbProps, {
            className: (0,clsx__WEBPACK_IMPORTED_MODULE_3__["default"])(classes.thumb, thumbProps.className, active === index && classes.active, focusedThumbIndex === index && classes.focusVisible),
            style: (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({}, style, {
              pointerEvents: disableSwap && active !== index ? 'none' : undefined
            }, thumbProps.style),
            children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_4__.jsx)(InputSlot, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__["default"])({
              "data-index": index,
              "aria-label": getAriaLabel ? getAriaLabel(index) : ariaLabel,
              "aria-valuenow": scale(value),
              "aria-labelledby": ariaLabelledby,
              "aria-valuetext": getAriaValueText ? getAriaValueText(scale(value), index) : ariaValuetext,
              value: values[index]
            }, inputSliderProps))
          }))
        }))
      }, index);
    })]
  }));
});
 true ? Slider.propTypes /* remove-proptypes */ = {
  // ----------------------------- Warning --------------------------------
  // | These PropTypes are generated from the TypeScript type definitions |
  // |     To update them edit the d.ts file and run "yarn proptypes"     |
  // ----------------------------------------------------------------------
  /**
   * The label of the slider.
   */
  'aria-label': (0,_mui_utils__WEBPACK_IMPORTED_MODULE_18__["default"])((prop_types__WEBPACK_IMPORTED_MODULE_8___default().string), props => {
    const range = Array.isArray(props.value || props.defaultValue);
    if (range && props['aria-label'] != null) {
      return new Error('MUI: You need to use the `getAriaLabel` prop instead of `aria-label` when using a range slider.');
    }
    return null;
  }),
  /**
   * The id of the element containing a label for the slider.
   */
  'aria-labelledby': (prop_types__WEBPACK_IMPORTED_MODULE_8___default().string),
  /**
   * A string value that provides a user-friendly name for the current value of the slider.
   */
  'aria-valuetext': (0,_mui_utils__WEBPACK_IMPORTED_MODULE_18__["default"])((prop_types__WEBPACK_IMPORTED_MODULE_8___default().string), props => {
    const range = Array.isArray(props.value || props.defaultValue);
    if (range && props['aria-valuetext'] != null) {
      return new Error('MUI: You need to use the `getAriaValueText` prop instead of `aria-valuetext` when using a range slider.');
    }
    return null;
  }),
  /**
   * @ignore
   */
  children: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().node),
  /**
   * Override or extend the styles applied to the component.
   */
  classes: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().object),
  /**
   * The color of the component.
   * It supports both default and custom theme colors, which can be added as shown in the
   * [palette customization guide](https://mui.com/material-ui/customization/palette/#adding-new-colors).
   * @default 'primary'
   */
  color: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOf(['primary', 'secondary']), (prop_types__WEBPACK_IMPORTED_MODULE_8___default().string)]),
  /**
   * The components used for each slot inside.
   *
   * This prop is an alias for the `slots` prop.
   * It's recommended to use the `slots` prop instead.
   *
   * @default {}
   */
  components: prop_types__WEBPACK_IMPORTED_MODULE_8___default().shape({
    Input: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().elementType),
    Mark: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().elementType),
    MarkLabel: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().elementType),
    Rail: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().elementType),
    Root: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().elementType),
    Thumb: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().elementType),
    Track: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().elementType),
    ValueLabel: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().elementType)
  }),
  /**
   * The extra props for the slot components.
   * You can override the existing props or add new ones.
   *
   * This prop is an alias for the `slotProps` prop.
   * It's recommended to use the `slotProps` prop instead, as `componentsProps` will be deprecated in the future.
   *
   * @default {}
   */
  componentsProps: prop_types__WEBPACK_IMPORTED_MODULE_8___default().shape({
    input: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_8___default().func), (prop_types__WEBPACK_IMPORTED_MODULE_8___default().object)]),
    mark: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_8___default().func), (prop_types__WEBPACK_IMPORTED_MODULE_8___default().object)]),
    markLabel: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_8___default().func), (prop_types__WEBPACK_IMPORTED_MODULE_8___default().object)]),
    rail: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_8___default().func), (prop_types__WEBPACK_IMPORTED_MODULE_8___default().object)]),
    root: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_8___default().func), (prop_types__WEBPACK_IMPORTED_MODULE_8___default().object)]),
    thumb: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_8___default().func), (prop_types__WEBPACK_IMPORTED_MODULE_8___default().object)]),
    track: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_8___default().func), (prop_types__WEBPACK_IMPORTED_MODULE_8___default().object)]),
    valueLabel: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_8___default().func), prop_types__WEBPACK_IMPORTED_MODULE_8___default().shape({
      children: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().element),
      className: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().string),
      open: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().bool),
      style: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().object),
      value: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number),
      valueLabelDisplay: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOf(['auto', 'off', 'on'])
    })])
  }),
  /**
   * The default value. Use when the component is not controlled.
   */
  defaultValue: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_8___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_8___default().number)), (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number)]),
  /**
   * If `true`, the component is disabled.
   * @default false
   */
  disabled: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().bool),
  /**
   * If `true`, the active thumb doesn't swap when moving pointer over a thumb while dragging another thumb.
   * @default false
   */
  disableSwap: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().bool),
  /**
   * Accepts a function which returns a string value that provides a user-friendly name for the thumb labels of the slider.
   * This is important for screen reader users.
   * @param {number} index The thumb label's index to format.
   * @returns {string}
   */
  getAriaLabel: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().func),
  /**
   * Accepts a function which returns a string value that provides a user-friendly name for the current value of the slider.
   * This is important for screen reader users.
   * @param {number} value The thumb label's value to format.
   * @param {number} index The thumb label's index to format.
   * @returns {string}
   */
  getAriaValueText: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().func),
  /**
   * Marks indicate predetermined values to which the user can move the slider.
   * If `true` the marks are spaced according the value of the `step` prop.
   * If an array, it should contain objects with `value` and an optional `label` keys.
   * @default false
   */
  marks: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_8___default().arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_8___default().shape({
    label: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().node),
    value: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number.isRequired)
  })), (prop_types__WEBPACK_IMPORTED_MODULE_8___default().bool)]),
  /**
   * The maximum allowed value of the slider.
   * Should not be equal to min.
   * @default 100
   */
  max: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number),
  /**
   * The minimum allowed value of the slider.
   * Should not be equal to max.
   * @default 0
   */
  min: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number),
  /**
   * Name attribute of the hidden `input` element.
   */
  name: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().string),
  /**
   * Callback function that is fired when the slider's value changed.
   *
   * @param {Event} event The event source of the callback.
   * You can pull out the new value by accessing `event.target.value` (any).
   * **Warning**: This is a generic event not a change event.
   * @param {number | number[]} value The new value.
   * @param {number} activeThumb Index of the currently moved thumb.
   */
  onChange: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().func),
  /**
   * Callback function that is fired when the `mouseup` is triggered.
   *
   * @param {React.SyntheticEvent | Event} event The event source of the callback. **Warning**: This is a generic event not a change event.
   * @param {number | number[]} value The new value.
   */
  onChangeCommitted: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().func),
  /**
   * The component orientation.
   * @default 'horizontal'
   */
  orientation: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOf(['horizontal', 'vertical']),
  /**
   * A transformation function, to change the scale of the slider.
   * @param {any} x
   * @returns {any}
   * @default function Identity(x) {
   *   return x;
   * }
   */
  scale: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().func),
  /**
   * The size of the slider.
   * @default 'medium'
   */
  size: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOf(['small', 'medium']), (prop_types__WEBPACK_IMPORTED_MODULE_8___default().string)]),
  /**
   * The props used for each slot inside the Slider.
   * @default {}
   */
  slotProps: prop_types__WEBPACK_IMPORTED_MODULE_8___default().shape({
    input: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_8___default().func), (prop_types__WEBPACK_IMPORTED_MODULE_8___default().object)]),
    mark: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_8___default().func), (prop_types__WEBPACK_IMPORTED_MODULE_8___default().object)]),
    markLabel: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_8___default().func), (prop_types__WEBPACK_IMPORTED_MODULE_8___default().object)]),
    rail: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_8___default().func), (prop_types__WEBPACK_IMPORTED_MODULE_8___default().object)]),
    root: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_8___default().func), (prop_types__WEBPACK_IMPORTED_MODULE_8___default().object)]),
    thumb: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_8___default().func), (prop_types__WEBPACK_IMPORTED_MODULE_8___default().object)]),
    track: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_8___default().func), (prop_types__WEBPACK_IMPORTED_MODULE_8___default().object)]),
    valueLabel: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_8___default().func), prop_types__WEBPACK_IMPORTED_MODULE_8___default().shape({
      children: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().element),
      className: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().string),
      open: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().bool),
      style: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().object),
      value: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number),
      valueLabelDisplay: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOf(['auto', 'off', 'on'])
    })])
  }),
  /**
   * The components used for each slot inside the Slider.
   * Either a string to use a HTML element or a component.
   * @default {}
   */
  slots: prop_types__WEBPACK_IMPORTED_MODULE_8___default().shape({
    input: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().elementType),
    mark: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().elementType),
    markLabel: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().elementType),
    rail: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().elementType),
    root: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().elementType),
    thumb: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().elementType),
    track: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().elementType),
    valueLabel: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().elementType)
  }),
  /**
   * The granularity with which the slider can step through values. (A "discrete" slider.)
   * The `min` prop serves as the origin for the valid values.
   * We recommend (max - min) to be evenly divisible by the step.
   *
   * When step is `null`, the thumb can only be slid onto marks provided with the `marks` prop.
   * @default 1
   */
  step: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number),
  /**
   * The system prop that allows defining system overrides as well as additional CSS styles.
   */
  sx: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_8___default().arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_8___default().func), (prop_types__WEBPACK_IMPORTED_MODULE_8___default().object), (prop_types__WEBPACK_IMPORTED_MODULE_8___default().bool)])), (prop_types__WEBPACK_IMPORTED_MODULE_8___default().func), (prop_types__WEBPACK_IMPORTED_MODULE_8___default().object)]),
  /**
   * Tab index attribute of the hidden `input` element.
   */
  tabIndex: (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number),
  /**
   * The track presentation:
   *
   * - `normal` the track will render a bar representing the slider value.
   * - `inverted` the track will render a bar representing the remaining slider value.
   * - `false` the track will render without a bar.
   * @default 'normal'
   */
  track: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOf(['inverted', 'normal', false]),
  /**
   * The value of the slider.
   * For ranged sliders, provide an array with two values.
   */
  value: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_8___default().arrayOf((prop_types__WEBPACK_IMPORTED_MODULE_8___default().number)), (prop_types__WEBPACK_IMPORTED_MODULE_8___default().number)]),
  /**
   * Controls when the value label is displayed:
   *
   * - `auto` the value label will display when the thumb is hovered or focused.
   * - `on` will display persistently.
   * - `off` will never display.
   * @default 'off'
   */
  valueLabelDisplay: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOf(['auto', 'off', 'on']),
  /**
   * The format function the value label's value.
   *
   * When a function is provided, it should have the following signature:
   *
   * - {number} value The value label's value to format
   * - {number} index The value label's index to format
   * @param {any} x
   * @returns {any}
   * @default function Identity(x) {
   *   return x;
   * }
   */
  valueLabelFormat: prop_types__WEBPACK_IMPORTED_MODULE_8___default().oneOfType([(prop_types__WEBPACK_IMPORTED_MODULE_8___default().func), (prop_types__WEBPACK_IMPORTED_MODULE_8___default().string)])
} : 0;
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Slider);

/***/ }),

/***/ "./node_modules/@mui/material/Slider/SliderValueLabel.js":
/*!***************************************************************!*\
  !*** ./node_modules/@mui/material/Slider/SliderValueLabel.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ SliderValueLabel)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! prop-types */ "./node_modules/prop-types/index.js");
/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(prop_types__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var clsx__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! clsx */ "./node_modules/clsx/dist/clsx.m.js");
/* harmony import */ var _sliderClasses__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sliderClasses */ "./node_modules/@mui/material/Slider/sliderClasses.js");
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react/jsx-runtime */ "./node_modules/react/jsx-runtime.js");






const useValueLabelClasses = props => {
  const {
    open
  } = props;
  const utilityClasses = {
    offset: (0,clsx__WEBPACK_IMPORTED_MODULE_1__["default"])(open && _sliderClasses__WEBPACK_IMPORTED_MODULE_3__["default"].valueLabelOpen),
    circle: _sliderClasses__WEBPACK_IMPORTED_MODULE_3__["default"].valueLabelCircle,
    label: _sliderClasses__WEBPACK_IMPORTED_MODULE_3__["default"].valueLabelLabel
  };
  return utilityClasses;
};

/**
 * @ignore - internal component.
 */
function SliderValueLabel(props) {
  const {
    children,
    className,
    value
  } = props;
  const classes = useValueLabelClasses(props);
  if (!children) {
    return null;
  }
  return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_0__.cloneElement(children, {
    className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__["default"])(children.props.className)
  }, /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsxs)(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, {
    children: [children.props.children, /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("span", {
      className: (0,clsx__WEBPACK_IMPORTED_MODULE_1__["default"])(classes.offset, className),
      "aria-hidden": true,
      children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("span", {
        className: classes.circle,
        children: /*#__PURE__*/(0,react_jsx_runtime__WEBPACK_IMPORTED_MODULE_2__.jsx)("span", {
          className: classes.label,
          children: value
        })
      })
    })]
  }));
}
 true ? SliderValueLabel.propTypes = {
  children: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().element.isRequired),
  className: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().string),
  value: (prop_types__WEBPACK_IMPORTED_MODULE_4___default().node)
} : 0;

/***/ }),

/***/ "./node_modules/@mui/material/Slider/sliderClasses.js":
/*!************************************************************!*\
  !*** ./node_modules/@mui/material/Slider/sliderClasses.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   "getSliderUtilityClass": () => (/* binding */ getSliderUtilityClass)
/* harmony export */ });
/* harmony import */ var _mui_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @mui/utils */ "./node_modules/@mui/utils/esm/generateUtilityClasses/generateUtilityClasses.js");
/* harmony import */ var _generateUtilityClass__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../generateUtilityClass */ "./node_modules/@mui/utils/esm/generateUtilityClass/generateUtilityClass.js");


function getSliderUtilityClass(slot) {
  return (0,_generateUtilityClass__WEBPACK_IMPORTED_MODULE_0__["default"])('MuiSlider', slot);
}
const sliderClasses = (0,_mui_utils__WEBPACK_IMPORTED_MODULE_1__["default"])('MuiSlider', ['root', 'active', 'colorPrimary', 'colorSecondary', 'disabled', 'dragging', 'focusVisible', 'mark', 'markActive', 'marked', 'markLabel', 'markLabelActive', 'rail', 'sizeSmall', 'thumb', 'thumbColorPrimary', 'thumbColorSecondary', 'track', 'trackInverted', 'trackFalse', 'thumbSizeSmall', 'valueLabel', 'valueLabelOpen', 'valueLabelCircle', 'valueLabelLabel', 'vertical']);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (sliderClasses);

/***/ }),

/***/ "./node_modules/@mui/material/utils/requirePropFactory.js":
/*!****************************************************************!*\
  !*** ./node_modules/@mui/material/utils/requirePropFactory.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _mui_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @mui/utils */ "./node_modules/@mui/utils/esm/requirePropFactory.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_mui_utils__WEBPACK_IMPORTED_MODULE_0__["default"]);

/***/ }),

/***/ "./node_modules/@mui/material/utils/shouldSpreadAdditionalProps.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@mui/material/utils/shouldSpreadAdditionalProps.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _mui_base__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @mui/base */ "./node_modules/@mui/base/utils/isHostComponent.js");

const shouldSpreadAdditionalProps = Slot => {
  return !Slot || !(0,_mui_base__WEBPACK_IMPORTED_MODULE_0__["default"])(Slot);
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (shouldSpreadAdditionalProps);

/***/ }),

/***/ "./node_modules/@mui/utils/esm/ownerDocument.js":
/*!******************************************************!*\
  !*** ./node_modules/@mui/utils/esm/ownerDocument.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ ownerDocument)
/* harmony export */ });
function ownerDocument(node) {
  return node && node.ownerDocument || document;
}

/***/ }),

/***/ "./node_modules/@mui/utils/esm/requirePropFactory.js":
/*!***********************************************************!*\
  !*** ./node_modules/@mui/utils/esm/requirePropFactory.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ requirePropFactory)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ "./node_modules/@babel/runtime/helpers/esm/extends.js");

function requirePropFactory(componentNameInError, Component) {
  if (false) {}

  // eslint-disable-next-line react/forbid-foreign-prop-types
  const prevPropTypes = Component ? (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__["default"])({}, Component.propTypes) : null;
  const requireProp = requiredProp => (props, propName, componentName, location, propFullName, ...args) => {
    const propFullNameSafe = propFullName || propName;
    const defaultTypeChecker = prevPropTypes == null ? void 0 : prevPropTypes[propFullNameSafe];
    if (defaultTypeChecker) {
      const typeCheckerResult = defaultTypeChecker(props, propName, componentName, location, propFullName, ...args);
      if (typeCheckerResult) {
        return typeCheckerResult;
      }
    }
    if (typeof props[propName] !== 'undefined' && !props[requiredProp]) {
      return new Error(`The prop \`${propFullNameSafe}\` of ` + `\`${componentNameInError}\` can only be used together with the \`${requiredProp}\` prop.`);
    }
    return null;
  };
  return requireProp;
}

/***/ }),

/***/ "./node_modules/@mui/utils/esm/useControlled.js":
/*!******************************************************!*\
  !*** ./node_modules/@mui/utils/esm/useControlled.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ useControlled)
/* harmony export */ });
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* eslint-disable react-hooks/rules-of-hooks, react-hooks/exhaustive-deps */

function useControlled({
  controlled,
  default: defaultProp,
  name,
  state = 'value'
}) {
  // isControlled is ignored in the hook dependency lists as it should never change.
  const {
    current: isControlled
  } = react__WEBPACK_IMPORTED_MODULE_0__.useRef(controlled !== undefined);
  const [valueState, setValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(defaultProp);
  const value = isControlled ? controlled : valueState;
  if (true) {
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
      if (isControlled !== (controlled !== undefined)) {
        console.error([`MUI: A component is changing the ${isControlled ? '' : 'un'}controlled ${state} state of ${name} to be ${isControlled ? 'un' : ''}controlled.`, 'Elements should not switch from uncontrolled to controlled (or vice versa).', `Decide between using a controlled or uncontrolled ${name} ` + 'element for the lifetime of the component.', "The nature of the state is determined during the first render. It's considered controlled if the value is not `undefined`.", 'More info: https://fb.me/react-controlled-components'].join('\n'));
      }
    }, [state, name, controlled]);
    const {
      current: defaultValue
    } = react__WEBPACK_IMPORTED_MODULE_0__.useRef(defaultProp);
    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {
      if (!isControlled && defaultValue !== defaultProp) {
        console.error([`MUI: A component is changing the default ${state} state of an uncontrolled ${name} after being initialized. ` + `To suppress this warning opt to use a controlled ${name}.`].join('\n'));
      }
    }, [JSON.stringify(defaultProp)]);
  }
  const setValueIfUncontrolled = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(newValue => {
    if (!isControlled) {
      setValue(newValue);
    }
  }, []);
  return [value, setValueIfUncontrolled];
}

/***/ }),

/***/ "./node_modules/@mui/utils/esm/visuallyHidden.js":
/*!*******************************************************!*\
  !*** ./node_modules/@mui/utils/esm/visuallyHidden.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const visuallyHidden = {
  border: 0,
  clip: 'rect(0 0 0 0)',
  height: '1px',
  margin: -1,
  overflow: 'hidden',
  padding: 0,
  position: 'absolute',
  whiteSpace: 'nowrap',
  width: '1px'
};
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (visuallyHidden);

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfbXVpX21hdGVyaWFsX0dyaWRfR3JpZF9qcy1ub2RlX21vZHVsZXNfbXVpX21hdGVyaWFsX1NsaWRlcl9TbGlkZXJfanMuNjcyYzAwNjFjOWIwMGU5Y2Y2YzkuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTBEO0FBQzNCO0FBQ21SO0FBQ2xUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0NBQXNDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxjQUFjLHNEQUFhO0FBQzNCO0FBQ0E7QUFDQSxpSUFBaUksWUFBWTtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLEtBQUs7QUFDTDtBQUNBLGdCQUFnQixRQUFRO0FBQ3hCLEtBQUs7QUFDTCxHQUFHO0FBQ0g7QUFDQTtBQUNBLGlCQUFpQixR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QUFDTDtBQUNBLGlDQUFpQyw4Q0FBaUI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBZSxjQUFjIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJval9fNDIvLi9ub2RlX21vZHVsZXMvQG11aS9iYXNlL1NsaWRlclVuc3R5bGVkL3VzZVNsaWRlci5qcyIsIndlYnBhY2s6Ly9wcm9qX180Mi8uL25vZGVfbW9kdWxlcy9AbXVpL2Jhc2UvdXRpbHMvYXBwZW5kT3duZXJTdGF0ZS5qcyIsIndlYnBhY2s6Ly9wcm9qX180Mi8uL25vZGVfbW9kdWxlcy9AbXVpL2Jhc2UvdXRpbHMvZXh0cmFjdEV2ZW50SGFuZGxlcnMuanMiLCJ3ZWJwYWNrOi8vcHJval9fNDIvLi9ub2RlX21vZHVsZXMvQG11aS9iYXNlL3V0aWxzL2lzSG9zdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly9wcm9qX180Mi8uL25vZGVfbW9kdWxlcy9AbXVpL2Jhc2UvdXRpbHMvbWVyZ2VTbG90UHJvcHMuanMiLCJ3ZWJwYWNrOi8vcHJval9fNDIvLi9ub2RlX21vZHVsZXMvQG11aS9iYXNlL3V0aWxzL29taXRFdmVudEhhbmRsZXJzLmpzIiwid2VicGFjazovL3Byb2pfXzQyLy4vbm9kZV9tb2R1bGVzL0BtdWkvYmFzZS91dGlscy9yZXNvbHZlQ29tcG9uZW50UHJvcHMuanMiLCJ3ZWJwYWNrOi8vcHJval9fNDIvLi9ub2RlX21vZHVsZXMvQG11aS9iYXNlL3V0aWxzL3VzZVNsb3RQcm9wcy5qcyIsIndlYnBhY2s6Ly9wcm9qX180Mi8uL25vZGVfbW9kdWxlcy9AbXVpL21hdGVyaWFsL0dyaWQvR3JpZC5qcyIsIndlYnBhY2s6Ly9wcm9qX180Mi8uL25vZGVfbW9kdWxlcy9AbXVpL21hdGVyaWFsL0dyaWQvR3JpZENvbnRleHQuanMiLCJ3ZWJwYWNrOi8vcHJval9fNDIvLi9ub2RlX21vZHVsZXMvQG11aS9tYXRlcmlhbC9HcmlkL2dyaWRDbGFzc2VzLmpzIiwid2VicGFjazovL3Byb2pfXzQyLy4vbm9kZV9tb2R1bGVzL0BtdWkvbWF0ZXJpYWwvU2xpZGVyL1NsaWRlci5qcyIsIndlYnBhY2s6Ly9wcm9qX180Mi8uL25vZGVfbW9kdWxlcy9AbXVpL21hdGVyaWFsL1NsaWRlci9TbGlkZXJWYWx1ZUxhYmVsLmpzIiwid2VicGFjazovL3Byb2pfXzQyLy4vbm9kZV9tb2R1bGVzL0BtdWkvbWF0ZXJpYWwvU2xpZGVyL3NsaWRlckNsYXNzZXMuanMiLCJ3ZWJwYWNrOi8vcHJval9fNDIvLi9ub2RlX21vZHVsZXMvQG11aS9tYXRlcmlhbC91dGlscy9yZXF1aXJlUHJvcEZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vcHJval9fNDIvLi9ub2RlX21vZHVsZXMvQG11aS9tYXRlcmlhbC91dGlscy9zaG91bGRTcHJlYWRBZGRpdGlvbmFsUHJvcHMuanMiLCJ3ZWJwYWNrOi8vcHJval9fNDIvLi9ub2RlX21vZHVsZXMvQG11aS91dGlscy9lc20vb3duZXJEb2N1bWVudC5qcyIsIndlYnBhY2s6Ly9wcm9qX180Mi8uL25vZGVfbW9kdWxlcy9AbXVpL3V0aWxzL2VzbS9yZXF1aXJlUHJvcEZhY3RvcnkuanMiLCJ3ZWJwYWNrOi8vcHJval9fNDIvLi9ub2RlX21vZHVsZXMvQG11aS91dGlscy9lc20vdXNlQ29udHJvbGxlZC5qcyIsIndlYnBhY2s6Ly9wcm9qX180Mi8uL25vZGVfbW9kdWxlcy9AbXVpL3V0aWxzL2VzbS92aXN1YWxseUhpZGRlbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVuc3RhYmxlX3VzZUlzRm9jdXNWaXNpYmxlIGFzIHVzZUlzRm9jdXNWaXNpYmxlLCB1bnN0YWJsZV91c2VFbmhhbmNlZEVmZmVjdCBhcyB1c2VFbmhhbmNlZEVmZmVjdCwgdW5zdGFibGVfb3duZXJEb2N1bWVudCBhcyBvd25lckRvY3VtZW50LCB1bnN0YWJsZV91c2VFdmVudENhbGxiYWNrIGFzIHVzZUV2ZW50Q2FsbGJhY2ssIHVuc3RhYmxlX3VzZUZvcmtSZWYgYXMgdXNlRm9ya1JlZiwgdW5zdGFibGVfdXNlQ29udHJvbGxlZCBhcyB1c2VDb250cm9sbGVkLCB2aXN1YWxseUhpZGRlbiB9IGZyb20gJ0BtdWkvdXRpbHMnO1xuY29uc3QgSU5URU5USU9OQUxfRFJBR19DT1VOVF9USFJFU0hPTEQgPSAyO1xuZnVuY3Rpb24gYXNjKGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiO1xufVxuZnVuY3Rpb24gY2xhbXAodmFsdWUsIG1pbiwgbWF4KSB7XG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG1pbjtcbiAgfVxuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobWluLCB2YWx1ZSksIG1heCk7XG59XG5mdW5jdGlvbiBmaW5kQ2xvc2VzdCh2YWx1ZXMsIGN1cnJlbnRWYWx1ZSkge1xuICB2YXIgX3ZhbHVlcyRyZWR1Y2U7XG4gIGNvbnN0IHtcbiAgICBpbmRleDogY2xvc2VzdEluZGV4XG4gIH0gPSAoX3ZhbHVlcyRyZWR1Y2UgPSB2YWx1ZXMucmVkdWNlKChhY2MsIHZhbHVlLCBpbmRleCkgPT4ge1xuICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5hYnMoY3VycmVudFZhbHVlIC0gdmFsdWUpO1xuICAgIGlmIChhY2MgPT09IG51bGwgfHwgZGlzdGFuY2UgPCBhY2MuZGlzdGFuY2UgfHwgZGlzdGFuY2UgPT09IGFjYy5kaXN0YW5jZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGlzdGFuY2UsXG4gICAgICAgIGluZGV4XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gYWNjO1xuICB9LCBudWxsKSkgIT0gbnVsbCA/IF92YWx1ZXMkcmVkdWNlIDoge307XG4gIHJldHVybiBjbG9zZXN0SW5kZXg7XG59XG5mdW5jdGlvbiB0cmFja0ZpbmdlcihldmVudCwgdG91Y2hJZCkge1xuICAvLyBUaGUgZXZlbnQgaXMgVG91Y2hFdmVudFxuICBpZiAodG91Y2hJZC5jdXJyZW50ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQuY2hhbmdlZFRvdWNoZXMpIHtcbiAgICBjb25zdCB0b3VjaEV2ZW50ID0gZXZlbnQ7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0b3VjaEV2ZW50LmNoYW5nZWRUb3VjaGVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjb25zdCB0b3VjaCA9IHRvdWNoRXZlbnQuY2hhbmdlZFRvdWNoZXNbaV07XG4gICAgICBpZiAodG91Y2guaWRlbnRpZmllciA9PT0gdG91Y2hJZC5jdXJyZW50KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgeDogdG91Y2guY2xpZW50WCxcbiAgICAgICAgICB5OiB0b3VjaC5jbGllbnRZXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIFRoZSBldmVudCBpcyBNb3VzZUV2ZW50XG4gIHJldHVybiB7XG4gICAgeDogZXZlbnQuY2xpZW50WCxcbiAgICB5OiBldmVudC5jbGllbnRZXG4gIH07XG59XG5leHBvcnQgZnVuY3Rpb24gdmFsdWVUb1BlcmNlbnQodmFsdWUsIG1pbiwgbWF4KSB7XG4gIHJldHVybiAodmFsdWUgLSBtaW4pICogMTAwIC8gKG1heCAtIG1pbik7XG59XG5mdW5jdGlvbiBwZXJjZW50VG9WYWx1ZShwZXJjZW50LCBtaW4sIG1heCkge1xuICByZXR1cm4gKG1heCAtIG1pbikgKiBwZXJjZW50ICsgbWluO1xufVxuZnVuY3Rpb24gZ2V0RGVjaW1hbFByZWNpc2lvbihudW0pIHtcbiAgLy8gVGhpcyBoYW5kbGVzIHRoZSBjYXNlIHdoZW4gbnVtIGlzIHZlcnkgc21hbGwgKDAuMDAwMDAwMDEpLCBqcyB3aWxsIHR1cm4gdGhpcyBpbnRvIDFlLTguXG4gIC8vIFdoZW4gbnVtIGlzIGJpZ2dlciB0aGFuIDEgb3IgbGVzcyB0aGFuIC0xIGl0IHdvbid0IGdldCBjb252ZXJ0ZWQgdG8gdGhpcyBub3RhdGlvbiBzbyBpdCdzIGZpbmUuXG4gIGlmIChNYXRoLmFicyhudW0pIDwgMSkge1xuICAgIGNvbnN0IHBhcnRzID0gbnVtLnRvRXhwb25lbnRpYWwoKS5zcGxpdCgnZS0nKTtcbiAgICBjb25zdCBtYXRpc3NhRGVjaW1hbFBhcnQgPSBwYXJ0c1swXS5zcGxpdCgnLicpWzFdO1xuICAgIHJldHVybiAobWF0aXNzYURlY2ltYWxQYXJ0ID8gbWF0aXNzYURlY2ltYWxQYXJ0Lmxlbmd0aCA6IDApICsgcGFyc2VJbnQocGFydHNbMV0sIDEwKTtcbiAgfVxuICBjb25zdCBkZWNpbWFsUGFydCA9IG51bS50b1N0cmluZygpLnNwbGl0KCcuJylbMV07XG4gIHJldHVybiBkZWNpbWFsUGFydCA/IGRlY2ltYWxQYXJ0Lmxlbmd0aCA6IDA7XG59XG5mdW5jdGlvbiByb3VuZFZhbHVlVG9TdGVwKHZhbHVlLCBzdGVwLCBtaW4pIHtcbiAgY29uc3QgbmVhcmVzdCA9IE1hdGgucm91bmQoKHZhbHVlIC0gbWluKSAvIHN0ZXApICogc3RlcCArIG1pbjtcbiAgcmV0dXJuIE51bWJlcihuZWFyZXN0LnRvRml4ZWQoZ2V0RGVjaW1hbFByZWNpc2lvbihzdGVwKSkpO1xufVxuZnVuY3Rpb24gc2V0VmFsdWVJbmRleCh7XG4gIHZhbHVlcyxcbiAgbmV3VmFsdWUsXG4gIGluZGV4XG59KSB7XG4gIGNvbnN0IG91dHB1dCA9IHZhbHVlcy5zbGljZSgpO1xuICBvdXRwdXRbaW5kZXhdID0gbmV3VmFsdWU7XG4gIHJldHVybiBvdXRwdXQuc29ydChhc2MpO1xufVxuZnVuY3Rpb24gZm9jdXNUaHVtYih7XG4gIHNsaWRlclJlZixcbiAgYWN0aXZlSW5kZXgsXG4gIHNldEFjdGl2ZVxufSkge1xuICB2YXIgX3NsaWRlclJlZiRjdXJyZW50LCBfZG9jJGFjdGl2ZUVsZW1lbnQ7XG4gIGNvbnN0IGRvYyA9IG93bmVyRG9jdW1lbnQoc2xpZGVyUmVmLmN1cnJlbnQpO1xuICBpZiAoISgoX3NsaWRlclJlZiRjdXJyZW50ID0gc2xpZGVyUmVmLmN1cnJlbnQpICE9IG51bGwgJiYgX3NsaWRlclJlZiRjdXJyZW50LmNvbnRhaW5zKGRvYy5hY3RpdmVFbGVtZW50KSkgfHwgTnVtYmVyKGRvYyA9PSBudWxsID8gdm9pZCAwIDogKF9kb2MkYWN0aXZlRWxlbWVudCA9IGRvYy5hY3RpdmVFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2RvYyRhY3RpdmVFbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1pbmRleCcpKSAhPT0gYWN0aXZlSW5kZXgpIHtcbiAgICB2YXIgX3NsaWRlclJlZiRjdXJyZW50MjtcbiAgICAoX3NsaWRlclJlZiRjdXJyZW50MiA9IHNsaWRlclJlZi5jdXJyZW50KSA9PSBudWxsID8gdm9pZCAwIDogX3NsaWRlclJlZiRjdXJyZW50Mi5xdWVyeVNlbGVjdG9yKGBbdHlwZT1cInJhbmdlXCJdW2RhdGEtaW5kZXg9XCIke2FjdGl2ZUluZGV4fVwiXWApLmZvY3VzKCk7XG4gIH1cbiAgaWYgKHNldEFjdGl2ZSkge1xuICAgIHNldEFjdGl2ZShhY3RpdmVJbmRleCk7XG4gIH1cbn1cbmNvbnN0IGF4aXNQcm9wcyA9IHtcbiAgaG9yaXpvbnRhbDoge1xuICAgIG9mZnNldDogcGVyY2VudCA9PiAoe1xuICAgICAgbGVmdDogYCR7cGVyY2VudH0lYFxuICAgIH0pLFxuICAgIGxlYXA6IHBlcmNlbnQgPT4gKHtcbiAgICAgIHdpZHRoOiBgJHtwZXJjZW50fSVgXG4gICAgfSlcbiAgfSxcbiAgJ2hvcml6b250YWwtcmV2ZXJzZSc6IHtcbiAgICBvZmZzZXQ6IHBlcmNlbnQgPT4gKHtcbiAgICAgIHJpZ2h0OiBgJHtwZXJjZW50fSVgXG4gICAgfSksXG4gICAgbGVhcDogcGVyY2VudCA9PiAoe1xuICAgICAgd2lkdGg6IGAke3BlcmNlbnR9JWBcbiAgICB9KVxuICB9LFxuICB2ZXJ0aWNhbDoge1xuICAgIG9mZnNldDogcGVyY2VudCA9PiAoe1xuICAgICAgYm90dG9tOiBgJHtwZXJjZW50fSVgXG4gICAgfSksXG4gICAgbGVhcDogcGVyY2VudCA9PiAoe1xuICAgICAgaGVpZ2h0OiBgJHtwZXJjZW50fSVgXG4gICAgfSlcbiAgfVxufTtcbmV4cG9ydCBjb25zdCBJZGVudGl0eSA9IHggPT4geDtcblxuLy8gVE9ETzogcmVtb3ZlIHN1cHBvcnQgZm9yIFNhZmFyaSA8IDEzLlxuLy8gaHR0cHM6Ly9jYW5pdXNlLmNvbS8jc2VhcmNoPXRvdWNoLWFjdGlvblxuLy9cbi8vIFNhZmFyaSwgb24gaU9TLCBzdXBwb3J0cyB0b3VjaCBhY3Rpb24gc2luY2UgdjEzLlxuLy8gT3ZlciA4MCUgb2YgdGhlIGlPUyBwaG9uZXMgYXJlIGNvbXBhdGlibGVcbi8vIGluIEF1Z3VzdCAyMDIwLlxuLy8gVXRpbGl6aW5nIHRoZSBDU1Muc3VwcG9ydHMgbWV0aG9kIHRvIGNoZWNrIGlmIHRvdWNoLWFjdGlvbiBpcyBzdXBwb3J0ZWQuXG4vLyBTaW5jZSBDU1Muc3VwcG9ydHMgaXMgc3VwcG9ydGVkIG9uIGFsbCBidXQgRWRnZUAxMiBhbmQgSUUgYW5kIHRvdWNoLWFjdGlvblxuLy8gaXMgc3VwcG9ydGVkIG9uIGJvdGggRWRnZUAxMiBhbmQgSUUgaWYgQ1NTLnN1cHBvcnRzIGlzIG5vdCBhdmFpbGFibGUgdGhhdCBtZWFucyB0aGF0XG4vLyB0b3VjaC1hY3Rpb24gd2lsbCBiZSBzdXBwb3J0ZWRcbmxldCBjYWNoZWRTdXBwb3J0c1RvdWNoQWN0aW9uTm9uZTtcbmZ1bmN0aW9uIGRvZXNTdXBwb3J0VG91Y2hBY3Rpb25Ob25lKCkge1xuICBpZiAoY2FjaGVkU3VwcG9ydHNUb3VjaEFjdGlvbk5vbmUgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgQ1NTICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgQ1NTLnN1cHBvcnRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWNoZWRTdXBwb3J0c1RvdWNoQWN0aW9uTm9uZSA9IENTUy5zdXBwb3J0cygndG91Y2gtYWN0aW9uJywgJ25vbmUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FjaGVkU3VwcG9ydHNUb3VjaEFjdGlvbk5vbmUgPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2FjaGVkU3VwcG9ydHNUb3VjaEFjdGlvbk5vbmU7XG59XG4vKipcbiAqXG4gKiBEZW1vczpcbiAqXG4gKiAtIFtVbnN0eWxlZCBTbGlkZXJdKGh0dHBzOi8vbXVpLmNvbS9iYXNlL3JlYWN0LXNsaWRlci8jaG9vaylcbiAqXG4gKiBBUEk6XG4gKlxuICogLSBbdXNlU2xpZGVyIEFQSV0oaHR0cHM6Ly9tdWkuY29tL2Jhc2UvYXBpL3VzZS1zbGlkZXIvKVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VTbGlkZXIocGFyYW1ldGVycykge1xuICBjb25zdCB7XG4gICAgJ2FyaWEtbGFiZWxsZWRieSc6IGFyaWFMYWJlbGxlZGJ5LFxuICAgIGRlZmF1bHRWYWx1ZSxcbiAgICBkaXNhYmxlZCA9IGZhbHNlLFxuICAgIGRpc2FibGVTd2FwID0gZmFsc2UsXG4gICAgaXNSdGwgPSBmYWxzZSxcbiAgICBtYXJrczogbWFya3NQcm9wID0gZmFsc2UsXG4gICAgbWF4ID0gMTAwLFxuICAgIG1pbiA9IDAsXG4gICAgbmFtZSxcbiAgICBvbkNoYW5nZSxcbiAgICBvbkNoYW5nZUNvbW1pdHRlZCxcbiAgICBvcmllbnRhdGlvbiA9ICdob3Jpem9udGFsJyxcbiAgICByZWYsXG4gICAgc2NhbGUgPSBJZGVudGl0eSxcbiAgICBzdGVwID0gMSxcbiAgICB0YWJJbmRleCxcbiAgICB2YWx1ZTogdmFsdWVQcm9wXG4gIH0gPSBwYXJhbWV0ZXJzO1xuICBjb25zdCB0b3VjaElkID0gUmVhY3QudXNlUmVmKCk7XG4gIC8vIFdlIGNhbid0IHVzZSB0aGUgOmFjdGl2ZSBicm93c2VyIHBzZXVkby1jbGFzc2VzLlxuICAvLyAtIFRoZSBhY3RpdmUgc3RhdGUgaXNuJ3QgdHJpZ2dlcmVkIHdoZW4gY2xpY2tpbmcgb24gdGhlIHJhaWwuXG4gIC8vIC0gVGhlIGFjdGl2ZSBzdGF0ZSBpc24ndCB0cmFuc2ZlcnJlZCB3aGVuIGludmVyc2luZyBhIHJhbmdlIHNsaWRlci5cbiAgY29uc3QgW2FjdGl2ZSwgc2V0QWN0aXZlXSA9IFJlYWN0LnVzZVN0YXRlKC0xKTtcbiAgY29uc3QgW29wZW4sIHNldE9wZW5dID0gUmVhY3QudXNlU3RhdGUoLTEpO1xuICBjb25zdCBbZHJhZ2dpbmcsIHNldERyYWdnaW5nXSA9IFJlYWN0LnVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgbW92ZUNvdW50ID0gUmVhY3QudXNlUmVmKDApO1xuICBjb25zdCBbdmFsdWVEZXJpdmVkLCBzZXRWYWx1ZVN0YXRlXSA9IHVzZUNvbnRyb2xsZWQoe1xuICAgIGNvbnRyb2xsZWQ6IHZhbHVlUHJvcCxcbiAgICBkZWZhdWx0OiBkZWZhdWx0VmFsdWUgIT0gbnVsbCA/IGRlZmF1bHRWYWx1ZSA6IG1pbixcbiAgICBuYW1lOiAnU2xpZGVyJ1xuICB9KTtcbiAgY29uc3QgaGFuZGxlQ2hhbmdlID0gb25DaGFuZ2UgJiYgKChldmVudCwgdmFsdWUsIHRodW1iSW5kZXgpID0+IHtcbiAgICAvLyBSZWRlZmluZSB0YXJnZXQgdG8gYWxsb3cgbmFtZSBhbmQgdmFsdWUgdG8gYmUgcmVhZC5cbiAgICAvLyBUaGlzIGFsbG93cyBzZWFtbGVzcyBpbnRlZ3JhdGlvbiB3aXRoIHRoZSBtb3N0IHBvcHVsYXIgZm9ybSBsaWJyYXJpZXMuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL211aS9tYXRlcmlhbC11aS9pc3N1ZXMvMTM0ODUjaXNzdWVjb21tZW50LTY3NjA0ODQ5MlxuICAgIC8vIENsb25lIHRoZSBldmVudCB0byBub3Qgb3ZlcnJpZGUgYHRhcmdldGAgb2YgdGhlIG9yaWdpbmFsIGV2ZW50LlxuICAgIGNvbnN0IG5hdGl2ZUV2ZW50ID0gZXZlbnQubmF0aXZlRXZlbnQgfHwgZXZlbnQ7XG4gICAgLy8gQHRzLWlnbm9yZSBUaGUgbmF0aXZlRXZlbnQgaXMgZnVuY3Rpb24sIG5vdCBvYmplY3RcbiAgICBjb25zdCBjbG9uZWRFdmVudCA9IG5ldyBuYXRpdmVFdmVudC5jb25zdHJ1Y3RvcihuYXRpdmVFdmVudC50eXBlLCBuYXRpdmVFdmVudCk7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsb25lZEV2ZW50LCAndGFyZ2V0Jywge1xuICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICB2YWx1ZToge1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgbmFtZVxuICAgICAgfVxuICAgIH0pO1xuICAgIG9uQ2hhbmdlKGNsb25lZEV2ZW50LCB2YWx1ZSwgdGh1bWJJbmRleCk7XG4gIH0pO1xuICBjb25zdCByYW5nZSA9IEFycmF5LmlzQXJyYXkodmFsdWVEZXJpdmVkKTtcbiAgbGV0IHZhbHVlcyA9IHJhbmdlID8gdmFsdWVEZXJpdmVkLnNsaWNlKCkuc29ydChhc2MpIDogW3ZhbHVlRGVyaXZlZF07XG4gIHZhbHVlcyA9IHZhbHVlcy5tYXAodmFsdWUgPT4gY2xhbXAodmFsdWUsIG1pbiwgbWF4KSk7XG4gIGNvbnN0IG1hcmtzID0gbWFya3NQcm9wID09PSB0cnVlICYmIHN0ZXAgIT09IG51bGwgPyBbLi4uQXJyYXkoTWF0aC5mbG9vcigobWF4IC0gbWluKSAvIHN0ZXApICsgMSldLm1hcCgoXywgaW5kZXgpID0+ICh7XG4gICAgdmFsdWU6IG1pbiArIHN0ZXAgKiBpbmRleFxuICB9KSkgOiBtYXJrc1Byb3AgfHwgW107XG4gIGNvbnN0IG1hcmtzVmFsdWVzID0gbWFya3MubWFwKG1hcmsgPT4gbWFyay52YWx1ZSk7XG4gIGNvbnN0IHtcbiAgICBpc0ZvY3VzVmlzaWJsZVJlZixcbiAgICBvbkJsdXI6IGhhbmRsZUJsdXJWaXNpYmxlLFxuICAgIG9uRm9jdXM6IGhhbmRsZUZvY3VzVmlzaWJsZSxcbiAgICByZWY6IGZvY3VzVmlzaWJsZVJlZlxuICB9ID0gdXNlSXNGb2N1c1Zpc2libGUoKTtcbiAgY29uc3QgW2ZvY3VzZWRUaHVtYkluZGV4LCBzZXRGb2N1c2VkVGh1bWJJbmRleF0gPSBSZWFjdC51c2VTdGF0ZSgtMSk7XG4gIGNvbnN0IHNsaWRlclJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBoYW5kbGVGb2N1c1JlZiA9IHVzZUZvcmtSZWYoZm9jdXNWaXNpYmxlUmVmLCBzbGlkZXJSZWYpO1xuICBjb25zdCBoYW5kbGVSZWYgPSB1c2VGb3JrUmVmKHJlZiwgaGFuZGxlRm9jdXNSZWYpO1xuICBjb25zdCBjcmVhdGVIYW5kbGVIaWRkZW5JbnB1dEZvY3VzID0gb3RoZXJIYW5kbGVycyA9PiBldmVudCA9PiB7XG4gICAgdmFyIF9vdGhlckhhbmRsZXJzJG9uRm9jdTtcbiAgICBjb25zdCBpbmRleCA9IE51bWJlcihldmVudC5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1pbmRleCcpKTtcbiAgICBoYW5kbGVGb2N1c1Zpc2libGUoZXZlbnQpO1xuICAgIGlmIChpc0ZvY3VzVmlzaWJsZVJlZi5jdXJyZW50ID09PSB0cnVlKSB7XG4gICAgICBzZXRGb2N1c2VkVGh1bWJJbmRleChpbmRleCk7XG4gICAgfVxuICAgIHNldE9wZW4oaW5kZXgpO1xuICAgIG90aGVySGFuZGxlcnMgPT0gbnVsbCA/IHZvaWQgMCA6IChfb3RoZXJIYW5kbGVycyRvbkZvY3UgPSBvdGhlckhhbmRsZXJzLm9uRm9jdXMpID09IG51bGwgPyB2b2lkIDAgOiBfb3RoZXJIYW5kbGVycyRvbkZvY3UuY2FsbChvdGhlckhhbmRsZXJzLCBldmVudCk7XG4gIH07XG4gIGNvbnN0IGNyZWF0ZUhhbmRsZUhpZGRlbklucHV0Qmx1ciA9IG90aGVySGFuZGxlcnMgPT4gZXZlbnQgPT4ge1xuICAgIHZhciBfb3RoZXJIYW5kbGVycyRvbkJsdXI7XG4gICAgaGFuZGxlQmx1clZpc2libGUoZXZlbnQpO1xuICAgIGlmIChpc0ZvY3VzVmlzaWJsZVJlZi5jdXJyZW50ID09PSBmYWxzZSkge1xuICAgICAgc2V0Rm9jdXNlZFRodW1iSW5kZXgoLTEpO1xuICAgIH1cbiAgICBzZXRPcGVuKC0xKTtcbiAgICBvdGhlckhhbmRsZXJzID09IG51bGwgPyB2b2lkIDAgOiAoX290aGVySGFuZGxlcnMkb25CbHVyID0gb3RoZXJIYW5kbGVycy5vbkJsdXIpID09IG51bGwgPyB2b2lkIDAgOiBfb3RoZXJIYW5kbGVycyRvbkJsdXIuY2FsbChvdGhlckhhbmRsZXJzLCBldmVudCk7XG4gIH07XG4gIHVzZUVuaGFuY2VkRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQgJiYgc2xpZGVyUmVmLmN1cnJlbnQuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIHZhciBfZG9jdW1lbnQkYWN0aXZlRWxlbWU7XG4gICAgICAvLyBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIEZpcmVmb3ggYW5kIFNhZmFyaSB3aWxsIGtlZXAgZm9jdXNcbiAgICAgIC8vIG9uIGEgZGlzYWJsZWQgZWxlbWVudDpcbiAgICAgIC8vIGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9tdWktcHItMjIyNDctZm9ya2VkLWgxNTFoP2ZpbGU9L3NyYy9BcHAuanNcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIChfZG9jdW1lbnQkYWN0aXZlRWxlbWUgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2RvY3VtZW50JGFjdGl2ZUVsZW1lLmJsdXIoKTtcbiAgICB9XG4gIH0sIFtkaXNhYmxlZF0pO1xuICBpZiAoZGlzYWJsZWQgJiYgYWN0aXZlICE9PSAtMSkge1xuICAgIHNldEFjdGl2ZSgtMSk7XG4gIH1cbiAgaWYgKGRpc2FibGVkICYmIGZvY3VzZWRUaHVtYkluZGV4ICE9PSAtMSkge1xuICAgIHNldEZvY3VzZWRUaHVtYkluZGV4KC0xKTtcbiAgfVxuICBjb25zdCBjcmVhdGVIYW5kbGVIaWRkZW5JbnB1dENoYW5nZSA9IG90aGVySGFuZGxlcnMgPT4gZXZlbnQgPT4ge1xuICAgIHZhciBfb3RoZXJIYW5kbGVycyRvbkNoYW47XG4gICAgKF9vdGhlckhhbmRsZXJzJG9uQ2hhbiA9IG90aGVySGFuZGxlcnMub25DaGFuZ2UpID09IG51bGwgPyB2b2lkIDAgOiBfb3RoZXJIYW5kbGVycyRvbkNoYW4uY2FsbChvdGhlckhhbmRsZXJzLCBldmVudCk7XG4gICAgY29uc3QgaW5kZXggPSBOdW1iZXIoZXZlbnQuY3VycmVudFRhcmdldC5nZXRBdHRyaWJ1dGUoJ2RhdGEtaW5kZXgnKSk7XG4gICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaW5kZXhdO1xuICAgIGNvbnN0IG1hcmtzSW5kZXggPSBtYXJrc1ZhbHVlcy5pbmRleE9mKHZhbHVlKTtcblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBsZXQgbmV3VmFsdWUgPSBldmVudC50YXJnZXQudmFsdWVBc051bWJlcjtcbiAgICBpZiAobWFya3MgJiYgc3RlcCA9PSBudWxsKSB7XG4gICAgICBuZXdWYWx1ZSA9IG5ld1ZhbHVlIDwgdmFsdWUgPyBtYXJrc1ZhbHVlc1ttYXJrc0luZGV4IC0gMV0gOiBtYXJrc1ZhbHVlc1ttYXJrc0luZGV4ICsgMV07XG4gICAgfVxuICAgIG5ld1ZhbHVlID0gY2xhbXAobmV3VmFsdWUsIG1pbiwgbWF4KTtcbiAgICBpZiAobWFya3MgJiYgc3RlcCA9PSBudWxsKSB7XG4gICAgICBjb25zdCBjdXJyZW50TWFya0luZGV4ID0gbWFya3NWYWx1ZXMuaW5kZXhPZih2YWx1ZXNbaW5kZXhdKTtcbiAgICAgIG5ld1ZhbHVlID0gbmV3VmFsdWUgPCB2YWx1ZXNbaW5kZXhdID8gbWFya3NWYWx1ZXNbY3VycmVudE1hcmtJbmRleCAtIDFdIDogbWFya3NWYWx1ZXNbY3VycmVudE1hcmtJbmRleCArIDFdO1xuICAgIH1cbiAgICBpZiAocmFuZ2UpIHtcbiAgICAgIC8vIEJvdW5kIHRoZSBuZXcgdmFsdWUgdG8gdGhlIHRodW1iJ3MgbmVpZ2hib3Vycy5cbiAgICAgIGlmIChkaXNhYmxlU3dhcCkge1xuICAgICAgICBuZXdWYWx1ZSA9IGNsYW1wKG5ld1ZhbHVlLCB2YWx1ZXNbaW5kZXggLSAxXSB8fCAtSW5maW5pdHksIHZhbHVlc1tpbmRleCArIDFdIHx8IEluZmluaXR5KTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSBuZXdWYWx1ZTtcbiAgICAgIG5ld1ZhbHVlID0gc2V0VmFsdWVJbmRleCh7XG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgIGluZGV4XG4gICAgICB9KTtcbiAgICAgIGxldCBhY3RpdmVJbmRleCA9IGluZGV4O1xuXG4gICAgICAvLyBQb3RlbnRpYWxseSBzd2FwIHRoZSBpbmRleCBpZiBuZWVkZWQuXG4gICAgICBpZiAoIWRpc2FibGVTd2FwKSB7XG4gICAgICAgIGFjdGl2ZUluZGV4ID0gbmV3VmFsdWUuaW5kZXhPZihwcmV2aW91c1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGZvY3VzVGh1bWIoe1xuICAgICAgICBzbGlkZXJSZWYsXG4gICAgICAgIGFjdGl2ZUluZGV4XG4gICAgICB9KTtcbiAgICB9XG4gICAgc2V0VmFsdWVTdGF0ZShuZXdWYWx1ZSk7XG4gICAgc2V0Rm9jdXNlZFRodW1iSW5kZXgoaW5kZXgpO1xuICAgIGlmIChoYW5kbGVDaGFuZ2UpIHtcbiAgICAgIGhhbmRsZUNoYW5nZShldmVudCwgbmV3VmFsdWUsIGluZGV4KTtcbiAgICB9XG4gICAgaWYgKG9uQ2hhbmdlQ29tbWl0dGVkKSB7XG4gICAgICBvbkNoYW5nZUNvbW1pdHRlZChldmVudCwgbmV3VmFsdWUpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgcHJldmlvdXNJbmRleCA9IFJlYWN0LnVzZVJlZigpO1xuICBsZXQgYXhpcyA9IG9yaWVudGF0aW9uO1xuICBpZiAoaXNSdGwgJiYgb3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJykge1xuICAgIGF4aXMgKz0gJy1yZXZlcnNlJztcbiAgfVxuICBjb25zdCBnZXRGaW5nZXJOZXdWYWx1ZSA9ICh7XG4gICAgZmluZ2VyLFxuICAgIG1vdmUgPSBmYWxzZVxuICB9KSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY3VycmVudDogc2xpZGVyXG4gICAgfSA9IHNsaWRlclJlZjtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGJvdHRvbSxcbiAgICAgIGxlZnRcbiAgICB9ID0gc2xpZGVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCBwZXJjZW50O1xuICAgIGlmIChheGlzLmluZGV4T2YoJ3ZlcnRpY2FsJykgPT09IDApIHtcbiAgICAgIHBlcmNlbnQgPSAoYm90dG9tIC0gZmluZ2VyLnkpIC8gaGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBwZXJjZW50ID0gKGZpbmdlci54IC0gbGVmdCkgLyB3aWR0aDtcbiAgICB9XG4gICAgaWYgKGF4aXMuaW5kZXhPZignLXJldmVyc2UnKSAhPT0gLTEpIHtcbiAgICAgIHBlcmNlbnQgPSAxIC0gcGVyY2VudDtcbiAgICB9XG4gICAgbGV0IG5ld1ZhbHVlO1xuICAgIG5ld1ZhbHVlID0gcGVyY2VudFRvVmFsdWUocGVyY2VudCwgbWluLCBtYXgpO1xuICAgIGlmIChzdGVwKSB7XG4gICAgICBuZXdWYWx1ZSA9IHJvdW5kVmFsdWVUb1N0ZXAobmV3VmFsdWUsIHN0ZXAsIG1pbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNsb3Nlc3RJbmRleCA9IGZpbmRDbG9zZXN0KG1hcmtzVmFsdWVzLCBuZXdWYWx1ZSk7XG4gICAgICBuZXdWYWx1ZSA9IG1hcmtzVmFsdWVzW2Nsb3Nlc3RJbmRleF07XG4gICAgfVxuICAgIG5ld1ZhbHVlID0gY2xhbXAobmV3VmFsdWUsIG1pbiwgbWF4KTtcbiAgICBsZXQgYWN0aXZlSW5kZXggPSAwO1xuICAgIGlmIChyYW5nZSkge1xuICAgICAgaWYgKCFtb3ZlKSB7XG4gICAgICAgIGFjdGl2ZUluZGV4ID0gZmluZENsb3Nlc3QodmFsdWVzLCBuZXdWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmVJbmRleCA9IHByZXZpb3VzSW5kZXguY3VycmVudDtcbiAgICAgIH1cblxuICAgICAgLy8gQm91bmQgdGhlIG5ldyB2YWx1ZSB0byB0aGUgdGh1bWIncyBuZWlnaGJvdXJzLlxuICAgICAgaWYgKGRpc2FibGVTd2FwKSB7XG4gICAgICAgIG5ld1ZhbHVlID0gY2xhbXAobmV3VmFsdWUsIHZhbHVlc1thY3RpdmVJbmRleCAtIDFdIHx8IC1JbmZpbml0eSwgdmFsdWVzW2FjdGl2ZUluZGV4ICsgMV0gfHwgSW5maW5pdHkpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHJldmlvdXNWYWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgbmV3VmFsdWUgPSBzZXRWYWx1ZUluZGV4KHtcbiAgICAgICAgdmFsdWVzLFxuICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgaW5kZXg6IGFjdGl2ZUluZGV4XG4gICAgICB9KTtcblxuICAgICAgLy8gUG90ZW50aWFsbHkgc3dhcCB0aGUgaW5kZXggaWYgbmVlZGVkLlxuICAgICAgaWYgKCEoZGlzYWJsZVN3YXAgJiYgbW92ZSkpIHtcbiAgICAgICAgYWN0aXZlSW5kZXggPSBuZXdWYWx1ZS5pbmRleE9mKHByZXZpb3VzVmFsdWUpO1xuICAgICAgICBwcmV2aW91c0luZGV4LmN1cnJlbnQgPSBhY3RpdmVJbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG5ld1ZhbHVlLFxuICAgICAgYWN0aXZlSW5kZXhcbiAgICB9O1xuICB9O1xuICBjb25zdCBoYW5kbGVUb3VjaE1vdmUgPSB1c2VFdmVudENhbGxiYWNrKG5hdGl2ZUV2ZW50ID0+IHtcbiAgICBjb25zdCBmaW5nZXIgPSB0cmFja0ZpbmdlcihuYXRpdmVFdmVudCwgdG91Y2hJZCk7XG4gICAgaWYgKCFmaW5nZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbW92ZUNvdW50LmN1cnJlbnQgKz0gMTtcblxuICAgIC8vIENhbmNlbCBtb3ZlIGluIGNhc2Ugc29tZSBvdGhlciBlbGVtZW50IGNvbnN1bWVkIGEgbW91c2V1cCBldmVudCBhbmQgaXQgd2FzIG5vdCBmaXJlZC5cbiAgICAvLyBAdHMtaWdub3JlIGJ1dHRvbnMgZG9lc24ndCBub3QgZXhpc3RzIG9uIHRvdWNoIGV2ZW50XG4gICAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdtb3VzZW1vdmUnICYmIG5hdGl2ZUV2ZW50LmJ1dHRvbnMgPT09IDApIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgIGhhbmRsZVRvdWNoRW5kKG5hdGl2ZUV2ZW50KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgbmV3VmFsdWUsXG4gICAgICBhY3RpdmVJbmRleFxuICAgIH0gPSBnZXRGaW5nZXJOZXdWYWx1ZSh7XG4gICAgICBmaW5nZXIsXG4gICAgICBtb3ZlOiB0cnVlXG4gICAgfSk7XG4gICAgZm9jdXNUaHVtYih7XG4gICAgICBzbGlkZXJSZWYsXG4gICAgICBhY3RpdmVJbmRleCxcbiAgICAgIHNldEFjdGl2ZVxuICAgIH0pO1xuICAgIHNldFZhbHVlU3RhdGUobmV3VmFsdWUpO1xuICAgIGlmICghZHJhZ2dpbmcgJiYgbW92ZUNvdW50LmN1cnJlbnQgPiBJTlRFTlRJT05BTF9EUkFHX0NPVU5UX1RIUkVTSE9MRCkge1xuICAgICAgc2V0RHJhZ2dpbmcodHJ1ZSk7XG4gICAgfVxuICAgIGlmIChoYW5kbGVDaGFuZ2UgJiYgbmV3VmFsdWUgIT09IHZhbHVlRGVyaXZlZCkge1xuICAgICAgaGFuZGxlQ2hhbmdlKG5hdGl2ZUV2ZW50LCBuZXdWYWx1ZSwgYWN0aXZlSW5kZXgpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGhhbmRsZVRvdWNoRW5kID0gdXNlRXZlbnRDYWxsYmFjayhuYXRpdmVFdmVudCA9PiB7XG4gICAgY29uc3QgZmluZ2VyID0gdHJhY2tGaW5nZXIobmF0aXZlRXZlbnQsIHRvdWNoSWQpO1xuICAgIHNldERyYWdnaW5nKGZhbHNlKTtcbiAgICBpZiAoIWZpbmdlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBuZXdWYWx1ZVxuICAgIH0gPSBnZXRGaW5nZXJOZXdWYWx1ZSh7XG4gICAgICBmaW5nZXIsXG4gICAgICBtb3ZlOiB0cnVlXG4gICAgfSk7XG4gICAgc2V0QWN0aXZlKC0xKTtcbiAgICBpZiAobmF0aXZlRXZlbnQudHlwZSA9PT0gJ3RvdWNoZW5kJykge1xuICAgICAgc2V0T3BlbigtMSk7XG4gICAgfVxuICAgIGlmIChvbkNoYW5nZUNvbW1pdHRlZCkge1xuICAgICAgb25DaGFuZ2VDb21taXR0ZWQobmF0aXZlRXZlbnQsIG5ld1ZhbHVlKTtcbiAgICB9XG4gICAgdG91Y2hJZC5jdXJyZW50ID0gdW5kZWZpbmVkO1xuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgIHN0b3BMaXN0ZW5pbmcoKTtcbiAgfSk7XG4gIGNvbnN0IGhhbmRsZVRvdWNoU3RhcnQgPSB1c2VFdmVudENhbGxiYWNrKG5hdGl2ZUV2ZW50ID0+IHtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gSWYgdG91Y2gtYWN0aW9uOiBub25lOyBpcyBub3Qgc3VwcG9ydGVkIHdlIG5lZWQgdG8gcHJldmVudCB0aGUgc2Nyb2xsIG1hbnVhbGx5LlxuICAgIGlmICghZG9lc1N1cHBvcnRUb3VjaEFjdGlvbk5vbmUoKSkge1xuICAgICAgbmF0aXZlRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gICAgY29uc3QgdG91Y2ggPSBuYXRpdmVFdmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICBpZiAodG91Y2ggIT0gbnVsbCkge1xuICAgICAgLy8gQSBudW1iZXIgdGhhdCB1bmlxdWVseSBpZGVudGlmaWVzIHRoZSBjdXJyZW50IGZpbmdlciBpbiB0aGUgdG91Y2ggc2Vzc2lvbi5cbiAgICAgIHRvdWNoSWQuY3VycmVudCA9IHRvdWNoLmlkZW50aWZpZXI7XG4gICAgfVxuICAgIGNvbnN0IGZpbmdlciA9IHRyYWNrRmluZ2VyKG5hdGl2ZUV2ZW50LCB0b3VjaElkKTtcbiAgICBpZiAoZmluZ2VyICE9PSBmYWxzZSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBuZXdWYWx1ZSxcbiAgICAgICAgYWN0aXZlSW5kZXhcbiAgICAgIH0gPSBnZXRGaW5nZXJOZXdWYWx1ZSh7XG4gICAgICAgIGZpbmdlclxuICAgICAgfSk7XG4gICAgICBmb2N1c1RodW1iKHtcbiAgICAgICAgc2xpZGVyUmVmLFxuICAgICAgICBhY3RpdmVJbmRleCxcbiAgICAgICAgc2V0QWN0aXZlXG4gICAgICB9KTtcbiAgICAgIHNldFZhbHVlU3RhdGUobmV3VmFsdWUpO1xuICAgICAgaWYgKGhhbmRsZUNoYW5nZSkge1xuICAgICAgICBoYW5kbGVDaGFuZ2UobmF0aXZlRXZlbnQsIG5ld1ZhbHVlLCBhY3RpdmVJbmRleCk7XG4gICAgICB9XG4gICAgfVxuICAgIG1vdmVDb3VudC5jdXJyZW50ID0gMDtcbiAgICBjb25zdCBkb2MgPSBvd25lckRvY3VtZW50KHNsaWRlclJlZi5jdXJyZW50KTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgaGFuZGxlVG91Y2hNb3ZlKTtcbiAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBoYW5kbGVUb3VjaEVuZCk7XG4gIH0pO1xuICBjb25zdCBzdG9wTGlzdGVuaW5nID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IGRvYyA9IG93bmVyRG9jdW1lbnQoc2xpZGVyUmVmLmN1cnJlbnQpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVUb3VjaE1vdmUpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgaGFuZGxlVG91Y2hFbmQpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaG1vdmUnLCBoYW5kbGVUb3VjaE1vdmUpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIGhhbmRsZVRvdWNoRW5kKTtcbiAgfSwgW2hhbmRsZVRvdWNoRW5kLCBoYW5kbGVUb3VjaE1vdmVdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBjdXJyZW50OiBzbGlkZXJcbiAgICB9ID0gc2xpZGVyUmVmO1xuICAgIHNsaWRlci5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgaGFuZGxlVG91Y2hTdGFydCwge1xuICAgICAgcGFzc2l2ZTogZG9lc1N1cHBvcnRUb3VjaEFjdGlvbk5vbmUoKVxuICAgIH0pO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBzbGlkZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGhhbmRsZVRvdWNoU3RhcnQsIHtcbiAgICAgICAgcGFzc2l2ZTogZG9lc1N1cHBvcnRUb3VjaEFjdGlvbk5vbmUoKVxuICAgICAgfSk7XG4gICAgICBzdG9wTGlzdGVuaW5nKCk7XG4gICAgfTtcbiAgfSwgW3N0b3BMaXN0ZW5pbmcsIGhhbmRsZVRvdWNoU3RhcnRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGlzYWJsZWQpIHtcbiAgICAgIHN0b3BMaXN0ZW5pbmcoKTtcbiAgICB9XG4gIH0sIFtkaXNhYmxlZCwgc3RvcExpc3RlbmluZ10pO1xuICBjb25zdCBjcmVhdGVIYW5kbGVNb3VzZURvd24gPSBvdGhlckhhbmRsZXJzID0+IGV2ZW50ID0+IHtcbiAgICB2YXIgX290aGVySGFuZGxlcnMkb25Nb3VzO1xuICAgIChfb3RoZXJIYW5kbGVycyRvbk1vdXMgPSBvdGhlckhhbmRsZXJzLm9uTW91c2VEb3duKSA9PSBudWxsID8gdm9pZCAwIDogX290aGVySGFuZGxlcnMkb25Nb3VzLmNhbGwob3RoZXJIYW5kbGVycywgZXZlbnQpO1xuICAgIGlmIChkaXNhYmxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIE9ubHkgaGFuZGxlIGxlZnQgY2xpY2tzXG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIEF2b2lkIHRleHQgc2VsZWN0aW9uXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBmaW5nZXIgPSB0cmFja0ZpbmdlcihldmVudCwgdG91Y2hJZCk7XG4gICAgaWYgKGZpbmdlciAhPT0gZmFsc2UpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmV3VmFsdWUsXG4gICAgICAgIGFjdGl2ZUluZGV4XG4gICAgICB9ID0gZ2V0RmluZ2VyTmV3VmFsdWUoe1xuICAgICAgICBmaW5nZXJcbiAgICAgIH0pO1xuICAgICAgZm9jdXNUaHVtYih7XG4gICAgICAgIHNsaWRlclJlZixcbiAgICAgICAgYWN0aXZlSW5kZXgsXG4gICAgICAgIHNldEFjdGl2ZVxuICAgICAgfSk7XG4gICAgICBzZXRWYWx1ZVN0YXRlKG5ld1ZhbHVlKTtcbiAgICAgIGlmIChoYW5kbGVDaGFuZ2UpIHtcbiAgICAgICAgaGFuZGxlQ2hhbmdlKGV2ZW50LCBuZXdWYWx1ZSwgYWN0aXZlSW5kZXgpO1xuICAgICAgfVxuICAgIH1cbiAgICBtb3ZlQ291bnQuY3VycmVudCA9IDA7XG4gICAgY29uc3QgZG9jID0gb3duZXJEb2N1bWVudChzbGlkZXJSZWYuY3VycmVudCk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZVRvdWNoTW92ZSk7XG4gICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBoYW5kbGVUb3VjaEVuZCk7XG4gIH07XG4gIGNvbnN0IHRyYWNrT2Zmc2V0ID0gdmFsdWVUb1BlcmNlbnQocmFuZ2UgPyB2YWx1ZXNbMF0gOiBtaW4sIG1pbiwgbWF4KTtcbiAgY29uc3QgdHJhY2tMZWFwID0gdmFsdWVUb1BlcmNlbnQodmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXSwgbWluLCBtYXgpIC0gdHJhY2tPZmZzZXQ7XG4gIGNvbnN0IGdldFJvb3RQcm9wcyA9IChvdGhlckhhbmRsZXJzID0ge30pID0+IHtcbiAgICBjb25zdCBvd25FdmVudEhhbmRsZXJzID0ge1xuICAgICAgb25Nb3VzZURvd246IGNyZWF0ZUhhbmRsZU1vdXNlRG93bihvdGhlckhhbmRsZXJzIHx8IHt9KVxuICAgIH07XG4gICAgY29uc3QgbWVyZ2VkRXZlbnRIYW5kbGVycyA9IF9leHRlbmRzKHt9LCBvdGhlckhhbmRsZXJzLCBvd25FdmVudEhhbmRsZXJzKTtcbiAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgcmVmOiBoYW5kbGVSZWZcbiAgICB9LCBtZXJnZWRFdmVudEhhbmRsZXJzKTtcbiAgfTtcbiAgY29uc3QgY3JlYXRlSGFuZGxlTW91c2VPdmVyID0gb3RoZXJIYW5kbGVycyA9PiBldmVudCA9PiB7XG4gICAgdmFyIF9vdGhlckhhbmRsZXJzJG9uTW91czI7XG4gICAgKF9vdGhlckhhbmRsZXJzJG9uTW91czIgPSBvdGhlckhhbmRsZXJzLm9uTW91c2VPdmVyKSA9PSBudWxsID8gdm9pZCAwIDogX290aGVySGFuZGxlcnMkb25Nb3VzMi5jYWxsKG90aGVySGFuZGxlcnMsIGV2ZW50KTtcbiAgICBjb25zdCBpbmRleCA9IE51bWJlcihldmVudC5jdXJyZW50VGFyZ2V0LmdldEF0dHJpYnV0ZSgnZGF0YS1pbmRleCcpKTtcbiAgICBzZXRPcGVuKGluZGV4KTtcbiAgfTtcbiAgY29uc3QgY3JlYXRlSGFuZGxlTW91c2VMZWF2ZSA9IG90aGVySGFuZGxlcnMgPT4gZXZlbnQgPT4ge1xuICAgIHZhciBfb3RoZXJIYW5kbGVycyRvbk1vdXMzO1xuICAgIChfb3RoZXJIYW5kbGVycyRvbk1vdXMzID0gb3RoZXJIYW5kbGVycy5vbk1vdXNlTGVhdmUpID09IG51bGwgPyB2b2lkIDAgOiBfb3RoZXJIYW5kbGVycyRvbk1vdXMzLmNhbGwob3RoZXJIYW5kbGVycywgZXZlbnQpO1xuICAgIHNldE9wZW4oLTEpO1xuICB9O1xuICBjb25zdCBnZXRUaHVtYlByb3BzID0gKG90aGVySGFuZGxlcnMgPSB7fSkgPT4ge1xuICAgIGNvbnN0IG93bkV2ZW50SGFuZGxlcnMgPSB7XG4gICAgICBvbk1vdXNlT3ZlcjogY3JlYXRlSGFuZGxlTW91c2VPdmVyKG90aGVySGFuZGxlcnMgfHwge30pLFxuICAgICAgb25Nb3VzZUxlYXZlOiBjcmVhdGVIYW5kbGVNb3VzZUxlYXZlKG90aGVySGFuZGxlcnMgfHwge30pXG4gICAgfTtcbiAgICByZXR1cm4gX2V4dGVuZHMoe30sIG90aGVySGFuZGxlcnMsIG93bkV2ZW50SGFuZGxlcnMpO1xuICB9O1xuICBjb25zdCBnZXRIaWRkZW5JbnB1dFByb3BzID0gKG90aGVySGFuZGxlcnMgPSB7fSkgPT4ge1xuICAgIHZhciBfcGFyYW1ldGVycyRzdGVwO1xuICAgIGNvbnN0IG93bkV2ZW50SGFuZGxlcnMgPSB7XG4gICAgICBvbkNoYW5nZTogY3JlYXRlSGFuZGxlSGlkZGVuSW5wdXRDaGFuZ2Uob3RoZXJIYW5kbGVycyB8fCB7fSksXG4gICAgICBvbkZvY3VzOiBjcmVhdGVIYW5kbGVIaWRkZW5JbnB1dEZvY3VzKG90aGVySGFuZGxlcnMgfHwge30pLFxuICAgICAgb25CbHVyOiBjcmVhdGVIYW5kbGVIaWRkZW5JbnB1dEJsdXIob3RoZXJIYW5kbGVycyB8fCB7fSlcbiAgICB9O1xuICAgIGNvbnN0IG1lcmdlZEV2ZW50SGFuZGxlcnMgPSBfZXh0ZW5kcyh7fSwgb3RoZXJIYW5kbGVycywgb3duRXZlbnRIYW5kbGVycyk7XG4gICAgcmV0dXJuIF9leHRlbmRzKHtcbiAgICAgIHRhYkluZGV4LFxuICAgICAgJ2FyaWEtbGFiZWxsZWRieSc6IGFyaWFMYWJlbGxlZGJ5LFxuICAgICAgJ2FyaWEtb3JpZW50YXRpb24nOiBvcmllbnRhdGlvbixcbiAgICAgICdhcmlhLXZhbHVlbWF4Jzogc2NhbGUobWF4KSxcbiAgICAgICdhcmlhLXZhbHVlbWluJzogc2NhbGUobWluKSxcbiAgICAgIG5hbWUsXG4gICAgICB0eXBlOiAncmFuZ2UnLFxuICAgICAgbWluOiBwYXJhbWV0ZXJzLm1pbixcbiAgICAgIG1heDogcGFyYW1ldGVycy5tYXgsXG4gICAgICBzdGVwOiAoX3BhcmFtZXRlcnMkc3RlcCA9IHBhcmFtZXRlcnMuc3RlcCkgIT0gbnVsbCA/IF9wYXJhbWV0ZXJzJHN0ZXAgOiB1bmRlZmluZWQsXG4gICAgICBkaXNhYmxlZFxuICAgIH0sIG1lcmdlZEV2ZW50SGFuZGxlcnMsIHtcbiAgICAgIHN0eWxlOiBfZXh0ZW5kcyh7fSwgdmlzdWFsbHlIaWRkZW4sIHtcbiAgICAgICAgZGlyZWN0aW9uOiBpc1J0bCA/ICdydGwnIDogJ2x0cicsXG4gICAgICAgIC8vIFNvIHRoYXQgVm9pY2VPdmVyJ3MgZm9jdXMgaW5kaWNhdG9yIG1hdGNoZXMgdGhlIHRodW1iJ3MgZGltZW5zaW9uc1xuICAgICAgICB3aWR0aDogJzEwMCUnLFxuICAgICAgICBoZWlnaHQ6ICcxMDAlJ1xuICAgICAgfSlcbiAgICB9KTtcbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBhY3RpdmUsXG4gICAgYXhpczogYXhpcyxcbiAgICBheGlzUHJvcHMsXG4gICAgZHJhZ2dpbmcsXG4gICAgZm9jdXNlZFRodW1iSW5kZXgsXG4gICAgZ2V0SGlkZGVuSW5wdXRQcm9wcyxcbiAgICBnZXRSb290UHJvcHMsXG4gICAgZ2V0VGh1bWJQcm9wcyxcbiAgICBtYXJrczogbWFya3MsXG4gICAgb3BlbixcbiAgICByYW5nZSxcbiAgICB0cmFja0xlYXAsXG4gICAgdHJhY2tPZmZzZXQsXG4gICAgdmFsdWVzXG4gIH07XG59IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgaXNIb3N0Q29tcG9uZW50IGZyb20gJy4vaXNIb3N0Q29tcG9uZW50JztcblxuLyoqXG4gKiBUeXBlIG9mIHRoZSBvd25lclN0YXRlIGJhc2VkIG9uIHRoZSB0eXBlIG9mIGFuIGVsZW1lbnQgaXQgYXBwbGllcyB0by5cbiAqIFRoaXMgcmVzb2x2ZXMgdG8gdGhlIHByb3ZpZGVkIE93bmVyU3RhdGUgZm9yIFJlYWN0IGNvbXBvbmVudHMgYW5kIGB1bmRlZmluZWRgIGZvciBob3N0IGNvbXBvbmVudHMuXG4gKiBGYWxscyBiYWNrIHRvIGBPd25lclN0YXRlIHwgdW5kZWZpbmVkYCB3aGVuIHRoZSBleGFjdCB0eXBlIGNhbid0IGJlIGRldGVybWluZWQgaW4gZGV2ZWxvcG1lbnQgdGltZS5cbiAqL1xuXG4vKipcbiAqIEFwcGVuZHMgdGhlIG93bmVyU3RhdGUgb2JqZWN0IHRvIHRoZSBwcm9wcywgbWVyZ2luZyB3aXRoIHRoZSBleGlzdGluZyBvbmUgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSBlbGVtZW50VHlwZSBUeXBlIG9mIHRoZSBlbGVtZW50IHRoYXQgb3ducyB0aGUgYGV4aXN0aW5nUHJvcHNgLiBJZiB0aGUgZWxlbWVudCBpcyBhIERPTSBub2RlIG9yIHVuZGVmaW5lZCwgYG93bmVyU3RhdGVgIGlzIG5vdCBhcHBsaWVkLlxuICogQHBhcmFtIG90aGVyUHJvcHMgUHJvcHMgb2YgdGhlIGVsZW1lbnQuXG4gKiBAcGFyYW0gb3duZXJTdGF0ZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhcHBlbmRPd25lclN0YXRlKGVsZW1lbnRUeXBlLCBvdGhlclByb3BzLCBvd25lclN0YXRlKSB7XG4gIGlmIChlbGVtZW50VHlwZSA9PT0gdW5kZWZpbmVkIHx8IGlzSG9zdENvbXBvbmVudChlbGVtZW50VHlwZSkpIHtcbiAgICByZXR1cm4gb3RoZXJQcm9wcztcbiAgfVxuICByZXR1cm4gX2V4dGVuZHMoe30sIG90aGVyUHJvcHMsIHtcbiAgICBvd25lclN0YXRlOiBfZXh0ZW5kcyh7fSwgb3RoZXJQcm9wcy5vd25lclN0YXRlLCBvd25lclN0YXRlKVxuICB9KTtcbn0iLCIvKipcbiAqIEV4dHJhY3RzIGV2ZW50IGhhbmRsZXJzIGZyb20gYSBnaXZlbiBvYmplY3QuXG4gKiBBIHByb3AgaXMgY29uc2lkZXJlZCBhbiBldmVudCBoYW5kbGVyIGlmIGl0IGlzIGEgZnVuY3Rpb24gYW5kIGl0cyBuYW1lIHN0YXJ0cyB3aXRoIGBvbmAuXG4gKlxuICogQHBhcmFtIG9iamVjdCBBbiBvYmplY3QgdG8gZXh0cmFjdCBldmVudCBoYW5kbGVycyBmcm9tLlxuICogQHBhcmFtIGV4Y2x1ZGVLZXlzIEFuIGFycmF5IG9mIGtleXMgdG8gZXhjbHVkZSBmcm9tIHRoZSByZXR1cm5lZCBvYmplY3QuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGV4dHJhY3RFdmVudEhhbmRsZXJzKG9iamVjdCwgZXhjbHVkZUtleXMgPSBbXSkge1xuICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIE9iamVjdC5rZXlzKG9iamVjdCkuZmlsdGVyKHByb3AgPT4gcHJvcC5tYXRjaCgvXm9uW0EtWl0vKSAmJiB0eXBlb2Ygb2JqZWN0W3Byb3BdID09PSAnZnVuY3Rpb24nICYmICFleGNsdWRlS2V5cy5pbmNsdWRlcyhwcm9wKSkuZm9yRWFjaChwcm9wID0+IHtcbiAgICByZXN1bHRbcHJvcF0gPSBvYmplY3RbcHJvcF07XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufSIsIi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIGVsZW1lbnQgaXMgYSBET00gZWxlbWVudCBuYW1lIChpLmUuIG5vdCBhIFJlYWN0IGNvbXBvbmVudCkuXG4gKi9cbmZ1bmN0aW9uIGlzSG9zdENvbXBvbmVudChlbGVtZW50KSB7XG4gIHJldHVybiB0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnQgZGVmYXVsdCBpc0hvc3RDb21wb25lbnQ7IiwiaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5pbXBvcnQgY2xzeCBmcm9tICdjbHN4JztcbmltcG9ydCBleHRyYWN0RXZlbnRIYW5kbGVycyBmcm9tICcuL2V4dHJhY3RFdmVudEhhbmRsZXJzJztcbmltcG9ydCBvbWl0RXZlbnRIYW5kbGVycyBmcm9tICcuL29taXRFdmVudEhhbmRsZXJzJztcbi8qKlxuICogTWVyZ2VzIHRoZSBzbG90IGNvbXBvbmVudCBpbnRlcm5hbCBwcm9wcyAodXN1YWxseSBjb21pbmcgZnJvbSBhIGhvb2spXG4gKiB3aXRoIHRoZSBleHRlcm5hbGx5IHByb3ZpZGVkIG9uZXMuXG4gKlxuICogVGhlIG1lcmdlIG9yZGVyIGlzICh0aGUgbGF0dGVyIG92ZXJyaWRlcyB0aGUgZm9ybWVyKTpcbiAqIDEuIFRoZSBpbnRlcm5hbCBwcm9wcyAoc3BlY2lmaWVkIGFzIGEgZ2V0dGVyIGZ1bmN0aW9uIHRvIHdvcmsgd2l0aCBnZXQqUHJvcHMgaG9vayByZXN1bHQpXG4gKiAyLiBBZGRpdGlvbmFsIHByb3BzIChzcGVjaWZpZWQgaW50ZXJuYWxseSBvbiBhbiB1bnN0eWxlZCBjb21wb25lbnQpXG4gKiAzLiBFeHRlcm5hbCBwcm9wcyBzcGVjaWZpZWQgb24gdGhlIG93bmVyIGNvbXBvbmVudC4gVGhlc2Ugc2hvdWxkIG9ubHkgYmUgdXNlZCBvbiBhIHJvb3Qgc2xvdC5cbiAqIDQuIEV4dGVybmFsIHByb3BzIHNwZWNpZmllZCBpbiB0aGUgYHNsb3RQcm9wcy4qYCBwcm9wLlxuICogNS4gVGhlIGBjbGFzc05hbWVgIHByb3AgLSBjb21iaW5lZCBmcm9tIGFsbCB0aGUgYWJvdmUuXG4gKiBAcGFyYW0gcGFyYW1ldGVyc1xuICogQHJldHVybnNcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWVyZ2VTbG90UHJvcHMocGFyYW1ldGVycykge1xuICBjb25zdCB7XG4gICAgZ2V0U2xvdFByb3BzLFxuICAgIGFkZGl0aW9uYWxQcm9wcyxcbiAgICBleHRlcm5hbFNsb3RQcm9wcyxcbiAgICBleHRlcm5hbEZvcndhcmRlZFByb3BzLFxuICAgIGNsYXNzTmFtZVxuICB9ID0gcGFyYW1ldGVycztcbiAgaWYgKCFnZXRTbG90UHJvcHMpIHtcbiAgICAvLyBUaGUgc2ltcGxlciBjYXNlIC0gZ2V0U2xvdFByb3BzIGlzIG5vdCBkZWZpbmVkLCBzbyBubyBpbnRlcm5hbCBldmVudCBoYW5kbGVycyBhcmUgZGVmaW5lZCxcbiAgICAvLyBzbyB3ZSBjYW4gc2ltcGx5IG1lcmdlIGFsbCB0aGUgcHJvcHMgd2l0aG91dCBoYXZpbmcgdG8gd29ycnkgYWJvdXQgZXh0cmFjdGluZyBldmVudCBoYW5kbGVycy5cbiAgICBjb25zdCBqb2luZWRDbGFzc2VzID0gY2xzeChleHRlcm5hbEZvcndhcmRlZFByb3BzID09IG51bGwgPyB2b2lkIDAgOiBleHRlcm5hbEZvcndhcmRlZFByb3BzLmNsYXNzTmFtZSwgZXh0ZXJuYWxTbG90UHJvcHMgPT0gbnVsbCA/IHZvaWQgMCA6IGV4dGVybmFsU2xvdFByb3BzLmNsYXNzTmFtZSwgY2xhc3NOYW1lLCBhZGRpdGlvbmFsUHJvcHMgPT0gbnVsbCA/IHZvaWQgMCA6IGFkZGl0aW9uYWxQcm9wcy5jbGFzc05hbWUpO1xuICAgIGNvbnN0IG1lcmdlZFN0eWxlID0gX2V4dGVuZHMoe30sIGFkZGl0aW9uYWxQcm9wcyA9PSBudWxsID8gdm9pZCAwIDogYWRkaXRpb25hbFByb3BzLnN0eWxlLCBleHRlcm5hbEZvcndhcmRlZFByb3BzID09IG51bGwgPyB2b2lkIDAgOiBleHRlcm5hbEZvcndhcmRlZFByb3BzLnN0eWxlLCBleHRlcm5hbFNsb3RQcm9wcyA9PSBudWxsID8gdm9pZCAwIDogZXh0ZXJuYWxTbG90UHJvcHMuc3R5bGUpO1xuICAgIGNvbnN0IHByb3BzID0gX2V4dGVuZHMoe30sIGFkZGl0aW9uYWxQcm9wcywgZXh0ZXJuYWxGb3J3YXJkZWRQcm9wcywgZXh0ZXJuYWxTbG90UHJvcHMpO1xuICAgIGlmIChqb2luZWRDbGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICAgIHByb3BzLmNsYXNzTmFtZSA9IGpvaW5lZENsYXNzZXM7XG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhtZXJnZWRTdHlsZSkubGVuZ3RoID4gMCkge1xuICAgICAgcHJvcHMuc3R5bGUgPSBtZXJnZWRTdHlsZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3BzLFxuICAgICAgaW50ZXJuYWxSZWY6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cblxuICAvLyBJbiB0aGlzIGNhc2UsIGdldFNsb3RQcm9wcyBpcyByZXNwb25zaWJsZSBmb3IgY2FsbGluZyB0aGUgZXh0ZXJuYWwgZXZlbnQgaGFuZGxlcnMuXG4gIC8vIFdlIGRvbid0IG5lZWQgdG8gaW5jbHVkZSB0aGVtIGluIHRoZSBtZXJnZWQgcHJvcHMgYmVjYXVzZSBvZiB0aGlzLlxuXG4gIGNvbnN0IGV2ZW50SGFuZGxlcnMgPSBleHRyYWN0RXZlbnRIYW5kbGVycyhfZXh0ZW5kcyh7fSwgZXh0ZXJuYWxGb3J3YXJkZWRQcm9wcywgZXh0ZXJuYWxTbG90UHJvcHMpKTtcbiAgY29uc3QgY29tcG9uZW50c1Byb3BzV2l0aG91dEV2ZW50SGFuZGxlcnMgPSBvbWl0RXZlbnRIYW5kbGVycyhleHRlcm5hbFNsb3RQcm9wcyk7XG4gIGNvbnN0IG90aGVyUHJvcHNXaXRob3V0RXZlbnRIYW5kbGVycyA9IG9taXRFdmVudEhhbmRsZXJzKGV4dGVybmFsRm9yd2FyZGVkUHJvcHMpO1xuICBjb25zdCBpbnRlcm5hbFNsb3RQcm9wcyA9IGdldFNsb3RQcm9wcyhldmVudEhhbmRsZXJzKTtcblxuICAvLyBUaGUgb3JkZXIgb2YgY2xhc3NlcyBpcyBpbXBvcnRhbnQgaGVyZS5cbiAgLy8gRW1vdGlvbiAodGhhdCB3ZSB1c2UgaW4gbGlicmFyaWVzIGNvbnN1bWluZyBNVUkgQmFzZSkgZGVwZW5kcyBvbiB0aGlzIG9yZGVyXG4gIC8vIHRvIHByb3Blcmx5IG92ZXJyaWRlIHN0eWxlLiBJdCByZXF1aXJlcyB0aGUgbW9zdCBpbXBvcnRhbnQgY2xhc3NlcyB0byBiZSBsYXN0XG4gIC8vIChzZWUgaHR0cHM6Ly9naXRodWIuY29tL211aS9tYXRlcmlhbC11aS9wdWxsLzMzMjA1KSBmb3IgdGhlIHJlbGF0ZWQgZGlzY3Vzc2lvbi5cbiAgY29uc3Qgam9pbmVkQ2xhc3NlcyA9IGNsc3goaW50ZXJuYWxTbG90UHJvcHMgPT0gbnVsbCA/IHZvaWQgMCA6IGludGVybmFsU2xvdFByb3BzLmNsYXNzTmFtZSwgYWRkaXRpb25hbFByb3BzID09IG51bGwgPyB2b2lkIDAgOiBhZGRpdGlvbmFsUHJvcHMuY2xhc3NOYW1lLCBjbGFzc05hbWUsIGV4dGVybmFsRm9yd2FyZGVkUHJvcHMgPT0gbnVsbCA/IHZvaWQgMCA6IGV4dGVybmFsRm9yd2FyZGVkUHJvcHMuY2xhc3NOYW1lLCBleHRlcm5hbFNsb3RQcm9wcyA9PSBudWxsID8gdm9pZCAwIDogZXh0ZXJuYWxTbG90UHJvcHMuY2xhc3NOYW1lKTtcbiAgY29uc3QgbWVyZ2VkU3R5bGUgPSBfZXh0ZW5kcyh7fSwgaW50ZXJuYWxTbG90UHJvcHMgPT0gbnVsbCA/IHZvaWQgMCA6IGludGVybmFsU2xvdFByb3BzLnN0eWxlLCBhZGRpdGlvbmFsUHJvcHMgPT0gbnVsbCA/IHZvaWQgMCA6IGFkZGl0aW9uYWxQcm9wcy5zdHlsZSwgZXh0ZXJuYWxGb3J3YXJkZWRQcm9wcyA9PSBudWxsID8gdm9pZCAwIDogZXh0ZXJuYWxGb3J3YXJkZWRQcm9wcy5zdHlsZSwgZXh0ZXJuYWxTbG90UHJvcHMgPT0gbnVsbCA/IHZvaWQgMCA6IGV4dGVybmFsU2xvdFByb3BzLnN0eWxlKTtcbiAgY29uc3QgcHJvcHMgPSBfZXh0ZW5kcyh7fSwgaW50ZXJuYWxTbG90UHJvcHMsIGFkZGl0aW9uYWxQcm9wcywgb3RoZXJQcm9wc1dpdGhvdXRFdmVudEhhbmRsZXJzLCBjb21wb25lbnRzUHJvcHNXaXRob3V0RXZlbnRIYW5kbGVycyk7XG4gIGlmIChqb2luZWRDbGFzc2VzLmxlbmd0aCA+IDApIHtcbiAgICBwcm9wcy5jbGFzc05hbWUgPSBqb2luZWRDbGFzc2VzO1xuICB9XG4gIGlmIChPYmplY3Qua2V5cyhtZXJnZWRTdHlsZSkubGVuZ3RoID4gMCkge1xuICAgIHByb3BzLnN0eWxlID0gbWVyZ2VkU3R5bGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBwcm9wcyxcbiAgICBpbnRlcm5hbFJlZjogaW50ZXJuYWxTbG90UHJvcHMucmVmXG4gIH07XG59IiwiLyoqXG4gKiBSZW1vdmVzIGV2ZW50IGhhbmRsZXJzIGZyb20gdGhlIGdpdmVuIG9iamVjdC5cbiAqIEEgZmllbGQgaXMgY29uc2lkZXJlZCBhbiBldmVudCBoYW5kbGVyIGlmIGl0IGlzIGEgZnVuY3Rpb24gd2l0aCBhIG5hbWUgYmVnaW5uaW5nIHdpdGggYG9uYC5cbiAqXG4gKiBAcGFyYW0gb2JqZWN0IE9iamVjdCB0byByZW1vdmUgZXZlbnQgaGFuZGxlcnMgZnJvbS5cbiAqIEByZXR1cm5zIE9iamVjdCB3aXRoIGV2ZW50IGhhbmRsZXJzIHJlbW92ZWQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIG9taXRFdmVudEhhbmRsZXJzKG9iamVjdCkge1xuICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIE9iamVjdC5rZXlzKG9iamVjdCkuZmlsdGVyKHByb3AgPT4gIShwcm9wLm1hdGNoKC9eb25bQS1aXS8pICYmIHR5cGVvZiBvYmplY3RbcHJvcF0gPT09ICdmdW5jdGlvbicpKS5mb3JFYWNoKHByb3AgPT4ge1xuICAgIHJlc3VsdFtwcm9wXSA9IG9iamVjdFtwcm9wXTtcbiAgfSk7XG4gIHJldHVybiByZXN1bHQ7XG59IiwiLyoqXG4gKiBJZiBgY29tcG9uZW50UHJvcHNgIGlzIGEgZnVuY3Rpb24sIGNhbGxzIGl0IHdpdGggdGhlIHByb3ZpZGVkIGBvd25lclN0YXRlYC5cbiAqIE90aGVyd2lzZSwganVzdCByZXR1cm5zIGBjb21wb25lbnRQcm9wc2AuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlc29sdmVDb21wb25lbnRQcm9wcyhjb21wb25lbnRQcm9wcywgb3duZXJTdGF0ZSkge1xuICBpZiAodHlwZW9mIGNvbXBvbmVudFByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudFByb3BzKG93bmVyU3RhdGUpO1xuICB9XG4gIHJldHVybiBjb21wb25lbnRQcm9wcztcbn0iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZVwiO1xuY29uc3QgX2V4Y2x1ZGVkID0gW1wiZWxlbWVudFR5cGVcIiwgXCJleHRlcm5hbFNsb3RQcm9wc1wiLCBcIm93bmVyU3RhdGVcIl07XG5pbXBvcnQgeyB1bnN0YWJsZV91c2VGb3JrUmVmIGFzIHVzZUZvcmtSZWYgfSBmcm9tICdAbXVpL3V0aWxzJztcbmltcG9ydCBhcHBlbmRPd25lclN0YXRlIGZyb20gJy4vYXBwZW5kT3duZXJTdGF0ZSc7XG5pbXBvcnQgbWVyZ2VTbG90UHJvcHMgZnJvbSAnLi9tZXJnZVNsb3RQcm9wcyc7XG5pbXBvcnQgcmVzb2x2ZUNvbXBvbmVudFByb3BzIGZyb20gJy4vcmVzb2x2ZUNvbXBvbmVudFByb3BzJztcbi8qKlxuICogQGlnbm9yZSAtIGRvIG5vdCBkb2N1bWVudC5cbiAqIEJ1aWxkcyB0aGUgcHJvcHMgdG8gYmUgcGFzc2VkIGludG8gdGhlIHNsb3Qgb2YgYW4gdW5zdHlsZWQgY29tcG9uZW50LlxuICogSXQgbWVyZ2VzIHRoZSBpbnRlcm5hbCBwcm9wcyBvZiB0aGUgY29tcG9uZW50IHdpdGggdGhlIG9uZXMgc3VwcGxpZWQgYnkgdGhlIHVzZXIsIGFsbG93aW5nIHRvIGN1c3RvbWl6ZSB0aGUgYmVoYXZpb3IuXG4gKiBJZiB0aGUgc2xvdCBjb21wb25lbnQgaXMgbm90IGEgaG9zdCBjb21wb25lbnQsIGl0IGFsc28gbWVyZ2VzIGluIHRoZSBgb3duZXJTdGF0ZWAuXG4gKlxuICogQHBhcmFtIHBhcmFtZXRlcnMuZ2V0U2xvdFByb3BzIC0gQSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIHByb3BzIHRvIGJlIHBhc3NlZCB0byB0aGUgc2xvdCBjb21wb25lbnQuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVzZVNsb3RQcm9wcyhwYXJhbWV0ZXJzKSB7XG4gIHZhciBfcGFyYW1ldGVycyRhZGRpdGlvbmE7XG4gIGNvbnN0IHtcbiAgICAgIGVsZW1lbnRUeXBlLFxuICAgICAgZXh0ZXJuYWxTbG90UHJvcHMsXG4gICAgICBvd25lclN0YXRlXG4gICAgfSA9IHBhcmFtZXRlcnMsXG4gICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHBhcmFtZXRlcnMsIF9leGNsdWRlZCk7XG4gIGNvbnN0IHJlc29sdmVkQ29tcG9uZW50c1Byb3BzID0gcmVzb2x2ZUNvbXBvbmVudFByb3BzKGV4dGVybmFsU2xvdFByb3BzLCBvd25lclN0YXRlKTtcbiAgY29uc3Qge1xuICAgIHByb3BzOiBtZXJnZWRQcm9wcyxcbiAgICBpbnRlcm5hbFJlZlxuICB9ID0gbWVyZ2VTbG90UHJvcHMoX2V4dGVuZHMoe30sIHJlc3QsIHtcbiAgICBleHRlcm5hbFNsb3RQcm9wczogcmVzb2x2ZWRDb21wb25lbnRzUHJvcHNcbiAgfSkpO1xuICBjb25zdCByZWYgPSB1c2VGb3JrUmVmKGludGVybmFsUmVmLCByZXNvbHZlZENvbXBvbmVudHNQcm9wcyA9PSBudWxsID8gdm9pZCAwIDogcmVzb2x2ZWRDb21wb25lbnRzUHJvcHMucmVmLCAoX3BhcmFtZXRlcnMkYWRkaXRpb25hID0gcGFyYW1ldGVycy5hZGRpdGlvbmFsUHJvcHMpID09IG51bGwgPyB2b2lkIDAgOiBfcGFyYW1ldGVycyRhZGRpdGlvbmEucmVmKTtcbiAgY29uc3QgcHJvcHMgPSBhcHBlbmRPd25lclN0YXRlKGVsZW1lbnRUeXBlLCBfZXh0ZW5kcyh7fSwgbWVyZ2VkUHJvcHMsIHtcbiAgICByZWZcbiAgfSksIG93bmVyU3RhdGUpO1xuICByZXR1cm4gcHJvcHM7XG59IiwiaW1wb3J0IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlXCI7XG5pbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmNvbnN0IF9leGNsdWRlZCA9IFtcImNsYXNzTmFtZVwiLCBcImNvbHVtbnNcIiwgXCJjb2x1bW5TcGFjaW5nXCIsIFwiY29tcG9uZW50XCIsIFwiY29udGFpbmVyXCIsIFwiZGlyZWN0aW9uXCIsIFwiaXRlbVwiLCBcInJvd1NwYWNpbmdcIiwgXCJzcGFjaW5nXCIsIFwid3JhcFwiLCBcInplcm9NaW5XaWR0aFwiXTtcbi8vIEEgZ3JpZCBjb21wb25lbnQgdXNpbmcgdGhlIGZvbGxvd2luZyBsaWJzIGFzIGluc3BpcmF0aW9uLlxuLy9cbi8vIEZvciB0aGUgaW1wbGVtZW50YXRpb246XG4vLyAtIGh0dHBzOi8vZ2V0Ym9vdHN0cmFwLmNvbS9kb2NzLzQuMy9sYXlvdXQvZ3JpZC9cbi8vIC0gaHR0cHM6Ly9naXRodWIuY29tL2tyaXN0b2Zlcmpvc2VwaC9mbGV4Ym94Z3JpZC9ibG9iL21hc3Rlci9zcmMvY3NzL2ZsZXhib3hncmlkLmNzc1xuLy8gLSBodHRwczovL2dpdGh1Yi5jb20vcm95bGVlMDcwNC9yZWFjdC1mbGV4Ym94LWdyaWRcbi8vIC0gaHR0cHM6Ly9tYXRlcmlhbC5hbmd1bGFyanMub3JnL2xhdGVzdC9sYXlvdXQvaW50cm9kdWN0aW9uXG4vL1xuLy8gRm9sbG93IHRoaXMgZmxleGJveCBHdWlkZSB0byBiZXR0ZXIgdW5kZXJzdGFuZCB0aGUgdW5kZXJseWluZyBtb2RlbDpcbi8vIC0gaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9zbmlwcGV0cy9jc3MvYS1ndWlkZS10by1mbGV4Ym94L1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IHsgdW5zdGFibGVfZXh0ZW5kU3hQcm9wIGFzIGV4dGVuZFN4UHJvcCwgaGFuZGxlQnJlYWtwb2ludHMsIHVuc3RhYmxlX3Jlc29sdmVCcmVha3BvaW50VmFsdWVzIGFzIHJlc29sdmVCcmVha3BvaW50VmFsdWVzIH0gZnJvbSAnQG11aS9zeXN0ZW0nO1xuaW1wb3J0IHsgdW5zdGFibGVfY29tcG9zZUNsYXNzZXMgYXMgY29tcG9zZUNsYXNzZXMgfSBmcm9tICdAbXVpL2Jhc2UnO1xuaW1wb3J0IHJlcXVpcmVQcm9wRmFjdG9yeSBmcm9tICcuLi91dGlscy9yZXF1aXJlUHJvcEZhY3RvcnknO1xuaW1wb3J0IHN0eWxlZCBmcm9tICcuLi9zdHlsZXMvc3R5bGVkJztcbmltcG9ydCB1c2VUaGVtZVByb3BzIGZyb20gJy4uL3N0eWxlcy91c2VUaGVtZVByb3BzJztcbmltcG9ydCB1c2VUaGVtZSBmcm9tICcuLi9zdHlsZXMvdXNlVGhlbWUnO1xuaW1wb3J0IEdyaWRDb250ZXh0IGZyb20gJy4vR3JpZENvbnRleHQnO1xuaW1wb3J0IGdyaWRDbGFzc2VzLCB7IGdldEdyaWRVdGlsaXR5Q2xhc3MgfSBmcm9tICcuL2dyaWRDbGFzc2VzJztcbmltcG9ydCB7IGpzeCBhcyBfanN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5mdW5jdGlvbiBnZXRPZmZzZXQodmFsKSB7XG4gIGNvbnN0IHBhcnNlID0gcGFyc2VGbG9hdCh2YWwpO1xuICByZXR1cm4gYCR7cGFyc2V9JHtTdHJpbmcodmFsKS5yZXBsYWNlKFN0cmluZyhwYXJzZSksICcnKSB8fCAncHgnfWA7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2VuZXJhdGVHcmlkKHtcbiAgdGhlbWUsXG4gIG93bmVyU3RhdGVcbn0pIHtcbiAgbGV0IHNpemU7XG4gIHJldHVybiB0aGVtZS5icmVha3BvaW50cy5rZXlzLnJlZHVjZSgoZ2xvYmFsU3R5bGVzLCBicmVha3BvaW50KSA9PiB7XG4gICAgLy8gVXNlIHNpZGUgZWZmZWN0IG92ZXIgaW1tdXRhYmlsaXR5IGZvciBiZXR0ZXIgcGVyZm9ybWFuY2UuXG4gICAgbGV0IHN0eWxlcyA9IHt9O1xuICAgIGlmIChvd25lclN0YXRlW2JyZWFrcG9pbnRdKSB7XG4gICAgICBzaXplID0gb3duZXJTdGF0ZVticmVha3BvaW50XTtcbiAgICB9XG4gICAgaWYgKCFzaXplKSB7XG4gICAgICByZXR1cm4gZ2xvYmFsU3R5bGVzO1xuICAgIH1cbiAgICBpZiAoc2l6ZSA9PT0gdHJ1ZSkge1xuICAgICAgLy8gRm9yIHRoZSBhdXRvIGxheW91dGluZ1xuICAgICAgc3R5bGVzID0ge1xuICAgICAgICBmbGV4QmFzaXM6IDAsXG4gICAgICAgIGZsZXhHcm93OiAxLFxuICAgICAgICBtYXhXaWR0aDogJzEwMCUnXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoc2l6ZSA9PT0gJ2F1dG8nKSB7XG4gICAgICBzdHlsZXMgPSB7XG4gICAgICAgIGZsZXhCYXNpczogJ2F1dG8nLFxuICAgICAgICBmbGV4R3JvdzogMCxcbiAgICAgICAgZmxleFNocmluazogMCxcbiAgICAgICAgbWF4V2lkdGg6ICdub25lJyxcbiAgICAgICAgd2lkdGg6ICdhdXRvJ1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29sdW1uc0JyZWFrcG9pbnRWYWx1ZXMgPSByZXNvbHZlQnJlYWtwb2ludFZhbHVlcyh7XG4gICAgICAgIHZhbHVlczogb3duZXJTdGF0ZS5jb2x1bW5zLFxuICAgICAgICBicmVha3BvaW50czogdGhlbWUuYnJlYWtwb2ludHMudmFsdWVzXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGNvbHVtblZhbHVlID0gdHlwZW9mIGNvbHVtbnNCcmVha3BvaW50VmFsdWVzID09PSAnb2JqZWN0JyA/IGNvbHVtbnNCcmVha3BvaW50VmFsdWVzW2JyZWFrcG9pbnRdIDogY29sdW1uc0JyZWFrcG9pbnRWYWx1ZXM7XG4gICAgICBpZiAoY29sdW1uVmFsdWUgPT09IHVuZGVmaW5lZCB8fCBjb2x1bW5WYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsU3R5bGVzO1xuICAgICAgfVxuICAgICAgLy8gS2VlcCA3IHNpZ25pZmljYW50IG51bWJlcnMuXG4gICAgICBjb25zdCB3aWR0aCA9IGAke01hdGgucm91bmQoc2l6ZSAvIGNvbHVtblZhbHVlICogMTBlNykgLyAxMGU1fSVgO1xuICAgICAgbGV0IG1vcmUgPSB7fTtcbiAgICAgIGlmIChvd25lclN0YXRlLmNvbnRhaW5lciAmJiBvd25lclN0YXRlLml0ZW0gJiYgb3duZXJTdGF0ZS5jb2x1bW5TcGFjaW5nICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IHRoZW1lU3BhY2luZyA9IHRoZW1lLnNwYWNpbmcob3duZXJTdGF0ZS5jb2x1bW5TcGFjaW5nKTtcbiAgICAgICAgaWYgKHRoZW1lU3BhY2luZyAhPT0gJzBweCcpIHtcbiAgICAgICAgICBjb25zdCBmdWxsV2lkdGggPSBgY2FsYygke3dpZHRofSArICR7Z2V0T2Zmc2V0KHRoZW1lU3BhY2luZyl9KWA7XG4gICAgICAgICAgbW9yZSA9IHtcbiAgICAgICAgICAgIGZsZXhCYXNpczogZnVsbFdpZHRoLFxuICAgICAgICAgICAgbWF4V2lkdGg6IGZ1bGxXaWR0aFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2xvc2UgdG8gdGhlIGJvb3RzdHJhcCBpbXBsZW1lbnRhdGlvbjpcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iLzhmY2NhYTI0MzllOTdlYzcyYTRiN2RjNDJjY2MxZjY0OTc5MGFkYjAvc2Nzcy9taXhpbnMvX2dyaWQuc2NzcyNMNDFcbiAgICAgIHN0eWxlcyA9IF9leHRlbmRzKHtcbiAgICAgICAgZmxleEJhc2lzOiB3aWR0aCxcbiAgICAgICAgZmxleEdyb3c6IDAsXG4gICAgICAgIG1heFdpZHRoOiB3aWR0aFxuICAgICAgfSwgbW9yZSk7XG4gICAgfVxuXG4gICAgLy8gTm8gbmVlZCBmb3IgYSBtZWRpYSBxdWVyeSBmb3IgdGhlIGZpcnN0IHNpemUuXG4gICAgaWYgKHRoZW1lLmJyZWFrcG9pbnRzLnZhbHVlc1ticmVha3BvaW50XSA9PT0gMCkge1xuICAgICAgT2JqZWN0LmFzc2lnbihnbG9iYWxTdHlsZXMsIHN0eWxlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGdsb2JhbFN0eWxlc1t0aGVtZS5icmVha3BvaW50cy51cChicmVha3BvaW50KV0gPSBzdHlsZXM7XG4gICAgfVxuICAgIHJldHVybiBnbG9iYWxTdHlsZXM7XG4gIH0sIHt9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZURpcmVjdGlvbih7XG4gIHRoZW1lLFxuICBvd25lclN0YXRlXG59KSB7XG4gIGNvbnN0IGRpcmVjdGlvblZhbHVlcyA9IHJlc29sdmVCcmVha3BvaW50VmFsdWVzKHtcbiAgICB2YWx1ZXM6IG93bmVyU3RhdGUuZGlyZWN0aW9uLFxuICAgIGJyZWFrcG9pbnRzOiB0aGVtZS5icmVha3BvaW50cy52YWx1ZXNcbiAgfSk7XG4gIHJldHVybiBoYW5kbGVCcmVha3BvaW50cyh7XG4gICAgdGhlbWVcbiAgfSwgZGlyZWN0aW9uVmFsdWVzLCBwcm9wVmFsdWUgPT4ge1xuICAgIGNvbnN0IG91dHB1dCA9IHtcbiAgICAgIGZsZXhEaXJlY3Rpb246IHByb3BWYWx1ZVxuICAgIH07XG4gICAgaWYgKHByb3BWYWx1ZS5pbmRleE9mKCdjb2x1bW4nKSA9PT0gMCkge1xuICAgICAgb3V0cHV0W2AmID4gLiR7Z3JpZENsYXNzZXMuaXRlbX1gXSA9IHtcbiAgICAgICAgbWF4V2lkdGg6ICdub25lJ1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSk7XG59XG5cbi8qKlxuICogRXh0cmFjdHMgemVybyB2YWx1ZSBicmVha3BvaW50IGtleXMgYmVmb3JlIGEgbm9uLXplcm8gdmFsdWUgYnJlYWtwb2ludCBrZXkuXG4gKiBAZXhhbXBsZSB7IHhzOiAwLCBzbTogMCwgbWQ6IDIsIGxnOiAwLCB4bDogMCB9IG9yIFswLCAwLCAyLCAwLCAwXVxuICogQHJldHVybnMgW3hzLCBzbV1cbiAqL1xuZnVuY3Rpb24gZXh0cmFjdFplcm9WYWx1ZUJyZWFrcG9pbnRLZXlzKHtcbiAgYnJlYWtwb2ludHMsXG4gIHZhbHVlc1xufSkge1xuICBsZXQgbm9uWmVyb0tleSA9ICcnO1xuICBPYmplY3Qua2V5cyh2YWx1ZXMpLmZvckVhY2goa2V5ID0+IHtcbiAgICBpZiAobm9uWmVyb0tleSAhPT0gJycpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHZhbHVlc1trZXldICE9PSAwKSB7XG4gICAgICBub25aZXJvS2V5ID0ga2V5O1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IHNvcnRlZEJyZWFrcG9pbnRLZXlzQnlWYWx1ZSA9IE9iamVjdC5rZXlzKGJyZWFrcG9pbnRzKS5zb3J0KChhLCBiKSA9PiB7XG4gICAgcmV0dXJuIGJyZWFrcG9pbnRzW2FdIC0gYnJlYWtwb2ludHNbYl07XG4gIH0pO1xuICByZXR1cm4gc29ydGVkQnJlYWtwb2ludEtleXNCeVZhbHVlLnNsaWNlKDAsIHNvcnRlZEJyZWFrcG9pbnRLZXlzQnlWYWx1ZS5pbmRleE9mKG5vblplcm9LZXkpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVJvd0dhcCh7XG4gIHRoZW1lLFxuICBvd25lclN0YXRlXG59KSB7XG4gIGNvbnN0IHtcbiAgICBjb250YWluZXIsXG4gICAgcm93U3BhY2luZ1xuICB9ID0gb3duZXJTdGF0ZTtcbiAgbGV0IHN0eWxlcyA9IHt9O1xuICBpZiAoY29udGFpbmVyICYmIHJvd1NwYWNpbmcgIT09IDApIHtcbiAgICBjb25zdCByb3dTcGFjaW5nVmFsdWVzID0gcmVzb2x2ZUJyZWFrcG9pbnRWYWx1ZXMoe1xuICAgICAgdmFsdWVzOiByb3dTcGFjaW5nLFxuICAgICAgYnJlYWtwb2ludHM6IHRoZW1lLmJyZWFrcG9pbnRzLnZhbHVlc1xuICAgIH0pO1xuICAgIGxldCB6ZXJvVmFsdWVCcmVha3BvaW50S2V5cztcbiAgICBpZiAodHlwZW9mIHJvd1NwYWNpbmdWYWx1ZXMgPT09ICdvYmplY3QnKSB7XG4gICAgICB6ZXJvVmFsdWVCcmVha3BvaW50S2V5cyA9IGV4dHJhY3RaZXJvVmFsdWVCcmVha3BvaW50S2V5cyh7XG4gICAgICAgIGJyZWFrcG9pbnRzOiB0aGVtZS5icmVha3BvaW50cy52YWx1ZXMsXG4gICAgICAgIHZhbHVlczogcm93U3BhY2luZ1ZhbHVlc1xuICAgICAgfSk7XG4gICAgfVxuICAgIHN0eWxlcyA9IGhhbmRsZUJyZWFrcG9pbnRzKHtcbiAgICAgIHRoZW1lXG4gICAgfSwgcm93U3BhY2luZ1ZhbHVlcywgKHByb3BWYWx1ZSwgYnJlYWtwb2ludCkgPT4ge1xuICAgICAgdmFyIF96ZXJvVmFsdWVCcmVha3BvaW50SztcbiAgICAgIGNvbnN0IHRoZW1lU3BhY2luZyA9IHRoZW1lLnNwYWNpbmcocHJvcFZhbHVlKTtcbiAgICAgIGlmICh0aGVtZVNwYWNpbmcgIT09ICcwcHgnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbWFyZ2luVG9wOiBgLSR7Z2V0T2Zmc2V0KHRoZW1lU3BhY2luZyl9YCxcbiAgICAgICAgICBbYCYgPiAuJHtncmlkQ2xhc3Nlcy5pdGVtfWBdOiB7XG4gICAgICAgICAgICBwYWRkaW5nVG9wOiBnZXRPZmZzZXQodGhlbWVTcGFjaW5nKVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICgoX3plcm9WYWx1ZUJyZWFrcG9pbnRLID0gemVyb1ZhbHVlQnJlYWtwb2ludEtleXMpICE9IG51bGwgJiYgX3plcm9WYWx1ZUJyZWFrcG9pbnRLLmluY2x1ZGVzKGJyZWFrcG9pbnQpKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1hcmdpblRvcDogMCxcbiAgICAgICAgW2AmID4gLiR7Z3JpZENsYXNzZXMuaXRlbX1gXToge1xuICAgICAgICAgIHBhZGRpbmdUb3A6IDBcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc3R5bGVzO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlQ29sdW1uR2FwKHtcbiAgdGhlbWUsXG4gIG93bmVyU3RhdGVcbn0pIHtcbiAgY29uc3Qge1xuICAgIGNvbnRhaW5lcixcbiAgICBjb2x1bW5TcGFjaW5nXG4gIH0gPSBvd25lclN0YXRlO1xuICBsZXQgc3R5bGVzID0ge307XG4gIGlmIChjb250YWluZXIgJiYgY29sdW1uU3BhY2luZyAhPT0gMCkge1xuICAgIGNvbnN0IGNvbHVtblNwYWNpbmdWYWx1ZXMgPSByZXNvbHZlQnJlYWtwb2ludFZhbHVlcyh7XG4gICAgICB2YWx1ZXM6IGNvbHVtblNwYWNpbmcsXG4gICAgICBicmVha3BvaW50czogdGhlbWUuYnJlYWtwb2ludHMudmFsdWVzXG4gICAgfSk7XG4gICAgbGV0IHplcm9WYWx1ZUJyZWFrcG9pbnRLZXlzO1xuICAgIGlmICh0eXBlb2YgY29sdW1uU3BhY2luZ1ZhbHVlcyA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHplcm9WYWx1ZUJyZWFrcG9pbnRLZXlzID0gZXh0cmFjdFplcm9WYWx1ZUJyZWFrcG9pbnRLZXlzKHtcbiAgICAgICAgYnJlYWtwb2ludHM6IHRoZW1lLmJyZWFrcG9pbnRzLnZhbHVlcyxcbiAgICAgICAgdmFsdWVzOiBjb2x1bW5TcGFjaW5nVmFsdWVzXG4gICAgICB9KTtcbiAgICB9XG4gICAgc3R5bGVzID0gaGFuZGxlQnJlYWtwb2ludHMoe1xuICAgICAgdGhlbWVcbiAgICB9LCBjb2x1bW5TcGFjaW5nVmFsdWVzLCAocHJvcFZhbHVlLCBicmVha3BvaW50KSA9PiB7XG4gICAgICB2YXIgX3plcm9WYWx1ZUJyZWFrcG9pbnRLMjtcbiAgICAgIGNvbnN0IHRoZW1lU3BhY2luZyA9IHRoZW1lLnNwYWNpbmcocHJvcFZhbHVlKTtcbiAgICAgIGlmICh0aGVtZVNwYWNpbmcgIT09ICcwcHgnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgd2lkdGg6IGBjYWxjKDEwMCUgKyAke2dldE9mZnNldCh0aGVtZVNwYWNpbmcpfSlgLFxuICAgICAgICAgIG1hcmdpbkxlZnQ6IGAtJHtnZXRPZmZzZXQodGhlbWVTcGFjaW5nKX1gLFxuICAgICAgICAgIFtgJiA+IC4ke2dyaWRDbGFzc2VzLml0ZW19YF06IHtcbiAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiBnZXRPZmZzZXQodGhlbWVTcGFjaW5nKVxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICgoX3plcm9WYWx1ZUJyZWFrcG9pbnRLMiA9IHplcm9WYWx1ZUJyZWFrcG9pbnRLZXlzKSAhPSBudWxsICYmIF96ZXJvVmFsdWVCcmVha3BvaW50SzIuaW5jbHVkZXMoYnJlYWtwb2ludCkpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgICAgbWFyZ2luTGVmdDogMCxcbiAgICAgICAgW2AmID4gLiR7Z3JpZENsYXNzZXMuaXRlbX1gXToge1xuICAgICAgICAgIHBhZGRpbmdMZWZ0OiAwXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHN0eWxlcztcbn1cbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlU3BhY2luZ1N0eWxlcyhzcGFjaW5nLCBicmVha3BvaW50cywgc3R5bGVzID0ge30pIHtcbiAgLy8gdW5kZWZpbmVkL251bGwgb3IgYHNwYWNpbmdgIDw9IDBcbiAgaWYgKCFzcGFjaW5nIHx8IHNwYWNpbmcgPD0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICAvLyBpbiBjYXNlIG9mIHN0cmluZy9udW1iZXIgYHNwYWNpbmdgXG4gIGlmICh0eXBlb2Ygc3BhY2luZyA9PT0gJ3N0cmluZycgJiYgIU51bWJlci5pc05hTihOdW1iZXIoc3BhY2luZykpIHx8IHR5cGVvZiBzcGFjaW5nID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBbc3R5bGVzW2BzcGFjaW5nLXhzLSR7U3RyaW5nKHNwYWNpbmcpfWBdXTtcbiAgfVxuICAvLyBpbiBjYXNlIG9mIG9iamVjdCBgc3BhY2luZ2BcbiAgY29uc3Qgc3BhY2luZ1N0eWxlcyA9IFtdO1xuICBicmVha3BvaW50cy5mb3JFYWNoKGJyZWFrcG9pbnQgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gc3BhY2luZ1ticmVha3BvaW50XTtcbiAgICBpZiAoTnVtYmVyKHZhbHVlKSA+IDApIHtcbiAgICAgIHNwYWNpbmdTdHlsZXMucHVzaChzdHlsZXNbYHNwYWNpbmctJHticmVha3BvaW50fS0ke1N0cmluZyh2YWx1ZSl9YF0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBzcGFjaW5nU3R5bGVzO1xufVxuXG4vLyBEZWZhdWx0IENTUyB2YWx1ZXNcbi8vIGZsZXg6ICcwIDEgYXV0bycsXG4vLyBmbGV4RGlyZWN0aW9uOiAncm93Jyxcbi8vIGFsaWduSXRlbXM6ICdmbGV4LXN0YXJ0Jyxcbi8vIGZsZXhXcmFwOiAnbm93cmFwJyxcbi8vIGp1c3RpZnlDb250ZW50OiAnZmxleC1zdGFydCcsXG5jb25zdCBHcmlkUm9vdCA9IHN0eWxlZCgnZGl2Jywge1xuICBuYW1lOiAnTXVpR3JpZCcsXG4gIHNsb3Q6ICdSb290JyxcbiAgb3ZlcnJpZGVzUmVzb2x2ZXI6IChwcm9wcywgc3R5bGVzKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgb3duZXJTdGF0ZVxuICAgIH0gPSBwcm9wcztcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXIsXG4gICAgICBkaXJlY3Rpb24sXG4gICAgICBpdGVtLFxuICAgICAgc3BhY2luZyxcbiAgICAgIHdyYXAsXG4gICAgICB6ZXJvTWluV2lkdGgsXG4gICAgICBicmVha3BvaW50c1xuICAgIH0gPSBvd25lclN0YXRlO1xuICAgIGxldCBzcGFjaW5nU3R5bGVzID0gW107XG5cbiAgICAvLyBpbiBjYXNlIG9mIGdyaWQgaXRlbVxuICAgIGlmIChjb250YWluZXIpIHtcbiAgICAgIHNwYWNpbmdTdHlsZXMgPSByZXNvbHZlU3BhY2luZ1N0eWxlcyhzcGFjaW5nLCBicmVha3BvaW50cywgc3R5bGVzKTtcbiAgICB9XG4gICAgY29uc3QgYnJlYWtwb2ludHNTdHlsZXMgPSBbXTtcbiAgICBicmVha3BvaW50cy5mb3JFYWNoKGJyZWFrcG9pbnQgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSBvd25lclN0YXRlW2JyZWFrcG9pbnRdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGJyZWFrcG9pbnRzU3R5bGVzLnB1c2goc3R5bGVzW2BncmlkLSR7YnJlYWtwb2ludH0tJHtTdHJpbmcodmFsdWUpfWBdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gW3N0eWxlcy5yb290LCBjb250YWluZXIgJiYgc3R5bGVzLmNvbnRhaW5lciwgaXRlbSAmJiBzdHlsZXMuaXRlbSwgemVyb01pbldpZHRoICYmIHN0eWxlcy56ZXJvTWluV2lkdGgsIC4uLnNwYWNpbmdTdHlsZXMsIGRpcmVjdGlvbiAhPT0gJ3JvdycgJiYgc3R5bGVzW2BkaXJlY3Rpb24teHMtJHtTdHJpbmcoZGlyZWN0aW9uKX1gXSwgd3JhcCAhPT0gJ3dyYXAnICYmIHN0eWxlc1tgd3JhcC14cy0ke1N0cmluZyh3cmFwKX1gXSwgLi4uYnJlYWtwb2ludHNTdHlsZXNdO1xuICB9XG59KSgoe1xuICBvd25lclN0YXRlXG59KSA9PiBfZXh0ZW5kcyh7XG4gIGJveFNpemluZzogJ2JvcmRlci1ib3gnXG59LCBvd25lclN0YXRlLmNvbnRhaW5lciAmJiB7XG4gIGRpc3BsYXk6ICdmbGV4JyxcbiAgZmxleFdyYXA6ICd3cmFwJyxcbiAgd2lkdGg6ICcxMDAlJ1xufSwgb3duZXJTdGF0ZS5pdGVtICYmIHtcbiAgbWFyZ2luOiAwIC8vIEZvciBpbnN0YW5jZSwgaXQncyB1c2VmdWwgd2hlbiB1c2VkIHdpdGggYSBgZmlndXJlYCBlbGVtZW50LlxufSwgb3duZXJTdGF0ZS56ZXJvTWluV2lkdGggJiYge1xuICBtaW5XaWR0aDogMFxufSwgb3duZXJTdGF0ZS53cmFwICE9PSAnd3JhcCcgJiYge1xuICBmbGV4V3JhcDogb3duZXJTdGF0ZS53cmFwXG59KSwgZ2VuZXJhdGVEaXJlY3Rpb24sIGdlbmVyYXRlUm93R2FwLCBnZW5lcmF0ZUNvbHVtbkdhcCwgZ2VuZXJhdGVHcmlkKTtcbmV4cG9ydCBmdW5jdGlvbiByZXNvbHZlU3BhY2luZ0NsYXNzZXMoc3BhY2luZywgYnJlYWtwb2ludHMpIHtcbiAgLy8gdW5kZWZpbmVkL251bGwgb3IgYHNwYWNpbmdgIDw9IDBcbiAgaWYgKCFzcGFjaW5nIHx8IHNwYWNpbmcgPD0gMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICAvLyBpbiBjYXNlIG9mIHN0cmluZy9udW1iZXIgYHNwYWNpbmdgXG4gIGlmICh0eXBlb2Ygc3BhY2luZyA9PT0gJ3N0cmluZycgJiYgIU51bWJlci5pc05hTihOdW1iZXIoc3BhY2luZykpIHx8IHR5cGVvZiBzcGFjaW5nID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBbYHNwYWNpbmcteHMtJHtTdHJpbmcoc3BhY2luZyl9YF07XG4gIH1cbiAgLy8gaW4gY2FzZSBvZiBvYmplY3QgYHNwYWNpbmdgXG4gIGNvbnN0IGNsYXNzZXMgPSBbXTtcbiAgYnJlYWtwb2ludHMuZm9yRWFjaChicmVha3BvaW50ID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IHNwYWNpbmdbYnJlYWtwb2ludF07XG4gICAgaWYgKE51bWJlcih2YWx1ZSkgPiAwKSB7XG4gICAgICBjb25zdCBjbGFzc05hbWUgPSBgc3BhY2luZy0ke2JyZWFrcG9pbnR9LSR7U3RyaW5nKHZhbHVlKX1gO1xuICAgICAgY2xhc3Nlcy5wdXNoKGNsYXNzTmFtZSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNsYXNzZXM7XG59XG5jb25zdCB1c2VVdGlsaXR5Q2xhc3NlcyA9IG93bmVyU3RhdGUgPT4ge1xuICBjb25zdCB7XG4gICAgY2xhc3NlcyxcbiAgICBjb250YWluZXIsXG4gICAgZGlyZWN0aW9uLFxuICAgIGl0ZW0sXG4gICAgc3BhY2luZyxcbiAgICB3cmFwLFxuICAgIHplcm9NaW5XaWR0aCxcbiAgICBicmVha3BvaW50c1xuICB9ID0gb3duZXJTdGF0ZTtcbiAgbGV0IHNwYWNpbmdDbGFzc2VzID0gW107XG5cbiAgLy8gaW4gY2FzZSBvZiBncmlkIGl0ZW1cbiAgaWYgKGNvbnRhaW5lcikge1xuICAgIHNwYWNpbmdDbGFzc2VzID0gcmVzb2x2ZVNwYWNpbmdDbGFzc2VzKHNwYWNpbmcsIGJyZWFrcG9pbnRzKTtcbiAgfVxuICBjb25zdCBicmVha3BvaW50c0NsYXNzZXMgPSBbXTtcbiAgYnJlYWtwb2ludHMuZm9yRWFjaChicmVha3BvaW50ID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IG93bmVyU3RhdGVbYnJlYWtwb2ludF07XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBicmVha3BvaW50c0NsYXNzZXMucHVzaChgZ3JpZC0ke2JyZWFrcG9pbnR9LSR7U3RyaW5nKHZhbHVlKX1gKTtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBzbG90cyA9IHtcbiAgICByb290OiBbJ3Jvb3QnLCBjb250YWluZXIgJiYgJ2NvbnRhaW5lcicsIGl0ZW0gJiYgJ2l0ZW0nLCB6ZXJvTWluV2lkdGggJiYgJ3plcm9NaW5XaWR0aCcsIC4uLnNwYWNpbmdDbGFzc2VzLCBkaXJlY3Rpb24gIT09ICdyb3cnICYmIGBkaXJlY3Rpb24teHMtJHtTdHJpbmcoZGlyZWN0aW9uKX1gLCB3cmFwICE9PSAnd3JhcCcgJiYgYHdyYXAteHMtJHtTdHJpbmcod3JhcCl9YCwgLi4uYnJlYWtwb2ludHNDbGFzc2VzXVxuICB9O1xuICByZXR1cm4gY29tcG9zZUNsYXNzZXMoc2xvdHMsIGdldEdyaWRVdGlsaXR5Q2xhc3MsIGNsYXNzZXMpO1xufTtcbmNvbnN0IEdyaWQgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBHcmlkKGluUHJvcHMsIHJlZikge1xuICBjb25zdCB0aGVtZVByb3BzID0gdXNlVGhlbWVQcm9wcyh7XG4gICAgcHJvcHM6IGluUHJvcHMsXG4gICAgbmFtZTogJ011aUdyaWQnXG4gIH0pO1xuICBjb25zdCB7XG4gICAgYnJlYWtwb2ludHNcbiAgfSA9IHVzZVRoZW1lKCk7XG4gIGNvbnN0IHByb3BzID0gZXh0ZW5kU3hQcm9wKHRoZW1lUHJvcHMpO1xuICBjb25zdCB7XG4gICAgICBjbGFzc05hbWUsXG4gICAgICBjb2x1bW5zOiBjb2x1bW5zUHJvcCxcbiAgICAgIGNvbHVtblNwYWNpbmc6IGNvbHVtblNwYWNpbmdQcm9wLFxuICAgICAgY29tcG9uZW50ID0gJ2RpdicsXG4gICAgICBjb250YWluZXIgPSBmYWxzZSxcbiAgICAgIGRpcmVjdGlvbiA9ICdyb3cnLFxuICAgICAgaXRlbSA9IGZhbHNlLFxuICAgICAgcm93U3BhY2luZzogcm93U3BhY2luZ1Byb3AsXG4gICAgICBzcGFjaW5nID0gMCxcbiAgICAgIHdyYXAgPSAnd3JhcCcsXG4gICAgICB6ZXJvTWluV2lkdGggPSBmYWxzZVxuICAgIH0gPSBwcm9wcyxcbiAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQpO1xuICBjb25zdCByb3dTcGFjaW5nID0gcm93U3BhY2luZ1Byb3AgfHwgc3BhY2luZztcbiAgY29uc3QgY29sdW1uU3BhY2luZyA9IGNvbHVtblNwYWNpbmdQcm9wIHx8IHNwYWNpbmc7XG4gIGNvbnN0IGNvbHVtbnNDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChHcmlkQ29udGV4dCk7XG5cbiAgLy8gY29sdW1ucyBzZXQgd2l0aCBkZWZhdWx0IGJyZWFrcG9pbnQgdW5pdCBvZiAxMlxuICBjb25zdCBjb2x1bW5zID0gY29udGFpbmVyID8gY29sdW1uc1Byb3AgfHwgMTIgOiBjb2x1bW5zQ29udGV4dDtcbiAgY29uc3QgYnJlYWtwb2ludHNWYWx1ZXMgPSB7fTtcbiAgY29uc3Qgb3RoZXJGaWx0ZXJlZCA9IF9leHRlbmRzKHt9LCBvdGhlcik7XG4gIGJyZWFrcG9pbnRzLmtleXMuZm9yRWFjaChicmVha3BvaW50ID0+IHtcbiAgICBpZiAob3RoZXJbYnJlYWtwb2ludF0gIT0gbnVsbCkge1xuICAgICAgYnJlYWtwb2ludHNWYWx1ZXNbYnJlYWtwb2ludF0gPSBvdGhlclticmVha3BvaW50XTtcbiAgICAgIGRlbGV0ZSBvdGhlckZpbHRlcmVkW2JyZWFrcG9pbnRdO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IG93bmVyU3RhdGUgPSBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBjb2x1bW5zLFxuICAgIGNvbnRhaW5lcixcbiAgICBkaXJlY3Rpb24sXG4gICAgaXRlbSxcbiAgICByb3dTcGFjaW5nLFxuICAgIGNvbHVtblNwYWNpbmcsXG4gICAgd3JhcCxcbiAgICB6ZXJvTWluV2lkdGgsXG4gICAgc3BhY2luZ1xuICB9LCBicmVha3BvaW50c1ZhbHVlcywge1xuICAgIGJyZWFrcG9pbnRzOiBicmVha3BvaW50cy5rZXlzXG4gIH0pO1xuICBjb25zdCBjbGFzc2VzID0gdXNlVXRpbGl0eUNsYXNzZXMob3duZXJTdGF0ZSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovX2pzeChHcmlkQ29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb2x1bW5zLFxuICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovX2pzeChHcmlkUm9vdCwgX2V4dGVuZHMoe1xuICAgICAgb3duZXJTdGF0ZTogb3duZXJTdGF0ZSxcbiAgICAgIGNsYXNzTmFtZTogY2xzeChjbGFzc2VzLnJvb3QsIGNsYXNzTmFtZSksXG4gICAgICBhczogY29tcG9uZW50LFxuICAgICAgcmVmOiByZWZcbiAgICB9LCBvdGhlckZpbHRlcmVkKSlcbiAgfSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IEdyaWQucHJvcFR5cGVzIC8qIHJlbW92ZS1wcm9wdHlwZXMgKi8gPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogVGhlIGNvbnRlbnQgb2YgdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZSxcbiAgLyoqXG4gICAqIE92ZXJyaWRlIG9yIGV4dGVuZCB0aGUgc3R5bGVzIGFwcGxpZWQgdG8gdGhlIGNvbXBvbmVudC5cbiAgICovXG4gIGNsYXNzZXM6IFByb3BUeXBlcy5vYmplY3QsXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIGNvbHVtbnMuXG4gICAqIEBkZWZhdWx0IDEyXG4gICAqL1xuICBjb2x1bW5zOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubnVtYmVyKSwgUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLm9iamVjdF0pLFxuICAvKipcbiAgICogRGVmaW5lcyB0aGUgaG9yaXpvbnRhbCBzcGFjZSBiZXR3ZWVuIHRoZSB0eXBlIGBpdGVtYCBjb21wb25lbnRzLlxuICAgKiBJdCBvdmVycmlkZXMgdGhlIHZhbHVlIG9mIHRoZSBgc3BhY2luZ2AgcHJvcC5cbiAgICovXG4gIGNvbHVtblNwYWNpbmc6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSksIFByb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnQgdXNlZCBmb3IgdGhlIHJvb3Qgbm9kZS5cbiAgICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgICovXG4gIGNvbXBvbmVudDogUHJvcFR5cGVzLmVsZW1lbnRUeXBlLFxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgY29tcG9uZW50IHdpbGwgaGF2ZSB0aGUgZmxleCAqY29udGFpbmVyKiBiZWhhdmlvci5cbiAgICogWW91IHNob3VsZCBiZSB3cmFwcGluZyAqaXRlbXMqIHdpdGggYSAqY29udGFpbmVyKi5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGNvbnRhaW5lcjogUHJvcFR5cGVzLmJvb2wsXG4gIC8qKlxuICAgKiBEZWZpbmVzIHRoZSBgZmxleC1kaXJlY3Rpb25gIHN0eWxlIHByb3BlcnR5LlxuICAgKiBJdCBpcyBhcHBsaWVkIGZvciBhbGwgc2NyZWVuIHNpemVzLlxuICAgKiBAZGVmYXVsdCAncm93J1xuICAgKi9cbiAgZGlyZWN0aW9uOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub25lT2YoWydjb2x1bW4tcmV2ZXJzZScsICdjb2x1bW4nLCAncm93LXJldmVyc2UnLCAncm93J10pLCBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMub25lT2YoWydjb2x1bW4tcmV2ZXJzZScsICdjb2x1bW4nLCAncm93LXJldmVyc2UnLCAncm93J10pKSwgUHJvcFR5cGVzLm9iamVjdF0pLFxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgY29tcG9uZW50IHdpbGwgaGF2ZSB0aGUgZmxleCAqaXRlbSogYmVoYXZpb3IuXG4gICAqIFlvdSBzaG91bGQgYmUgd3JhcHBpbmcgKml0ZW1zKiB3aXRoIGEgKmNvbnRhaW5lciouXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBpdGVtOiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIElmIGEgbnVtYmVyLCBpdCBzZXRzIHRoZSBudW1iZXIgb2YgY29sdW1ucyB0aGUgZ3JpZCBpdGVtIHVzZXMuXG4gICAqIEl0IGNhbid0IGJlIGdyZWF0ZXIgdGhhbiB0aGUgdG90YWwgbnVtYmVyIG9mIGNvbHVtbnMgb2YgdGhlIGNvbnRhaW5lciAoMTIgYnkgZGVmYXVsdCkuXG4gICAqIElmICdhdXRvJywgdGhlIGdyaWQgaXRlbSdzIHdpZHRoIG1hdGNoZXMgaXRzIGNvbnRlbnQuXG4gICAqIElmIGZhbHNlLCB0aGUgcHJvcCBpcyBpZ25vcmVkLlxuICAgKiBJZiB0cnVlLCB0aGUgZ3JpZCBpdGVtJ3Mgd2lkdGggZ3Jvd3MgdG8gdXNlIHRoZSBzcGFjZSBhdmFpbGFibGUgaW4gdGhlIGdyaWQgY29udGFpbmVyLlxuICAgKiBUaGUgdmFsdWUgaXMgYXBwbGllZCBmb3IgdGhlIGBsZ2AgYnJlYWtwb2ludCBhbmQgd2lkZXIgc2NyZWVucyBpZiBub3Qgb3ZlcnJpZGRlbi5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGxnOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub25lT2YoWydhdXRvJ10pLCBQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuYm9vbF0pLFxuICAvKipcbiAgICogSWYgYSBudW1iZXIsIGl0IHNldHMgdGhlIG51bWJlciBvZiBjb2x1bW5zIHRoZSBncmlkIGl0ZW0gdXNlcy5cbiAgICogSXQgY2FuJ3QgYmUgZ3JlYXRlciB0aGFuIHRoZSB0b3RhbCBudW1iZXIgb2YgY29sdW1ucyBvZiB0aGUgY29udGFpbmVyICgxMiBieSBkZWZhdWx0KS5cbiAgICogSWYgJ2F1dG8nLCB0aGUgZ3JpZCBpdGVtJ3Mgd2lkdGggbWF0Y2hlcyBpdHMgY29udGVudC5cbiAgICogSWYgZmFsc2UsIHRoZSBwcm9wIGlzIGlnbm9yZWQuXG4gICAqIElmIHRydWUsIHRoZSBncmlkIGl0ZW0ncyB3aWR0aCBncm93cyB0byB1c2UgdGhlIHNwYWNlIGF2YWlsYWJsZSBpbiB0aGUgZ3JpZCBjb250YWluZXIuXG4gICAqIFRoZSB2YWx1ZSBpcyBhcHBsaWVkIGZvciB0aGUgYG1kYCBicmVha3BvaW50IGFuZCB3aWRlciBzY3JlZW5zIGlmIG5vdCBvdmVycmlkZGVuLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgbWQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vbmVPZihbJ2F1dG8nXSksIFByb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5ib29sXSksXG4gIC8qKlxuICAgKiBEZWZpbmVzIHRoZSB2ZXJ0aWNhbCBzcGFjZSBiZXR3ZWVuIHRoZSB0eXBlIGBpdGVtYCBjb21wb25lbnRzLlxuICAgKiBJdCBvdmVycmlkZXMgdGhlIHZhbHVlIG9mIHRoZSBgc3BhY2luZ2AgcHJvcC5cbiAgICovXG4gIHJvd1NwYWNpbmc6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5zdHJpbmddKSksIFByb3BUeXBlcy5udW1iZXIsIFByb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgLyoqXG4gICAqIElmIGEgbnVtYmVyLCBpdCBzZXRzIHRoZSBudW1iZXIgb2YgY29sdW1ucyB0aGUgZ3JpZCBpdGVtIHVzZXMuXG4gICAqIEl0IGNhbid0IGJlIGdyZWF0ZXIgdGhhbiB0aGUgdG90YWwgbnVtYmVyIG9mIGNvbHVtbnMgb2YgdGhlIGNvbnRhaW5lciAoMTIgYnkgZGVmYXVsdCkuXG4gICAqIElmICdhdXRvJywgdGhlIGdyaWQgaXRlbSdzIHdpZHRoIG1hdGNoZXMgaXRzIGNvbnRlbnQuXG4gICAqIElmIGZhbHNlLCB0aGUgcHJvcCBpcyBpZ25vcmVkLlxuICAgKiBJZiB0cnVlLCB0aGUgZ3JpZCBpdGVtJ3Mgd2lkdGggZ3Jvd3MgdG8gdXNlIHRoZSBzcGFjZSBhdmFpbGFibGUgaW4gdGhlIGdyaWQgY29udGFpbmVyLlxuICAgKiBUaGUgdmFsdWUgaXMgYXBwbGllZCBmb3IgdGhlIGBzbWAgYnJlYWtwb2ludCBhbmQgd2lkZXIgc2NyZWVucyBpZiBub3Qgb3ZlcnJpZGRlbi5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHNtOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub25lT2YoWydhdXRvJ10pLCBQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuYm9vbF0pLFxuICAvKipcbiAgICogRGVmaW5lcyB0aGUgc3BhY2UgYmV0d2VlbiB0aGUgdHlwZSBgaXRlbWAgY29tcG9uZW50cy5cbiAgICogSXQgY2FuIG9ubHkgYmUgdXNlZCBvbiBhIHR5cGUgYGNvbnRhaW5lcmAgY29tcG9uZW50LlxuICAgKiBAZGVmYXVsdCAwXG4gICAqL1xuICBzcGFjaW5nOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuc3RyaW5nXSkpLCBQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMub2JqZWN0LCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIC8qKlxuICAgKiBUaGUgc3lzdGVtIHByb3AgdGhhdCBhbGxvd3MgZGVmaW5pbmcgc3lzdGVtIG92ZXJyaWRlcyBhcyB3ZWxsIGFzIGFkZGl0aW9uYWwgQ1NTIHN0eWxlcy5cbiAgICovXG4gIHN4OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm9iamVjdCwgUHJvcFR5cGVzLmJvb2xdKSksIFByb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMub2JqZWN0XSksXG4gIC8qKlxuICAgKiBEZWZpbmVzIHRoZSBgZmxleC13cmFwYCBzdHlsZSBwcm9wZXJ0eS5cbiAgICogSXQncyBhcHBsaWVkIGZvciBhbGwgc2NyZWVuIHNpemVzLlxuICAgKiBAZGVmYXVsdCAnd3JhcCdcbiAgICovXG4gIHdyYXA6IFByb3BUeXBlcy5vbmVPZihbJ25vd3JhcCcsICd3cmFwLXJldmVyc2UnLCAnd3JhcCddKSxcbiAgLyoqXG4gICAqIElmIGEgbnVtYmVyLCBpdCBzZXRzIHRoZSBudW1iZXIgb2YgY29sdW1ucyB0aGUgZ3JpZCBpdGVtIHVzZXMuXG4gICAqIEl0IGNhbid0IGJlIGdyZWF0ZXIgdGhhbiB0aGUgdG90YWwgbnVtYmVyIG9mIGNvbHVtbnMgb2YgdGhlIGNvbnRhaW5lciAoMTIgYnkgZGVmYXVsdCkuXG4gICAqIElmICdhdXRvJywgdGhlIGdyaWQgaXRlbSdzIHdpZHRoIG1hdGNoZXMgaXRzIGNvbnRlbnQuXG4gICAqIElmIGZhbHNlLCB0aGUgcHJvcCBpcyBpZ25vcmVkLlxuICAgKiBJZiB0cnVlLCB0aGUgZ3JpZCBpdGVtJ3Mgd2lkdGggZ3Jvd3MgdG8gdXNlIHRoZSBzcGFjZSBhdmFpbGFibGUgaW4gdGhlIGdyaWQgY29udGFpbmVyLlxuICAgKiBUaGUgdmFsdWUgaXMgYXBwbGllZCBmb3IgdGhlIGB4bGAgYnJlYWtwb2ludCBhbmQgd2lkZXIgc2NyZWVucyBpZiBub3Qgb3ZlcnJpZGRlbi5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHhsOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMub25lT2YoWydhdXRvJ10pLCBQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuYm9vbF0pLFxuICAvKipcbiAgICogSWYgYSBudW1iZXIsIGl0IHNldHMgdGhlIG51bWJlciBvZiBjb2x1bW5zIHRoZSBncmlkIGl0ZW0gdXNlcy5cbiAgICogSXQgY2FuJ3QgYmUgZ3JlYXRlciB0aGFuIHRoZSB0b3RhbCBudW1iZXIgb2YgY29sdW1ucyBvZiB0aGUgY29udGFpbmVyICgxMiBieSBkZWZhdWx0KS5cbiAgICogSWYgJ2F1dG8nLCB0aGUgZ3JpZCBpdGVtJ3Mgd2lkdGggbWF0Y2hlcyBpdHMgY29udGVudC5cbiAgICogSWYgZmFsc2UsIHRoZSBwcm9wIGlzIGlnbm9yZWQuXG4gICAqIElmIHRydWUsIHRoZSBncmlkIGl0ZW0ncyB3aWR0aCBncm93cyB0byB1c2UgdGhlIHNwYWNlIGF2YWlsYWJsZSBpbiB0aGUgZ3JpZCBjb250YWluZXIuXG4gICAqIFRoZSB2YWx1ZSBpcyBhcHBsaWVkIGZvciBhbGwgdGhlIHNjcmVlbiBzaXplcyB3aXRoIHRoZSBsb3dlc3QgcHJpb3JpdHkuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICB4czogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLm9uZU9mKFsnYXV0byddKSwgUHJvcFR5cGVzLm51bWJlciwgUHJvcFR5cGVzLmJvb2xdKSxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgaXQgc2V0cyBgbWluLXdpZHRoOiAwYCBvbiB0aGUgaXRlbS5cbiAgICogUmVmZXIgdG8gdGhlIGxpbWl0YXRpb25zIHNlY3Rpb24gb2YgdGhlIGRvY3VtZW50YXRpb24gdG8gYmV0dGVyIHVuZGVyc3RhbmQgdGhlIHVzZSBjYXNlLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgemVyb01pbldpZHRoOiBQcm9wVHlwZXMuYm9vbFxufSA6IHZvaWQgMDtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGNvbnN0IHJlcXVpcmVQcm9wID0gcmVxdWlyZVByb3BGYWN0b3J5KCdHcmlkJywgR3JpZCk7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLWNvbmNhdFxuICBHcmlkWydwcm9wVHlwZXMnICsgJyddID0gX2V4dGVuZHMoe30sIEdyaWQucHJvcFR5cGVzLCB7XG4gICAgZGlyZWN0aW9uOiByZXF1aXJlUHJvcCgnY29udGFpbmVyJyksXG4gICAgbGc6IHJlcXVpcmVQcm9wKCdpdGVtJyksXG4gICAgbWQ6IHJlcXVpcmVQcm9wKCdpdGVtJyksXG4gICAgc206IHJlcXVpcmVQcm9wKCdpdGVtJyksXG4gICAgc3BhY2luZzogcmVxdWlyZVByb3AoJ2NvbnRhaW5lcicpLFxuICAgIHdyYXA6IHJlcXVpcmVQcm9wKCdjb250YWluZXInKSxcbiAgICB4czogcmVxdWlyZVByb3AoJ2l0ZW0nKSxcbiAgICB6ZXJvTWluV2lkdGg6IHJlcXVpcmVQcm9wKCdpdGVtJylcbiAgfSk7XG59XG5leHBvcnQgZGVmYXVsdCBHcmlkOyIsImltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcblxuLyoqXG4gKiBAaWdub3JlIC0gaW50ZXJuYWwgY29tcG9uZW50LlxuICovXG5jb25zdCBHcmlkQ29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KCk7XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBHcmlkQ29udGV4dC5kaXNwbGF5TmFtZSA9ICdHcmlkQ29udGV4dCc7XG59XG5leHBvcnQgZGVmYXVsdCBHcmlkQ29udGV4dDsiLCJpbXBvcnQgeyB1bnN0YWJsZV9nZW5lcmF0ZVV0aWxpdHlDbGFzc2VzIGFzIGdlbmVyYXRlVXRpbGl0eUNsYXNzZXMgfSBmcm9tICdAbXVpL3V0aWxzJztcbmltcG9ydCBnZW5lcmF0ZVV0aWxpdHlDbGFzcyBmcm9tICcuLi9nZW5lcmF0ZVV0aWxpdHlDbGFzcyc7XG5leHBvcnQgZnVuY3Rpb24gZ2V0R3JpZFV0aWxpdHlDbGFzcyhzbG90KSB7XG4gIHJldHVybiBnZW5lcmF0ZVV0aWxpdHlDbGFzcygnTXVpR3JpZCcsIHNsb3QpO1xufVxuY29uc3QgU1BBQ0lOR1MgPSBbMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgOSwgMTBdO1xuY29uc3QgRElSRUNUSU9OUyA9IFsnY29sdW1uLXJldmVyc2UnLCAnY29sdW1uJywgJ3Jvdy1yZXZlcnNlJywgJ3JvdyddO1xuY29uc3QgV1JBUFMgPSBbJ25vd3JhcCcsICd3cmFwLXJldmVyc2UnLCAnd3JhcCddO1xuY29uc3QgR1JJRF9TSVpFUyA9IFsnYXV0bycsIHRydWUsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTJdO1xuY29uc3QgZ3JpZENsYXNzZXMgPSBnZW5lcmF0ZVV0aWxpdHlDbGFzc2VzKCdNdWlHcmlkJywgWydyb290JywgJ2NvbnRhaW5lcicsICdpdGVtJywgJ3plcm9NaW5XaWR0aCcsXG4vLyBzcGFjaW5nc1xuLi4uU1BBQ0lOR1MubWFwKHNwYWNpbmcgPT4gYHNwYWNpbmcteHMtJHtzcGFjaW5nfWApLFxuLy8gZGlyZWN0aW9uIHZhbHVlc1xuLi4uRElSRUNUSU9OUy5tYXAoZGlyZWN0aW9uID0+IGBkaXJlY3Rpb24teHMtJHtkaXJlY3Rpb259YCksXG4vLyB3cmFwIHZhbHVlc1xuLi4uV1JBUFMubWFwKHdyYXAgPT4gYHdyYXAteHMtJHt3cmFwfWApLFxuLy8gZ3JpZCBzaXplcyBmb3IgYWxsIGJyZWFrcG9pbnRzXG4uLi5HUklEX1NJWkVTLm1hcChzaXplID0+IGBncmlkLXhzLSR7c2l6ZX1gKSwgLi4uR1JJRF9TSVpFUy5tYXAoc2l6ZSA9PiBgZ3JpZC1zbS0ke3NpemV9YCksIC4uLkdSSURfU0laRVMubWFwKHNpemUgPT4gYGdyaWQtbWQtJHtzaXplfWApLCAuLi5HUklEX1NJWkVTLm1hcChzaXplID0+IGBncmlkLWxnLSR7c2l6ZX1gKSwgLi4uR1JJRF9TSVpFUy5tYXAoc2l6ZSA9PiBgZ3JpZC14bC0ke3NpemV9YCldKTtcbmV4cG9ydCBkZWZhdWx0IGdyaWRDbGFzc2VzOyIsImltcG9ydCBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZVwiO1xuaW1wb3J0IF9leHRlbmRzIGZyb20gXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzXCI7XG5jb25zdCBfZXhjbHVkZWQgPSBbXCJhcmlhLWxhYmVsXCIsIFwiYXJpYS12YWx1ZXRleHRcIiwgXCJhcmlhLWxhYmVsbGVkYnlcIiwgXCJjb21wb25lbnRcIiwgXCJjb21wb25lbnRzXCIsIFwiY29tcG9uZW50c1Byb3BzXCIsIFwiY29sb3JcIiwgXCJjbGFzc2VzXCIsIFwiY2xhc3NOYW1lXCIsIFwiZGlzYWJsZVN3YXBcIiwgXCJkaXNhYmxlZFwiLCBcImdldEFyaWFMYWJlbFwiLCBcImdldEFyaWFWYWx1ZVRleHRcIiwgXCJtYXJrc1wiLCBcIm1heFwiLCBcIm1pblwiLCBcIm5hbWVcIiwgXCJvbkNoYW5nZVwiLCBcIm9uQ2hhbmdlQ29tbWl0dGVkXCIsIFwib3JpZW50YXRpb25cIiwgXCJzaXplXCIsIFwic3RlcFwiLCBcInNjYWxlXCIsIFwic2xvdFByb3BzXCIsIFwic2xvdHNcIiwgXCJ0YWJJbmRleFwiLCBcInRyYWNrXCIsIFwidmFsdWVcIiwgXCJ2YWx1ZUxhYmVsRGlzcGxheVwiLCBcInZhbHVlTGFiZWxGb3JtYXRcIl07XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IGNsc3ggZnJvbSAnY2xzeCc7XG5pbXBvcnQgeyBjaGFpblByb3BUeXBlcyB9IGZyb20gJ0BtdWkvdXRpbHMnO1xuaW1wb3J0IHsgaXNIb3N0Q29tcG9uZW50LCB1c2VTbG90UHJvcHMsIHVuc3RhYmxlX2NvbXBvc2VDbGFzc2VzIGFzIGNvbXBvc2VDbGFzc2VzIH0gZnJvbSAnQG11aS9iYXNlJztcbmltcG9ydCB7IHVzZVNsaWRlciB9IGZyb20gJ0BtdWkvYmFzZS9TbGlkZXJVbnN0eWxlZCc7XG5pbXBvcnQgeyBhbHBoYSwgbGlnaHRlbiwgZGFya2VuIH0gZnJvbSAnQG11aS9zeXN0ZW0nO1xuaW1wb3J0IHVzZVRoZW1lUHJvcHMgZnJvbSAnLi4vc3R5bGVzL3VzZVRoZW1lUHJvcHMnO1xuaW1wb3J0IHN0eWxlZCwgeyBzbG90U2hvdWxkRm9yd2FyZFByb3AgfSBmcm9tICcuLi9zdHlsZXMvc3R5bGVkJztcbmltcG9ydCB1c2VUaGVtZSBmcm9tICcuLi9zdHlsZXMvdXNlVGhlbWUnO1xuaW1wb3J0IHNob3VsZFNwcmVhZEFkZGl0aW9uYWxQcm9wcyBmcm9tICcuLi91dGlscy9zaG91bGRTcHJlYWRBZGRpdGlvbmFsUHJvcHMnO1xuaW1wb3J0IGNhcGl0YWxpemUgZnJvbSAnLi4vdXRpbHMvY2FwaXRhbGl6ZSc7XG5pbXBvcnQgU2xpZGVyVmFsdWVMYWJlbCBmcm9tICcuL1NsaWRlclZhbHVlTGFiZWwnO1xuaW1wb3J0IHNsaWRlckNsYXNzZXMsIHsgZ2V0U2xpZGVyVXRpbGl0eUNsYXNzIH0gZnJvbSAnLi9zbGlkZXJDbGFzc2VzJztcbmltcG9ydCB7IGpzeCBhcyBfanN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyBqc3hzIGFzIF9qc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5jb25zdCB2YWx1ZVRvUGVyY2VudCA9ICh2YWx1ZSwgbWluLCBtYXgpID0+ICh2YWx1ZSAtIG1pbikgKiAxMDAgLyAobWF4IC0gbWluKTtcbmZ1bmN0aW9uIElkZW50aXR5KHgpIHtcbiAgcmV0dXJuIHg7XG59XG5jb25zdCBTbGlkZXJSb290ID0gc3R5bGVkKCdzcGFuJywge1xuICBuYW1lOiAnTXVpU2xpZGVyJyxcbiAgc2xvdDogJ1Jvb3QnLFxuICBvdmVycmlkZXNSZXNvbHZlcjogKHByb3BzLCBzdHlsZXMpID0+IHtcbiAgICBjb25zdCB7XG4gICAgICBvd25lclN0YXRlXG4gICAgfSA9IHByb3BzO1xuICAgIHJldHVybiBbc3R5bGVzLnJvb3QsIHN0eWxlc1tgY29sb3Ike2NhcGl0YWxpemUob3duZXJTdGF0ZS5jb2xvcil9YF0sIG93bmVyU3RhdGUuc2l6ZSAhPT0gJ21lZGl1bScgJiYgc3R5bGVzW2BzaXplJHtjYXBpdGFsaXplKG93bmVyU3RhdGUuc2l6ZSl9YF0sIG93bmVyU3RhdGUubWFya2VkICYmIHN0eWxlcy5tYXJrZWQsIG93bmVyU3RhdGUub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgJiYgc3R5bGVzLnZlcnRpY2FsLCBvd25lclN0YXRlLnRyYWNrID09PSAnaW52ZXJ0ZWQnICYmIHN0eWxlcy50cmFja0ludmVydGVkLCBvd25lclN0YXRlLnRyYWNrID09PSBmYWxzZSAmJiBzdHlsZXMudHJhY2tGYWxzZV07XG4gIH1cbn0pKCh7XG4gIHRoZW1lLFxuICBvd25lclN0YXRlXG59KSA9PiBfZXh0ZW5kcyh7XG4gIGJvcmRlclJhZGl1czogMTIsXG4gIGJveFNpemluZzogJ2NvbnRlbnQtYm94JyxcbiAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXG4gIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICBjdXJzb3I6ICdwb2ludGVyJyxcbiAgdG91Y2hBY3Rpb246ICdub25lJyxcbiAgY29sb3I6ICh0aGVtZS52YXJzIHx8IHRoZW1lKS5wYWxldHRlW293bmVyU3RhdGUuY29sb3JdLm1haW4sXG4gIFdlYmtpdFRhcEhpZ2hsaWdodENvbG9yOiAndHJhbnNwYXJlbnQnXG59LCBvd25lclN0YXRlLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgJiYgX2V4dGVuZHMoe1xuICBoZWlnaHQ6IDQsXG4gIHdpZHRoOiAnMTAwJScsXG4gIHBhZGRpbmc6ICcxM3B4IDAnLFxuICAvLyBUaGUgcHJpbWFyeSBpbnB1dCBtZWNoYW5pc20gb2YgdGhlIGRldmljZSBpbmNsdWRlcyBhIHBvaW50aW5nIGRldmljZSBvZiBsaW1pdGVkIGFjY3VyYWN5LlxuICAnQG1lZGlhIChwb2ludGVyOiBjb2Fyc2UpJzoge1xuICAgIC8vIFJlYWNoIDQycHggdG91Y2ggdGFyZ2V0LCBhYm91dCB+OG1tIG9uIHNjcmVlbi5cbiAgICBwYWRkaW5nOiAnMjBweCAwJ1xuICB9XG59LCBvd25lclN0YXRlLnNpemUgPT09ICdzbWFsbCcgJiYge1xuICBoZWlnaHQ6IDJcbn0sIG93bmVyU3RhdGUubWFya2VkICYmIHtcbiAgbWFyZ2luQm90dG9tOiAyMFxufSksIG93bmVyU3RhdGUub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgJiYgX2V4dGVuZHMoe1xuICBoZWlnaHQ6ICcxMDAlJyxcbiAgd2lkdGg6IDQsXG4gIHBhZGRpbmc6ICcwIDEzcHgnLFxuICAvLyBUaGUgcHJpbWFyeSBpbnB1dCBtZWNoYW5pc20gb2YgdGhlIGRldmljZSBpbmNsdWRlcyBhIHBvaW50aW5nIGRldmljZSBvZiBsaW1pdGVkIGFjY3VyYWN5LlxuICAnQG1lZGlhIChwb2ludGVyOiBjb2Fyc2UpJzoge1xuICAgIC8vIFJlYWNoIDQycHggdG91Y2ggdGFyZ2V0LCBhYm91dCB+OG1tIG9uIHNjcmVlbi5cbiAgICBwYWRkaW5nOiAnMCAyMHB4J1xuICB9XG59LCBvd25lclN0YXRlLnNpemUgPT09ICdzbWFsbCcgJiYge1xuICB3aWR0aDogMlxufSwgb3duZXJTdGF0ZS5tYXJrZWQgJiYge1xuICBtYXJnaW5SaWdodDogNDRcbn0pLCB7XG4gICdAbWVkaWEgcHJpbnQnOiB7XG4gICAgY29sb3JBZGp1c3Q6ICdleGFjdCdcbiAgfSxcbiAgW2AmLiR7c2xpZGVyQ2xhc3Nlcy5kaXNhYmxlZH1gXToge1xuICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcbiAgICBjdXJzb3I6ICdkZWZhdWx0JyxcbiAgICBjb2xvcjogKHRoZW1lLnZhcnMgfHwgdGhlbWUpLnBhbGV0dGUuZ3JleVs0MDBdXG4gIH0sXG4gIFtgJi4ke3NsaWRlckNsYXNzZXMuZHJhZ2dpbmd9YF06IHtcbiAgICBbYCYgLiR7c2xpZGVyQ2xhc3Nlcy50aHVtYn0sICYgLiR7c2xpZGVyQ2xhc3Nlcy50cmFja31gXToge1xuICAgICAgdHJhbnNpdGlvbjogJ25vbmUnXG4gICAgfVxuICB9XG59KSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBTbGlkZXJSb290LnByb3BUeXBlcyAvKiByZW1vdmUtcHJvcHR5cGVzICovID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZVxufSA6IHZvaWQgMDtcbmV4cG9ydCB7IFNsaWRlclJvb3QgfTtcbmNvbnN0IFNsaWRlclJhaWwgPSBzdHlsZWQoJ3NwYW4nLCB7XG4gIG5hbWU6ICdNdWlTbGlkZXInLFxuICBzbG90OiAnUmFpbCcsXG4gIG92ZXJyaWRlc1Jlc29sdmVyOiAocHJvcHMsIHN0eWxlcykgPT4gc3R5bGVzLnJhaWxcbn0pKCh7XG4gIG93bmVyU3RhdGVcbn0pID0+IF9leHRlbmRzKHtcbiAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gIGJvcmRlclJhZGl1czogJ2luaGVyaXQnLFxuICBiYWNrZ3JvdW5kQ29sb3I6ICdjdXJyZW50Q29sb3InLFxuICBvcGFjaXR5OiAwLjM4XG59LCBvd25lclN0YXRlLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgJiYge1xuICB3aWR0aDogJzEwMCUnLFxuICBoZWlnaHQ6ICdpbmhlcml0JyxcbiAgdG9wOiAnNTAlJyxcbiAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgtNTAlKSdcbn0sIG93bmVyU3RhdGUub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgJiYge1xuICBoZWlnaHQ6ICcxMDAlJyxcbiAgd2lkdGg6ICdpbmhlcml0JyxcbiAgbGVmdDogJzUwJScsXG4gIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTUwJSknXG59LCBvd25lclN0YXRlLnRyYWNrID09PSAnaW52ZXJ0ZWQnICYmIHtcbiAgb3BhY2l0eTogMVxufSkpO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gU2xpZGVyUmFpbC5wcm9wVHlwZXMgLyogcmVtb3ZlLXByb3B0eXBlcyAqLyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGVcbn0gOiB2b2lkIDA7XG5leHBvcnQgeyBTbGlkZXJSYWlsIH07XG5jb25zdCBTbGlkZXJUcmFjayA9IHN0eWxlZCgnc3BhbicsIHtcbiAgbmFtZTogJ011aVNsaWRlcicsXG4gIHNsb3Q6ICdUcmFjaycsXG4gIG92ZXJyaWRlc1Jlc29sdmVyOiAocHJvcHMsIHN0eWxlcykgPT4gc3R5bGVzLnRyYWNrXG59KSgoe1xuICB0aGVtZSxcbiAgb3duZXJTdGF0ZVxufSkgPT4ge1xuICBjb25zdCBjb2xvciA9XG4gIC8vIFNhbWUgbG9naWMgYXMgdGhlIExpbmVhclByb2dyZXNzIHRyYWNrIGNvbG9yXG4gIHRoZW1lLnBhbGV0dGUubW9kZSA9PT0gJ2xpZ2h0JyA/IGxpZ2h0ZW4odGhlbWUucGFsZXR0ZVtvd25lclN0YXRlLmNvbG9yXS5tYWluLCAwLjYyKSA6IGRhcmtlbih0aGVtZS5wYWxldHRlW293bmVyU3RhdGUuY29sb3JdLm1haW4sIDAuNSk7XG4gIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgZGlzcGxheTogJ2Jsb2NrJyxcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICBib3JkZXJSYWRpdXM6ICdpbmhlcml0JyxcbiAgICBib3JkZXI6ICcxcHggc29saWQgY3VycmVudENvbG9yJyxcbiAgICBiYWNrZ3JvdW5kQ29sb3I6ICdjdXJyZW50Q29sb3InLFxuICAgIHRyYW5zaXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmNyZWF0ZShbJ2xlZnQnLCAnd2lkdGgnLCAnYm90dG9tJywgJ2hlaWdodCddLCB7XG4gICAgICBkdXJhdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuZHVyYXRpb24uc2hvcnRlc3RcbiAgICB9KVxuICB9LCBvd25lclN0YXRlLnNpemUgPT09ICdzbWFsbCcgJiYge1xuICAgIGJvcmRlcjogJ25vbmUnXG4gIH0sIG93bmVyU3RhdGUub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyAmJiB7XG4gICAgaGVpZ2h0OiAnaW5oZXJpdCcsXG4gICAgdG9wOiAnNTAlJyxcbiAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVZKC01MCUpJ1xuICB9LCBvd25lclN0YXRlLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnICYmIHtcbiAgICB3aWR0aDogJ2luaGVyaXQnLFxuICAgIGxlZnQ6ICc1MCUnLFxuICAgIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZVgoLTUwJSknXG4gIH0sIG93bmVyU3RhdGUudHJhY2sgPT09IGZhbHNlICYmIHtcbiAgICBkaXNwbGF5OiAnbm9uZSdcbiAgfSwgb3duZXJTdGF0ZS50cmFjayA9PT0gJ2ludmVydGVkJyAmJiB7XG4gICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS52YXJzID8gdGhlbWUudmFycy5wYWxldHRlLlNsaWRlcltgJHtvd25lclN0YXRlLmNvbG9yfVRyYWNrYF0gOiBjb2xvcixcbiAgICBib3JkZXJDb2xvcjogdGhlbWUudmFycyA/IHRoZW1lLnZhcnMucGFsZXR0ZS5TbGlkZXJbYCR7b3duZXJTdGF0ZS5jb2xvcn1UcmFja2BdIDogY29sb3JcbiAgfSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFNsaWRlclRyYWNrLnByb3BUeXBlcyAvKiByZW1vdmUtcHJvcHR5cGVzICovID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZVxufSA6IHZvaWQgMDtcbmV4cG9ydCB7IFNsaWRlclRyYWNrIH07XG5jb25zdCBTbGlkZXJUaHVtYiA9IHN0eWxlZCgnc3BhbicsIHtcbiAgbmFtZTogJ011aVNsaWRlcicsXG4gIHNsb3Q6ICdUaHVtYicsXG4gIG92ZXJyaWRlc1Jlc29sdmVyOiAocHJvcHMsIHN0eWxlcykgPT4ge1xuICAgIGNvbnN0IHtcbiAgICAgIG93bmVyU3RhdGVcbiAgICB9ID0gcHJvcHM7XG4gICAgcmV0dXJuIFtzdHlsZXMudGh1bWIsIHN0eWxlc1tgdGh1bWJDb2xvciR7Y2FwaXRhbGl6ZShvd25lclN0YXRlLmNvbG9yKX1gXSwgb3duZXJTdGF0ZS5zaXplICE9PSAnbWVkaXVtJyAmJiBzdHlsZXNbYHRodW1iU2l6ZSR7Y2FwaXRhbGl6ZShvd25lclN0YXRlLnNpemUpfWBdXTtcbiAgfVxufSkoKHtcbiAgdGhlbWUsXG4gIG93bmVyU3RhdGVcbn0pID0+IF9leHRlbmRzKHtcbiAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gIHdpZHRoOiAyMCxcbiAgaGVpZ2h0OiAyMCxcbiAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXG4gIGJvcmRlclJhZGl1czogJzUwJScsXG4gIG91dGxpbmU6IDAsXG4gIGJhY2tncm91bmRDb2xvcjogJ2N1cnJlbnRDb2xvcicsXG4gIGRpc3BsYXk6ICdmbGV4JyxcbiAgYWxpZ25JdGVtczogJ2NlbnRlcicsXG4gIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcbiAgdHJhbnNpdGlvbjogdGhlbWUudHJhbnNpdGlvbnMuY3JlYXRlKFsnYm94LXNoYWRvdycsICdsZWZ0JywgJ2JvdHRvbSddLCB7XG4gICAgZHVyYXRpb246IHRoZW1lLnRyYW5zaXRpb25zLmR1cmF0aW9uLnNob3J0ZXN0XG4gIH0pXG59LCBvd25lclN0YXRlLnNpemUgPT09ICdzbWFsbCcgJiYge1xuICB3aWR0aDogMTIsXG4gIGhlaWdodDogMTJcbn0sIG93bmVyU3RhdGUub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyAmJiB7XG4gIHRvcDogJzUwJScsXG4gIHRyYW5zZm9ybTogJ3RyYW5zbGF0ZSgtNTAlLCAtNTAlKSdcbn0sIG93bmVyU3RhdGUub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgJiYge1xuICBsZWZ0OiAnNTAlJyxcbiAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKC01MCUsIDUwJSknXG59LCB7XG4gICcmOmJlZm9yZSc6IF9leHRlbmRzKHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICBjb250ZW50OiAnXCJcIicsXG4gICAgYm9yZGVyUmFkaXVzOiAnaW5oZXJpdCcsXG4gICAgd2lkdGg6ICcxMDAlJyxcbiAgICBoZWlnaHQ6ICcxMDAlJyxcbiAgICBib3hTaGFkb3c6ICh0aGVtZS52YXJzIHx8IHRoZW1lKS5zaGFkb3dzWzJdXG4gIH0sIG93bmVyU3RhdGUuc2l6ZSA9PT0gJ3NtYWxsJyAmJiB7XG4gICAgYm94U2hhZG93OiAnbm9uZSdcbiAgfSksXG4gICcmOjphZnRlcic6IHtcbiAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICBjb250ZW50OiAnXCJcIicsXG4gICAgYm9yZGVyUmFkaXVzOiAnNTAlJyxcbiAgICAvLyA0MnB4IGlzIHRoZSBoaXQgdGFyZ2V0XG4gICAgd2lkdGg6IDQyLFxuICAgIGhlaWdodDogNDIsXG4gICAgdG9wOiAnNTAlJyxcbiAgICBsZWZ0OiAnNTAlJyxcbiAgICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoLTUwJSwgLTUwJSknXG4gIH0sXG4gIFtgJjpob3ZlciwgJi4ke3NsaWRlckNsYXNzZXMuZm9jdXNWaXNpYmxlfWBdOiB7XG4gICAgYm94U2hhZG93OiBgMHB4IDBweCAwcHggOHB4ICR7dGhlbWUudmFycyA/IGByZ2JhKCR7dGhlbWUudmFycy5wYWxldHRlW293bmVyU3RhdGUuY29sb3JdLm1haW5DaGFubmVsfSAvIDAuMTYpYCA6IGFscGhhKHRoZW1lLnBhbGV0dGVbb3duZXJTdGF0ZS5jb2xvcl0ubWFpbiwgMC4xNil9YCxcbiAgICAnQG1lZGlhIChob3Zlcjogbm9uZSknOiB7XG4gICAgICBib3hTaGFkb3c6ICdub25lJ1xuICAgIH1cbiAgfSxcbiAgW2AmLiR7c2xpZGVyQ2xhc3Nlcy5hY3RpdmV9YF06IHtcbiAgICBib3hTaGFkb3c6IGAwcHggMHB4IDBweCAxNHB4ICR7dGhlbWUudmFycyA/IGByZ2JhKCR7dGhlbWUudmFycy5wYWxldHRlW293bmVyU3RhdGUuY29sb3JdLm1haW5DaGFubmVsfSAvIDAuMTYpYCA6IGFscGhhKHRoZW1lLnBhbGV0dGVbb3duZXJTdGF0ZS5jb2xvcl0ubWFpbiwgMC4xNil9YFxuICB9LFxuICBbYCYuJHtzbGlkZXJDbGFzc2VzLmRpc2FibGVkfWBdOiB7XG4gICAgJyY6aG92ZXInOiB7XG4gICAgICBib3hTaGFkb3c6ICdub25lJ1xuICAgIH1cbiAgfVxufSkpO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gU2xpZGVyVGh1bWIucHJvcFR5cGVzIC8qIHJlbW92ZS1wcm9wdHlwZXMgKi8gPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59IDogdm9pZCAwO1xuZXhwb3J0IHsgU2xpZGVyVGh1bWIgfTtcbmNvbnN0IFN0eWxlZFNsaWRlclZhbHVlTGFiZWwgPSBzdHlsZWQoU2xpZGVyVmFsdWVMYWJlbCwge1xuICBuYW1lOiAnTXVpU2xpZGVyJyxcbiAgc2xvdDogJ1ZhbHVlTGFiZWwnLFxuICBvdmVycmlkZXNSZXNvbHZlcjogKHByb3BzLCBzdHlsZXMpID0+IHN0eWxlcy52YWx1ZUxhYmVsXG59KSgoe1xuICB0aGVtZSxcbiAgb3duZXJTdGF0ZVxufSkgPT4gX2V4dGVuZHMoe1xuICBbYCYuJHtzbGlkZXJDbGFzc2VzLnZhbHVlTGFiZWxPcGVufWBdOiB7XG4gICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgtMTAwJSkgc2NhbGUoMSknXG4gIH0sXG4gIHpJbmRleDogMSxcbiAgd2hpdGVTcGFjZTogJ25vd3JhcCdcbn0sIHRoZW1lLnR5cG9ncmFwaHkuYm9keTIsIHtcbiAgZm9udFdlaWdodDogNTAwLFxuICB0cmFuc2l0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5jcmVhdGUoWyd0cmFuc2Zvcm0nXSwge1xuICAgIGR1cmF0aW9uOiB0aGVtZS50cmFuc2l0aW9ucy5kdXJhdGlvbi5zaG9ydGVzdFxuICB9KSxcbiAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSgtMTAwJSkgc2NhbGUoMCknLFxuICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgYmFja2dyb3VuZENvbG9yOiAodGhlbWUudmFycyB8fCB0aGVtZSkucGFsZXR0ZS5ncmV5WzYwMF0sXG4gIGJvcmRlclJhZGl1czogMixcbiAgY29sb3I6ICh0aGVtZS52YXJzIHx8IHRoZW1lKS5wYWxldHRlLmNvbW1vbi53aGl0ZSxcbiAgZGlzcGxheTogJ2ZsZXgnLFxuICBhbGlnbkl0ZW1zOiAnY2VudGVyJyxcbiAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxuICBwYWRkaW5nOiAnMC4yNXJlbSAwLjc1cmVtJ1xufSwgb3duZXJTdGF0ZS5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnICYmIHtcbiAgdG9wOiAnLTEwcHgnLFxuICB0cmFuc2Zvcm1PcmlnaW46ICdib3R0b20gY2VudGVyJyxcbiAgJyY6YmVmb3JlJzoge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIGNvbnRlbnQ6ICdcIlwiJyxcbiAgICB3aWR0aDogOCxcbiAgICBoZWlnaHQ6IDgsXG4gICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKC01MCUsIDUwJSkgcm90YXRlKDQ1ZGVnKScsXG4gICAgYmFja2dyb3VuZENvbG9yOiAnaW5oZXJpdCcsXG4gICAgYm90dG9tOiAwLFxuICAgIGxlZnQ6ICc1MCUnXG4gIH1cbn0sIG93bmVyU3RhdGUub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgJiYge1xuICByaWdodDogJzMwcHgnLFxuICB0b3A6ICcyNHB4JyxcbiAgdHJhbnNmb3JtT3JpZ2luOiAncmlnaHQgY2VudGVyJyxcbiAgJyY6YmVmb3JlJzoge1xuICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgIGNvbnRlbnQ6ICdcIlwiJyxcbiAgICB3aWR0aDogOCxcbiAgICBoZWlnaHQ6IDgsXG4gICAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKC01MCUsIDUwJSkgcm90YXRlKDQ1ZGVnKScsXG4gICAgYmFja2dyb3VuZENvbG9yOiAnaW5oZXJpdCcsXG4gICAgcmlnaHQ6ICctMjAlJyxcbiAgICB0b3A6ICcyNSUnXG4gIH1cbn0sIG93bmVyU3RhdGUuc2l6ZSA9PT0gJ3NtYWxsJyAmJiB7XG4gIGZvbnRTaXplOiB0aGVtZS50eXBvZ3JhcGh5LnB4VG9SZW0oMTIpLFxuICBwYWRkaW5nOiAnMC4yNXJlbSAwLjVyZW0nXG59KSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBTdHlsZWRTbGlkZXJWYWx1ZUxhYmVsLnByb3BUeXBlcyAvKiByZW1vdmUtcHJvcHR5cGVzICovID0ge1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBXYXJuaW5nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8vIHwgVGhlc2UgUHJvcFR5cGVzIGFyZSBnZW5lcmF0ZWQgZnJvbSB0aGUgVHlwZVNjcmlwdCB0eXBlIGRlZmluaXRpb25zIHxcbiAgLy8gfCAgICAgVG8gdXBkYXRlIHRoZW0gZWRpdCB0aGUgZC50cyBmaWxlIGFuZCBydW4gXCJ5YXJuIHByb3B0eXBlc1wiICAgICB8XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLyoqXG4gICAqIEBpZ25vcmVcbiAgICovXG4gIGNoaWxkcmVuOiBQcm9wVHlwZXMubm9kZVxufSA6IHZvaWQgMDtcbmV4cG9ydCB7IFN0eWxlZFNsaWRlclZhbHVlTGFiZWwgYXMgU2xpZGVyVmFsdWVMYWJlbCB9O1xuY29uc3QgU2xpZGVyTWFyayA9IHN0eWxlZCgnc3BhbicsIHtcbiAgbmFtZTogJ011aVNsaWRlcicsXG4gIHNsb3Q6ICdNYXJrJyxcbiAgc2hvdWxkRm9yd2FyZFByb3A6IHByb3AgPT4gc2xvdFNob3VsZEZvcndhcmRQcm9wKHByb3ApICYmIHByb3AgIT09ICdtYXJrQWN0aXZlJyxcbiAgb3ZlcnJpZGVzUmVzb2x2ZXI6IChwcm9wcywgc3R5bGVzKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgbWFya0FjdGl2ZVxuICAgIH0gPSBwcm9wcztcbiAgICByZXR1cm4gW3N0eWxlcy5tYXJrLCBtYXJrQWN0aXZlICYmIHN0eWxlcy5tYXJrQWN0aXZlXTtcbiAgfVxufSkoKHtcbiAgdGhlbWUsXG4gIG93bmVyU3RhdGUsXG4gIG1hcmtBY3RpdmVcbn0pID0+IF9leHRlbmRzKHtcbiAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gIHdpZHRoOiAyLFxuICBoZWlnaHQ6IDIsXG4gIGJvcmRlclJhZGl1czogMSxcbiAgYmFja2dyb3VuZENvbG9yOiAnY3VycmVudENvbG9yJ1xufSwgb3duZXJTdGF0ZS5vcmllbnRhdGlvbiA9PT0gJ2hvcml6b250YWwnICYmIHtcbiAgdG9wOiAnNTAlJyxcbiAgdHJhbnNmb3JtOiAndHJhbnNsYXRlKC0xcHgsIC01MCUpJ1xufSwgb3duZXJTdGF0ZS5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJyAmJiB7XG4gIGxlZnQ6ICc1MCUnLFxuICB0cmFuc2Zvcm06ICd0cmFuc2xhdGUoLTUwJSwgMXB4KSdcbn0sIG1hcmtBY3RpdmUgJiYge1xuICBiYWNrZ3JvdW5kQ29sb3I6ICh0aGVtZS52YXJzIHx8IHRoZW1lKS5wYWxldHRlLmJhY2tncm91bmQucGFwZXIsXG4gIG9wYWNpdHk6IDAuOFxufSkpO1xucHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8gU2xpZGVyTWFyay5wcm9wVHlwZXMgLyogcmVtb3ZlLXByb3B0eXBlcyAqLyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8qKlxuICAgKiBAaWdub3JlXG4gICAqL1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLm5vZGVcbn0gOiB2b2lkIDA7XG5leHBvcnQgeyBTbGlkZXJNYXJrIH07XG5jb25zdCBTbGlkZXJNYXJrTGFiZWwgPSBzdHlsZWQoJ3NwYW4nLCB7XG4gIG5hbWU6ICdNdWlTbGlkZXInLFxuICBzbG90OiAnTWFya0xhYmVsJyxcbiAgc2hvdWxkRm9yd2FyZFByb3A6IHByb3AgPT4gc2xvdFNob3VsZEZvcndhcmRQcm9wKHByb3ApICYmIHByb3AgIT09ICdtYXJrTGFiZWxBY3RpdmUnLFxuICBvdmVycmlkZXNSZXNvbHZlcjogKHByb3BzLCBzdHlsZXMpID0+IHN0eWxlcy5tYXJrTGFiZWxcbn0pKCh7XG4gIHRoZW1lLFxuICBvd25lclN0YXRlLFxuICBtYXJrTGFiZWxBY3RpdmVcbn0pID0+IF9leHRlbmRzKHt9LCB0aGVtZS50eXBvZ3JhcGh5LmJvZHkyLCB7XG4gIGNvbG9yOiAodGhlbWUudmFycyB8fCB0aGVtZSkucGFsZXR0ZS50ZXh0LnNlY29uZGFyeSxcbiAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gIHdoaXRlU3BhY2U6ICdub3dyYXAnXG59LCBvd25lclN0YXRlLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgJiYge1xuICB0b3A6IDMwLFxuICB0cmFuc2Zvcm06ICd0cmFuc2xhdGVYKC01MCUpJyxcbiAgJ0BtZWRpYSAocG9pbnRlcjogY29hcnNlKSc6IHtcbiAgICB0b3A6IDQwXG4gIH1cbn0sIG93bmVyU3RhdGUub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcgJiYge1xuICBsZWZ0OiAzNixcbiAgdHJhbnNmb3JtOiAndHJhbnNsYXRlWSg1MCUpJyxcbiAgJ0BtZWRpYSAocG9pbnRlcjogY29hcnNlKSc6IHtcbiAgICBsZWZ0OiA0NFxuICB9XG59LCBtYXJrTGFiZWxBY3RpdmUgJiYge1xuICBjb2xvcjogKHRoZW1lLnZhcnMgfHwgdGhlbWUpLnBhbGV0dGUudGV4dC5wcmltYXJ5XG59KSk7XG5wcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgPyBTbGlkZXJNYXJrTGFiZWwucHJvcFR5cGVzIC8qIHJlbW92ZS1wcm9wdHlwZXMgKi8gPSB7XG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFdhcm5pbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgLy8gfCBUaGVzZSBQcm9wVHlwZXMgYXJlIGdlbmVyYXRlZCBmcm9tIHRoZSBUeXBlU2NyaXB0IHR5cGUgZGVmaW5pdGlvbnMgfFxuICAvLyB8ICAgICBUbyB1cGRhdGUgdGhlbSBlZGl0IHRoZSBkLnRzIGZpbGUgYW5kIHJ1biBcInlhcm4gcHJvcHR5cGVzXCIgICAgIHxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlXG59IDogdm9pZCAwO1xuZXhwb3J0IHsgU2xpZGVyTWFya0xhYmVsIH07XG5jb25zdCB1c2VVdGlsaXR5Q2xhc3NlcyA9IG93bmVyU3RhdGUgPT4ge1xuICBjb25zdCB7XG4gICAgZGlzYWJsZWQsXG4gICAgZHJhZ2dpbmcsXG4gICAgbWFya2VkLFxuICAgIG9yaWVudGF0aW9uLFxuICAgIHRyYWNrLFxuICAgIGNsYXNzZXMsXG4gICAgY29sb3IsXG4gICAgc2l6ZVxuICB9ID0gb3duZXJTdGF0ZTtcbiAgY29uc3Qgc2xvdHMgPSB7XG4gICAgcm9vdDogWydyb290JywgZGlzYWJsZWQgJiYgJ2Rpc2FibGVkJywgZHJhZ2dpbmcgJiYgJ2RyYWdnaW5nJywgbWFya2VkICYmICdtYXJrZWQnLCBvcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJyAmJiAndmVydGljYWwnLCB0cmFjayA9PT0gJ2ludmVydGVkJyAmJiAndHJhY2tJbnZlcnRlZCcsIHRyYWNrID09PSBmYWxzZSAmJiAndHJhY2tGYWxzZScsIGNvbG9yICYmIGBjb2xvciR7Y2FwaXRhbGl6ZShjb2xvcil9YCwgc2l6ZSAmJiBgc2l6ZSR7Y2FwaXRhbGl6ZShzaXplKX1gXSxcbiAgICByYWlsOiBbJ3JhaWwnXSxcbiAgICB0cmFjazogWyd0cmFjayddLFxuICAgIG1hcms6IFsnbWFyayddLFxuICAgIG1hcmtBY3RpdmU6IFsnbWFya0FjdGl2ZSddLFxuICAgIG1hcmtMYWJlbDogWydtYXJrTGFiZWwnXSxcbiAgICBtYXJrTGFiZWxBY3RpdmU6IFsnbWFya0xhYmVsQWN0aXZlJ10sXG4gICAgdmFsdWVMYWJlbDogWyd2YWx1ZUxhYmVsJ10sXG4gICAgdGh1bWI6IFsndGh1bWInLCBkaXNhYmxlZCAmJiAnZGlzYWJsZWQnLCBzaXplICYmIGB0aHVtYlNpemUke2NhcGl0YWxpemUoc2l6ZSl9YCwgY29sb3IgJiYgYHRodW1iQ29sb3Ike2NhcGl0YWxpemUoY29sb3IpfWBdLFxuICAgIGFjdGl2ZTogWydhY3RpdmUnXSxcbiAgICBkaXNhYmxlZDogWydkaXNhYmxlZCddLFxuICAgIGZvY3VzVmlzaWJsZTogWydmb2N1c1Zpc2libGUnXVxuICB9O1xuICByZXR1cm4gY29tcG9zZUNsYXNzZXMoc2xvdHMsIGdldFNsaWRlclV0aWxpdHlDbGFzcywgY2xhc3Nlcyk7XG59O1xuY29uc3QgRm9yd2FyZCA9ICh7XG4gIGNoaWxkcmVuXG59KSA9PiBjaGlsZHJlbjtcbmNvbnN0IFNsaWRlciA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKGZ1bmN0aW9uIFNsaWRlcihpbnB1dFByb3BzLCByZWYpIHtcbiAgdmFyIF9yZWYsIF9zbG90cyRyb290LCBfcmVmMiwgX3Nsb3RzJHJhaWwsIF9yZWYzLCBfc2xvdHMkdHJhY2ssIF9yZWY0LCBfc2xvdHMkdGh1bWIsIF9yZWY1LCBfc2xvdHMkdmFsdWVMYWJlbCwgX3JlZjYsIF9zbG90cyRtYXJrLCBfcmVmNywgX3Nsb3RzJG1hcmtMYWJlbCwgX3JlZjgsIF9zbG90cyRpbnB1dCwgX3Nsb3RQcm9wcyRyb290LCBfc2xvdFByb3BzJHJhaWwsIF9zbG90UHJvcHMkdHJhY2ssIF9zbG90UHJvcHMkdGh1bWIsIF9zbG90UHJvcHMkdmFsdWVMYWJlbCwgX3Nsb3RQcm9wcyRtYXJrLCBfc2xvdFByb3BzJG1hcmtMYWJlbCwgX3Nsb3RQcm9wcyRpbnB1dDtcbiAgY29uc3QgcHJvcHMgPSB1c2VUaGVtZVByb3BzKHtcbiAgICBwcm9wczogaW5wdXRQcm9wcyxcbiAgICBuYW1lOiAnTXVpU2xpZGVyJ1xuICB9KTtcbiAgY29uc3QgdGhlbWUgPSB1c2VUaGVtZSgpO1xuICBjb25zdCBpc1J0bCA9IHRoZW1lLmRpcmVjdGlvbiA9PT0gJ3J0bCc7XG4gIGNvbnN0IHtcbiAgICAgICdhcmlhLWxhYmVsJzogYXJpYUxhYmVsLFxuICAgICAgJ2FyaWEtdmFsdWV0ZXh0JzogYXJpYVZhbHVldGV4dCxcbiAgICAgICdhcmlhLWxhYmVsbGVkYnknOiBhcmlhTGFiZWxsZWRieSxcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC9wcm9wLXR5cGVzXG4gICAgICBjb21wb25lbnQgPSAnc3BhbicsXG4gICAgICBjb21wb25lbnRzID0ge30sXG4gICAgICBjb21wb25lbnRzUHJvcHMgPSB7fSxcbiAgICAgIGNvbG9yID0gJ3ByaW1hcnknLFxuICAgICAgY2xhc3NlczogY2xhc3Nlc1Byb3AsXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvcHJvcC10eXBlc1xuICAgICAgY2xhc3NOYW1lLFxuICAgICAgZGlzYWJsZVN3YXAgPSBmYWxzZSxcbiAgICAgIGRpc2FibGVkID0gZmFsc2UsXG4gICAgICBnZXRBcmlhTGFiZWwsXG4gICAgICBnZXRBcmlhVmFsdWVUZXh0LFxuICAgICAgbWFya3M6IG1hcmtzUHJvcCA9IGZhbHNlLFxuICAgICAgbWF4ID0gMTAwLFxuICAgICAgbWluID0gMCxcbiAgICAgIG9yaWVudGF0aW9uID0gJ2hvcml6b250YWwnLFxuICAgICAgc2l6ZSA9ICdtZWRpdW0nLFxuICAgICAgc3RlcCA9IDEsXG4gICAgICBzY2FsZSA9IElkZW50aXR5LFxuICAgICAgc2xvdFByb3BzLFxuICAgICAgc2xvdHMsXG4gICAgICB0cmFjayA9ICdub3JtYWwnLFxuICAgICAgdmFsdWVMYWJlbERpc3BsYXkgPSAnb2ZmJyxcbiAgICAgIHZhbHVlTGFiZWxGb3JtYXQgPSBJZGVudGl0eVxuICAgIH0gPSBwcm9wcyxcbiAgICBvdGhlciA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQpO1xuICBjb25zdCBvd25lclN0YXRlID0gX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgaXNSdGwsXG4gICAgbWF4LFxuICAgIG1pbixcbiAgICBjbGFzc2VzOiBjbGFzc2VzUHJvcCxcbiAgICBkaXNhYmxlZCxcbiAgICBkaXNhYmxlU3dhcCxcbiAgICBvcmllbnRhdGlvbixcbiAgICBtYXJrczogbWFya3NQcm9wLFxuICAgIGNvbG9yLFxuICAgIHNpemUsXG4gICAgc3RlcCxcbiAgICBzY2FsZSxcbiAgICB0cmFjayxcbiAgICB2YWx1ZUxhYmVsRGlzcGxheSxcbiAgICB2YWx1ZUxhYmVsRm9ybWF0XG4gIH0pO1xuICBjb25zdCB7XG4gICAgYXhpc1Byb3BzLFxuICAgIGdldFJvb3RQcm9wcyxcbiAgICBnZXRIaWRkZW5JbnB1dFByb3BzLFxuICAgIGdldFRodW1iUHJvcHMsXG4gICAgb3BlbixcbiAgICBhY3RpdmUsXG4gICAgYXhpcyxcbiAgICBmb2N1c2VkVGh1bWJJbmRleCxcbiAgICByYW5nZSxcbiAgICBkcmFnZ2luZyxcbiAgICBtYXJrcyxcbiAgICB2YWx1ZXMsXG4gICAgdHJhY2tPZmZzZXQsXG4gICAgdHJhY2tMZWFwXG4gIH0gPSB1c2VTbGlkZXIoX2V4dGVuZHMoe30sIG93bmVyU3RhdGUsIHtcbiAgICByZWZcbiAgfSkpO1xuICBvd25lclN0YXRlLm1hcmtlZCA9IG1hcmtzLmxlbmd0aCA+IDAgJiYgbWFya3Muc29tZShtYXJrID0+IG1hcmsubGFiZWwpO1xuICBvd25lclN0YXRlLmRyYWdnaW5nID0gZHJhZ2dpbmc7XG4gIG93bmVyU3RhdGUuZm9jdXNlZFRodW1iSW5kZXggPSBmb2N1c2VkVGh1bWJJbmRleDtcbiAgY29uc3QgY2xhc3NlcyA9IHVzZVV0aWxpdHlDbGFzc2VzKG93bmVyU3RhdGUpO1xuXG4gIC8vIHN1cHBvcnQgYm90aCBgc2xvdHNgIGFuZCBgY29tcG9uZW50c2AgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHlcbiAgY29uc3QgUm9vdFNsb3QgPSAoX3JlZiA9IChfc2xvdHMkcm9vdCA9IHNsb3RzID09IG51bGwgPyB2b2lkIDAgOiBzbG90cy5yb290KSAhPSBudWxsID8gX3Nsb3RzJHJvb3QgOiBjb21wb25lbnRzLlJvb3QpICE9IG51bGwgPyBfcmVmIDogU2xpZGVyUm9vdDtcbiAgY29uc3QgUmFpbFNsb3QgPSAoX3JlZjIgPSAoX3Nsb3RzJHJhaWwgPSBzbG90cyA9PSBudWxsID8gdm9pZCAwIDogc2xvdHMucmFpbCkgIT0gbnVsbCA/IF9zbG90cyRyYWlsIDogY29tcG9uZW50cy5SYWlsKSAhPSBudWxsID8gX3JlZjIgOiBTbGlkZXJSYWlsO1xuICBjb25zdCBUcmFja1Nsb3QgPSAoX3JlZjMgPSAoX3Nsb3RzJHRyYWNrID0gc2xvdHMgPT0gbnVsbCA/IHZvaWQgMCA6IHNsb3RzLnRyYWNrKSAhPSBudWxsID8gX3Nsb3RzJHRyYWNrIDogY29tcG9uZW50cy5UcmFjaykgIT0gbnVsbCA/IF9yZWYzIDogU2xpZGVyVHJhY2s7XG4gIGNvbnN0IFRodW1iU2xvdCA9IChfcmVmNCA9IChfc2xvdHMkdGh1bWIgPSBzbG90cyA9PSBudWxsID8gdm9pZCAwIDogc2xvdHMudGh1bWIpICE9IG51bGwgPyBfc2xvdHMkdGh1bWIgOiBjb21wb25lbnRzLlRodW1iKSAhPSBudWxsID8gX3JlZjQgOiBTbGlkZXJUaHVtYjtcbiAgY29uc3QgVmFsdWVMYWJlbFNsb3QgPSAoX3JlZjUgPSAoX3Nsb3RzJHZhbHVlTGFiZWwgPSBzbG90cyA9PSBudWxsID8gdm9pZCAwIDogc2xvdHMudmFsdWVMYWJlbCkgIT0gbnVsbCA/IF9zbG90cyR2YWx1ZUxhYmVsIDogY29tcG9uZW50cy5WYWx1ZUxhYmVsKSAhPSBudWxsID8gX3JlZjUgOiBTdHlsZWRTbGlkZXJWYWx1ZUxhYmVsO1xuICBjb25zdCBNYXJrU2xvdCA9IChfcmVmNiA9IChfc2xvdHMkbWFyayA9IHNsb3RzID09IG51bGwgPyB2b2lkIDAgOiBzbG90cy5tYXJrKSAhPSBudWxsID8gX3Nsb3RzJG1hcmsgOiBjb21wb25lbnRzLk1hcmspICE9IG51bGwgPyBfcmVmNiA6IFNsaWRlck1hcms7XG4gIGNvbnN0IE1hcmtMYWJlbFNsb3QgPSAoX3JlZjcgPSAoX3Nsb3RzJG1hcmtMYWJlbCA9IHNsb3RzID09IG51bGwgPyB2b2lkIDAgOiBzbG90cy5tYXJrTGFiZWwpICE9IG51bGwgPyBfc2xvdHMkbWFya0xhYmVsIDogY29tcG9uZW50cy5NYXJrTGFiZWwpICE9IG51bGwgPyBfcmVmNyA6IFNsaWRlck1hcmtMYWJlbDtcbiAgY29uc3QgSW5wdXRTbG90ID0gKF9yZWY4ID0gKF9zbG90cyRpbnB1dCA9IHNsb3RzID09IG51bGwgPyB2b2lkIDAgOiBzbG90cy5pbnB1dCkgIT0gbnVsbCA/IF9zbG90cyRpbnB1dCA6IGNvbXBvbmVudHMuSW5wdXQpICE9IG51bGwgPyBfcmVmOCA6ICdpbnB1dCc7XG4gIGNvbnN0IHJvb3RTbG90UHJvcHMgPSAoX3Nsb3RQcm9wcyRyb290ID0gc2xvdFByb3BzID09IG51bGwgPyB2b2lkIDAgOiBzbG90UHJvcHMucm9vdCkgIT0gbnVsbCA/IF9zbG90UHJvcHMkcm9vdCA6IGNvbXBvbmVudHNQcm9wcy5yb290O1xuICBjb25zdCByYWlsU2xvdFByb3BzID0gKF9zbG90UHJvcHMkcmFpbCA9IHNsb3RQcm9wcyA9PSBudWxsID8gdm9pZCAwIDogc2xvdFByb3BzLnJhaWwpICE9IG51bGwgPyBfc2xvdFByb3BzJHJhaWwgOiBjb21wb25lbnRzUHJvcHMucmFpbDtcbiAgY29uc3QgdHJhY2tTbG90UHJvcHMgPSAoX3Nsb3RQcm9wcyR0cmFjayA9IHNsb3RQcm9wcyA9PSBudWxsID8gdm9pZCAwIDogc2xvdFByb3BzLnRyYWNrKSAhPSBudWxsID8gX3Nsb3RQcm9wcyR0cmFjayA6IGNvbXBvbmVudHNQcm9wcy50cmFjaztcbiAgY29uc3QgdGh1bWJTbG90UHJvcHMgPSAoX3Nsb3RQcm9wcyR0aHVtYiA9IHNsb3RQcm9wcyA9PSBudWxsID8gdm9pZCAwIDogc2xvdFByb3BzLnRodW1iKSAhPSBudWxsID8gX3Nsb3RQcm9wcyR0aHVtYiA6IGNvbXBvbmVudHNQcm9wcy50aHVtYjtcbiAgY29uc3QgdmFsdWVMYWJlbFNsb3RQcm9wcyA9IChfc2xvdFByb3BzJHZhbHVlTGFiZWwgPSBzbG90UHJvcHMgPT0gbnVsbCA/IHZvaWQgMCA6IHNsb3RQcm9wcy52YWx1ZUxhYmVsKSAhPSBudWxsID8gX3Nsb3RQcm9wcyR2YWx1ZUxhYmVsIDogY29tcG9uZW50c1Byb3BzLnZhbHVlTGFiZWw7XG4gIGNvbnN0IG1hcmtTbG90UHJvcHMgPSAoX3Nsb3RQcm9wcyRtYXJrID0gc2xvdFByb3BzID09IG51bGwgPyB2b2lkIDAgOiBzbG90UHJvcHMubWFyaykgIT0gbnVsbCA/IF9zbG90UHJvcHMkbWFyayA6IGNvbXBvbmVudHNQcm9wcy5tYXJrO1xuICBjb25zdCBtYXJrTGFiZWxTbG90UHJvcHMgPSAoX3Nsb3RQcm9wcyRtYXJrTGFiZWwgPSBzbG90UHJvcHMgPT0gbnVsbCA/IHZvaWQgMCA6IHNsb3RQcm9wcy5tYXJrTGFiZWwpICE9IG51bGwgPyBfc2xvdFByb3BzJG1hcmtMYWJlbCA6IGNvbXBvbmVudHNQcm9wcy5tYXJrTGFiZWw7XG4gIGNvbnN0IGlucHV0U2xvdFByb3BzID0gKF9zbG90UHJvcHMkaW5wdXQgPSBzbG90UHJvcHMgPT0gbnVsbCA/IHZvaWQgMCA6IHNsb3RQcm9wcy5pbnB1dCkgIT0gbnVsbCA/IF9zbG90UHJvcHMkaW5wdXQgOiBjb21wb25lbnRzUHJvcHMuaW5wdXQ7XG4gIGNvbnN0IHJvb3RQcm9wcyA9IHVzZVNsb3RQcm9wcyh7XG4gICAgZWxlbWVudFR5cGU6IFJvb3RTbG90LFxuICAgIGdldFNsb3RQcm9wczogZ2V0Um9vdFByb3BzLFxuICAgIGV4dGVybmFsU2xvdFByb3BzOiByb290U2xvdFByb3BzLFxuICAgIGV4dGVybmFsRm9yd2FyZGVkUHJvcHM6IG90aGVyLFxuICAgIGFkZGl0aW9uYWxQcm9wczogX2V4dGVuZHMoe30sIHNob3VsZFNwcmVhZEFkZGl0aW9uYWxQcm9wcyhSb290U2xvdCkgJiYge1xuICAgICAgYXM6IGNvbXBvbmVudFxuICAgIH0pLFxuICAgIG93bmVyU3RhdGU6IF9leHRlbmRzKHt9LCBvd25lclN0YXRlLCByb290U2xvdFByb3BzID09IG51bGwgPyB2b2lkIDAgOiByb290U2xvdFByb3BzLm93bmVyU3RhdGUpLFxuICAgIGNsYXNzTmFtZTogW2NsYXNzZXMucm9vdCwgY2xhc3NOYW1lXVxuICB9KTtcbiAgY29uc3QgcmFpbFByb3BzID0gdXNlU2xvdFByb3BzKHtcbiAgICBlbGVtZW50VHlwZTogUmFpbFNsb3QsXG4gICAgZXh0ZXJuYWxTbG90UHJvcHM6IHJhaWxTbG90UHJvcHMsXG4gICAgb3duZXJTdGF0ZSxcbiAgICBjbGFzc05hbWU6IGNsYXNzZXMucmFpbFxuICB9KTtcbiAgY29uc3QgdHJhY2tQcm9wcyA9IHVzZVNsb3RQcm9wcyh7XG4gICAgZWxlbWVudFR5cGU6IFRyYWNrU2xvdCxcbiAgICBleHRlcm5hbFNsb3RQcm9wczogdHJhY2tTbG90UHJvcHMsXG4gICAgYWRkaXRpb25hbFByb3BzOiB7XG4gICAgICBzdHlsZTogX2V4dGVuZHMoe30sIGF4aXNQcm9wc1theGlzXS5vZmZzZXQodHJhY2tPZmZzZXQpLCBheGlzUHJvcHNbYXhpc10ubGVhcCh0cmFja0xlYXApKVxuICAgIH0sXG4gICAgb3duZXJTdGF0ZTogX2V4dGVuZHMoe30sIG93bmVyU3RhdGUsIHRyYWNrU2xvdFByb3BzID09IG51bGwgPyB2b2lkIDAgOiB0cmFja1Nsb3RQcm9wcy5vd25lclN0YXRlKSxcbiAgICBjbGFzc05hbWU6IGNsYXNzZXMudHJhY2tcbiAgfSk7XG4gIGNvbnN0IHRodW1iUHJvcHMgPSB1c2VTbG90UHJvcHMoe1xuICAgIGVsZW1lbnRUeXBlOiBUaHVtYlNsb3QsXG4gICAgZ2V0U2xvdFByb3BzOiBnZXRUaHVtYlByb3BzLFxuICAgIGV4dGVybmFsU2xvdFByb3BzOiB0aHVtYlNsb3RQcm9wcyxcbiAgICBvd25lclN0YXRlOiBfZXh0ZW5kcyh7fSwgb3duZXJTdGF0ZSwgdGh1bWJTbG90UHJvcHMgPT0gbnVsbCA/IHZvaWQgMCA6IHRodW1iU2xvdFByb3BzLm93bmVyU3RhdGUpXG4gIH0pO1xuICBjb25zdCB2YWx1ZUxhYmVsUHJvcHMgPSB1c2VTbG90UHJvcHMoe1xuICAgIGVsZW1lbnRUeXBlOiBWYWx1ZUxhYmVsU2xvdCxcbiAgICBleHRlcm5hbFNsb3RQcm9wczogdmFsdWVMYWJlbFNsb3RQcm9wcyxcbiAgICBvd25lclN0YXRlOiBfZXh0ZW5kcyh7fSwgb3duZXJTdGF0ZSwgdmFsdWVMYWJlbFNsb3RQcm9wcyA9PSBudWxsID8gdm9pZCAwIDogdmFsdWVMYWJlbFNsb3RQcm9wcy5vd25lclN0YXRlKSxcbiAgICBjbGFzc05hbWU6IGNsYXNzZXMudmFsdWVMYWJlbFxuICB9KTtcbiAgY29uc3QgbWFya1Byb3BzID0gdXNlU2xvdFByb3BzKHtcbiAgICBlbGVtZW50VHlwZTogTWFya1Nsb3QsXG4gICAgZXh0ZXJuYWxTbG90UHJvcHM6IG1hcmtTbG90UHJvcHMsXG4gICAgb3duZXJTdGF0ZSxcbiAgICBjbGFzc05hbWU6IGNsYXNzZXMubWFya1xuICB9KTtcbiAgY29uc3QgbWFya0xhYmVsUHJvcHMgPSB1c2VTbG90UHJvcHMoe1xuICAgIGVsZW1lbnRUeXBlOiBNYXJrTGFiZWxTbG90LFxuICAgIGV4dGVybmFsU2xvdFByb3BzOiBtYXJrTGFiZWxTbG90UHJvcHMsXG4gICAgb3duZXJTdGF0ZVxuICB9KTtcbiAgY29uc3QgaW5wdXRTbGlkZXJQcm9wcyA9IHVzZVNsb3RQcm9wcyh7XG4gICAgZWxlbWVudFR5cGU6IElucHV0U2xvdCxcbiAgICBnZXRTbG90UHJvcHM6IGdldEhpZGRlbklucHV0UHJvcHMsXG4gICAgZXh0ZXJuYWxTbG90UHJvcHM6IGlucHV0U2xvdFByb3BzLFxuICAgIG93bmVyU3RhdGVcbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovX2pzeHMoUm9vdFNsb3QsIF9leHRlbmRzKHt9LCByb290UHJvcHMsIHtcbiAgICBjaGlsZHJlbjogWy8qI19fUFVSRV9fKi9fanN4KFJhaWxTbG90LCBfZXh0ZW5kcyh7fSwgcmFpbFByb3BzKSksIC8qI19fUFVSRV9fKi9fanN4KFRyYWNrU2xvdCwgX2V4dGVuZHMoe30sIHRyYWNrUHJvcHMpKSwgbWFya3MuZmlsdGVyKG1hcmsgPT4gbWFyay52YWx1ZSA+PSBtaW4gJiYgbWFyay52YWx1ZSA8PSBtYXgpLm1hcCgobWFyaywgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHBlcmNlbnQgPSB2YWx1ZVRvUGVyY2VudChtYXJrLnZhbHVlLCBtaW4sIG1heCk7XG4gICAgICBjb25zdCBzdHlsZSA9IGF4aXNQcm9wc1theGlzXS5vZmZzZXQocGVyY2VudCk7XG4gICAgICBsZXQgbWFya0FjdGl2ZTtcbiAgICAgIGlmICh0cmFjayA9PT0gZmFsc2UpIHtcbiAgICAgICAgbWFya0FjdGl2ZSA9IHZhbHVlcy5pbmRleE9mKG1hcmsudmFsdWUpICE9PSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hcmtBY3RpdmUgPSB0cmFjayA9PT0gJ25vcm1hbCcgJiYgKHJhbmdlID8gbWFyay52YWx1ZSA+PSB2YWx1ZXNbMF0gJiYgbWFyay52YWx1ZSA8PSB2YWx1ZXNbdmFsdWVzLmxlbmd0aCAtIDFdIDogbWFyay52YWx1ZSA8PSB2YWx1ZXNbMF0pIHx8IHRyYWNrID09PSAnaW52ZXJ0ZWQnICYmIChyYW5nZSA/IG1hcmsudmFsdWUgPD0gdmFsdWVzWzBdIHx8IG1hcmsudmFsdWUgPj0gdmFsdWVzW3ZhbHVlcy5sZW5ndGggLSAxXSA6IG1hcmsudmFsdWUgPj0gdmFsdWVzWzBdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAvKiNfX1BVUkVfXyovX2pzeHMoUmVhY3QuRnJhZ21lbnQsIHtcbiAgICAgICAgY2hpbGRyZW46IFsvKiNfX1BVUkVfXyovX2pzeChNYXJrU2xvdCwgX2V4dGVuZHMoe1xuICAgICAgICAgIFwiZGF0YS1pbmRleFwiOiBpbmRleFxuICAgICAgICB9LCBtYXJrUHJvcHMsICFpc0hvc3RDb21wb25lbnQoTWFya1Nsb3QpICYmIHtcbiAgICAgICAgICBtYXJrQWN0aXZlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBzdHlsZTogX2V4dGVuZHMoe30sIHN0eWxlLCBtYXJrUHJvcHMuc3R5bGUpLFxuICAgICAgICAgIGNsYXNzTmFtZTogY2xzeChtYXJrUHJvcHMuY2xhc3NOYW1lLCBtYXJrQWN0aXZlICYmIGNsYXNzZXMubWFya0FjdGl2ZSlcbiAgICAgICAgfSkpLCBtYXJrLmxhYmVsICE9IG51bGwgPyAvKiNfX1BVUkVfXyovX2pzeChNYXJrTGFiZWxTbG90LCBfZXh0ZW5kcyh7XG4gICAgICAgICAgXCJhcmlhLWhpZGRlblwiOiB0cnVlLFxuICAgICAgICAgIFwiZGF0YS1pbmRleFwiOiBpbmRleFxuICAgICAgICB9LCBtYXJrTGFiZWxQcm9wcywgIWlzSG9zdENvbXBvbmVudChNYXJrTGFiZWxTbG90KSAmJiB7XG4gICAgICAgICAgbWFya0xhYmVsQWN0aXZlOiBtYXJrQWN0aXZlXG4gICAgICAgIH0sIHtcbiAgICAgICAgICBzdHlsZTogX2V4dGVuZHMoe30sIHN0eWxlLCBtYXJrTGFiZWxQcm9wcy5zdHlsZSksXG4gICAgICAgICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMubWFya0xhYmVsLCBtYXJrTGFiZWxQcm9wcy5jbGFzc05hbWUsIG1hcmtBY3RpdmUgJiYgY2xhc3Nlcy5tYXJrTGFiZWxBY3RpdmUpLFxuICAgICAgICAgIGNoaWxkcmVuOiBtYXJrLmxhYmVsXG4gICAgICAgIH0pKSA6IG51bGxdXG4gICAgICB9LCBpbmRleCk7XG4gICAgfSksIHZhbHVlcy5tYXAoKHZhbHVlLCBpbmRleCkgPT4ge1xuICAgICAgY29uc3QgcGVyY2VudCA9IHZhbHVlVG9QZXJjZW50KHZhbHVlLCBtaW4sIG1heCk7XG4gICAgICBjb25zdCBzdHlsZSA9IGF4aXNQcm9wc1theGlzXS5vZmZzZXQocGVyY2VudCk7XG4gICAgICBjb25zdCBWYWx1ZUxhYmVsQ29tcG9uZW50ID0gdmFsdWVMYWJlbERpc3BsYXkgPT09ICdvZmYnID8gRm9yd2FyZCA6IFZhbHVlTGFiZWxTbG90O1xuICAgICAgcmV0dXJuIC8qI19fUFVSRV9fKi9fanN4KFJlYWN0LkZyYWdtZW50LCB7XG4gICAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovX2pzeChWYWx1ZUxhYmVsQ29tcG9uZW50LCBfZXh0ZW5kcyh7fSwgIWlzSG9zdENvbXBvbmVudChWYWx1ZUxhYmVsQ29tcG9uZW50KSAmJiB7XG4gICAgICAgICAgdmFsdWVMYWJlbEZvcm1hdCxcbiAgICAgICAgICB2YWx1ZUxhYmVsRGlzcGxheSxcbiAgICAgICAgICB2YWx1ZTogdHlwZW9mIHZhbHVlTGFiZWxGb3JtYXQgPT09ICdmdW5jdGlvbicgPyB2YWx1ZUxhYmVsRm9ybWF0KHNjYWxlKHZhbHVlKSwgaW5kZXgpIDogdmFsdWVMYWJlbEZvcm1hdCxcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBvcGVuOiBvcGVuID09PSBpbmRleCB8fCBhY3RpdmUgPT09IGluZGV4IHx8IHZhbHVlTGFiZWxEaXNwbGF5ID09PSAnb24nLFxuICAgICAgICAgIGRpc2FibGVkXG4gICAgICAgIH0sIHZhbHVlTGFiZWxQcm9wcywge1xuICAgICAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovX2pzeChUaHVtYlNsb3QsIF9leHRlbmRzKHtcbiAgICAgICAgICAgIFwiZGF0YS1pbmRleFwiOiBpbmRleCxcbiAgICAgICAgICAgIFwiZGF0YS1mb2N1c3Zpc2libGVcIjogZm9jdXNlZFRodW1iSW5kZXggPT09IGluZGV4XG4gICAgICAgICAgfSwgdGh1bWJQcm9wcywge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMudGh1bWIsIHRodW1iUHJvcHMuY2xhc3NOYW1lLCBhY3RpdmUgPT09IGluZGV4ICYmIGNsYXNzZXMuYWN0aXZlLCBmb2N1c2VkVGh1bWJJbmRleCA9PT0gaW5kZXggJiYgY2xhc3Nlcy5mb2N1c1Zpc2libGUpLFxuICAgICAgICAgICAgc3R5bGU6IF9leHRlbmRzKHt9LCBzdHlsZSwge1xuICAgICAgICAgICAgICBwb2ludGVyRXZlbnRzOiBkaXNhYmxlU3dhcCAmJiBhY3RpdmUgIT09IGluZGV4ID8gJ25vbmUnIDogdW5kZWZpbmVkXG4gICAgICAgICAgICB9LCB0aHVtYlByb3BzLnN0eWxlKSxcbiAgICAgICAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovX2pzeChJbnB1dFNsb3QsIF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgXCJkYXRhLWluZGV4XCI6IGluZGV4LFxuICAgICAgICAgICAgICBcImFyaWEtbGFiZWxcIjogZ2V0QXJpYUxhYmVsID8gZ2V0QXJpYUxhYmVsKGluZGV4KSA6IGFyaWFMYWJlbCxcbiAgICAgICAgICAgICAgXCJhcmlhLXZhbHVlbm93XCI6IHNjYWxlKHZhbHVlKSxcbiAgICAgICAgICAgICAgXCJhcmlhLWxhYmVsbGVkYnlcIjogYXJpYUxhYmVsbGVkYnksXG4gICAgICAgICAgICAgIFwiYXJpYS12YWx1ZXRleHRcIjogZ2V0QXJpYVZhbHVlVGV4dCA/IGdldEFyaWFWYWx1ZVRleHQoc2NhbGUodmFsdWUpLCBpbmRleCkgOiBhcmlhVmFsdWV0ZXh0LFxuICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVzW2luZGV4XVxuICAgICAgICAgICAgfSwgaW5wdXRTbGlkZXJQcm9wcykpXG4gICAgICAgICAgfSkpXG4gICAgICAgIH0pKVxuICAgICAgfSwgaW5kZXgpO1xuICAgIH0pXVxuICB9KSk7XG59KTtcbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFNsaWRlci5wcm9wVHlwZXMgLyogcmVtb3ZlLXByb3B0eXBlcyAqLyA9IHtcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gV2FybmluZyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAvLyB8IFRoZXNlIFByb3BUeXBlcyBhcmUgZ2VuZXJhdGVkIGZyb20gdGhlIFR5cGVTY3JpcHQgdHlwZSBkZWZpbml0aW9ucyB8XG4gIC8vIHwgICAgIFRvIHVwZGF0ZSB0aGVtIGVkaXQgdGhlIGQudHMgZmlsZSBhbmQgcnVuIFwieWFybiBwcm9wdHlwZXNcIiAgICAgfFxuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gIC8qKlxuICAgKiBUaGUgbGFiZWwgb2YgdGhlIHNsaWRlci5cbiAgICovXG4gICdhcmlhLWxhYmVsJzogY2hhaW5Qcm9wVHlwZXMoUHJvcFR5cGVzLnN0cmluZywgcHJvcHMgPT4ge1xuICAgIGNvbnN0IHJhbmdlID0gQXJyYXkuaXNBcnJheShwcm9wcy52YWx1ZSB8fCBwcm9wcy5kZWZhdWx0VmFsdWUpO1xuICAgIGlmIChyYW5nZSAmJiBwcm9wc1snYXJpYS1sYWJlbCddICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01VSTogWW91IG5lZWQgdG8gdXNlIHRoZSBgZ2V0QXJpYUxhYmVsYCBwcm9wIGluc3RlYWQgb2YgYGFyaWEtbGFiZWxgIHdoZW4gdXNpbmcgYSByYW5nZSBzbGlkZXIuJyk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9KSxcbiAgLyoqXG4gICAqIFRoZSBpZCBvZiB0aGUgZWxlbWVudCBjb250YWluaW5nIGEgbGFiZWwgZm9yIHRoZSBzbGlkZXIuXG4gICAqL1xuICAnYXJpYS1sYWJlbGxlZGJ5JzogUHJvcFR5cGVzLnN0cmluZyxcbiAgLyoqXG4gICAqIEEgc3RyaW5nIHZhbHVlIHRoYXQgcHJvdmlkZXMgYSB1c2VyLWZyaWVuZGx5IG5hbWUgZm9yIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBzbGlkZXIuXG4gICAqL1xuICAnYXJpYS12YWx1ZXRleHQnOiBjaGFpblByb3BUeXBlcyhQcm9wVHlwZXMuc3RyaW5nLCBwcm9wcyA9PiB7XG4gICAgY29uc3QgcmFuZ2UgPSBBcnJheS5pc0FycmF5KHByb3BzLnZhbHVlIHx8IHByb3BzLmRlZmF1bHRWYWx1ZSk7XG4gICAgaWYgKHJhbmdlICYmIHByb3BzWydhcmlhLXZhbHVldGV4dCddICE9IG51bGwpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ01VSTogWW91IG5lZWQgdG8gdXNlIHRoZSBgZ2V0QXJpYVZhbHVlVGV4dGAgcHJvcCBpbnN0ZWFkIG9mIGBhcmlhLXZhbHVldGV4dGAgd2hlbiB1c2luZyBhIHJhbmdlIHNsaWRlci4nKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH0pLFxuICAvKipcbiAgICogQGlnbm9yZVxuICAgKi9cbiAgY2hpbGRyZW46IFByb3BUeXBlcy5ub2RlLFxuICAvKipcbiAgICogT3ZlcnJpZGUgb3IgZXh0ZW5kIHRoZSBzdHlsZXMgYXBwbGllZCB0byB0aGUgY29tcG9uZW50LlxuICAgKi9cbiAgY2xhc3NlczogUHJvcFR5cGVzLm9iamVjdCxcbiAgLyoqXG4gICAqIFRoZSBjb2xvciBvZiB0aGUgY29tcG9uZW50LlxuICAgKiBJdCBzdXBwb3J0cyBib3RoIGRlZmF1bHQgYW5kIGN1c3RvbSB0aGVtZSBjb2xvcnMsIHdoaWNoIGNhbiBiZSBhZGRlZCBhcyBzaG93biBpbiB0aGVcbiAgICogW3BhbGV0dGUgY3VzdG9taXphdGlvbiBndWlkZV0oaHR0cHM6Ly9tdWkuY29tL21hdGVyaWFsLXVpL2N1c3RvbWl6YXRpb24vcGFsZXR0ZS8jYWRkaW5nLW5ldy1jb2xvcnMpLlxuICAgKiBAZGVmYXVsdCAncHJpbWFyeSdcbiAgICovXG4gIGNvbG9yOiBQcm9wVHlwZXMgLyogQHR5cGVzY3JpcHQtdG8tcHJvcHR5cGVzLWlnbm9yZSAqLy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5vbmVPZihbJ3ByaW1hcnknLCAnc2Vjb25kYXJ5J10pLCBQcm9wVHlwZXMuc3RyaW5nXSksXG4gIC8qKlxuICAgKiBUaGUgY29tcG9uZW50cyB1c2VkIGZvciBlYWNoIHNsb3QgaW5zaWRlLlxuICAgKlxuICAgKiBUaGlzIHByb3AgaXMgYW4gYWxpYXMgZm9yIHRoZSBgc2xvdHNgIHByb3AuXG4gICAqIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIHRoZSBgc2xvdHNgIHByb3AgaW5zdGVhZC5cbiAgICpcbiAgICogQGRlZmF1bHQge31cbiAgICovXG4gIGNvbXBvbmVudHM6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgSW5wdXQ6IFByb3BUeXBlcy5lbGVtZW50VHlwZSxcbiAgICBNYXJrOiBQcm9wVHlwZXMuZWxlbWVudFR5cGUsXG4gICAgTWFya0xhYmVsOiBQcm9wVHlwZXMuZWxlbWVudFR5cGUsXG4gICAgUmFpbDogUHJvcFR5cGVzLmVsZW1lbnRUeXBlLFxuICAgIFJvb3Q6IFByb3BUeXBlcy5lbGVtZW50VHlwZSxcbiAgICBUaHVtYjogUHJvcFR5cGVzLmVsZW1lbnRUeXBlLFxuICAgIFRyYWNrOiBQcm9wVHlwZXMuZWxlbWVudFR5cGUsXG4gICAgVmFsdWVMYWJlbDogUHJvcFR5cGVzLmVsZW1lbnRUeXBlXG4gIH0pLFxuICAvKipcbiAgICogVGhlIGV4dHJhIHByb3BzIGZvciB0aGUgc2xvdCBjb21wb25lbnRzLlxuICAgKiBZb3UgY2FuIG92ZXJyaWRlIHRoZSBleGlzdGluZyBwcm9wcyBvciBhZGQgbmV3IG9uZXMuXG4gICAqXG4gICAqIFRoaXMgcHJvcCBpcyBhbiBhbGlhcyBmb3IgdGhlIGBzbG90UHJvcHNgIHByb3AuXG4gICAqIEl0J3MgcmVjb21tZW5kZWQgdG8gdXNlIHRoZSBgc2xvdFByb3BzYCBwcm9wIGluc3RlYWQsIGFzIGBjb21wb25lbnRzUHJvcHNgIHdpbGwgYmUgZGVwcmVjYXRlZCBpbiB0aGUgZnV0dXJlLlxuICAgKlxuICAgKiBAZGVmYXVsdCB7fVxuICAgKi9cbiAgY29tcG9uZW50c1Byb3BzOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGlucHV0OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm9iamVjdF0pLFxuICAgIG1hcms6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMub2JqZWN0XSksXG4gICAgbWFya0xhYmVsOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm9iamVjdF0pLFxuICAgIHJhaWw6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMub2JqZWN0XSksXG4gICAgcm9vdDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5vYmplY3RdKSxcbiAgICB0aHVtYjogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5vYmplY3RdKSxcbiAgICB0cmFjazogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5vYmplY3RdKSxcbiAgICB2YWx1ZUxhYmVsOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLnNoYXBlKHtcbiAgICAgIGNoaWxkcmVuOiBQcm9wVHlwZXMuZWxlbWVudCxcbiAgICAgIGNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgIG9wZW46IFByb3BUeXBlcy5ib29sLFxuICAgICAgc3R5bGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICB2YWx1ZTogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgIHZhbHVlTGFiZWxEaXNwbGF5OiBQcm9wVHlwZXMub25lT2YoWydhdXRvJywgJ29mZicsICdvbiddKVxuICAgIH0pXSlcbiAgfSksXG4gIC8qKlxuICAgKiBUaGUgZGVmYXVsdCB2YWx1ZS4gVXNlIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBub3QgY29udHJvbGxlZC5cbiAgICovXG4gIGRlZmF1bHRWYWx1ZTogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm51bWJlciksIFByb3BUeXBlcy5udW1iZXJdKSxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGNvbXBvbmVudCBpcyBkaXNhYmxlZC5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgdGhlIGFjdGl2ZSB0aHVtYiBkb2Vzbid0IHN3YXAgd2hlbiBtb3ZpbmcgcG9pbnRlciBvdmVyIGEgdGh1bWIgd2hpbGUgZHJhZ2dpbmcgYW5vdGhlciB0aHVtYi5cbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGRpc2FibGVTd2FwOiBQcm9wVHlwZXMuYm9vbCxcbiAgLyoqXG4gICAqIEFjY2VwdHMgYSBmdW5jdGlvbiB3aGljaCByZXR1cm5zIGEgc3RyaW5nIHZhbHVlIHRoYXQgcHJvdmlkZXMgYSB1c2VyLWZyaWVuZGx5IG5hbWUgZm9yIHRoZSB0aHVtYiBsYWJlbHMgb2YgdGhlIHNsaWRlci5cbiAgICogVGhpcyBpcyBpbXBvcnRhbnQgZm9yIHNjcmVlbiByZWFkZXIgdXNlcnMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgdGh1bWIgbGFiZWwncyBpbmRleCB0byBmb3JtYXQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBnZXRBcmlhTGFiZWw6IFByb3BUeXBlcy5mdW5jLFxuICAvKipcbiAgICogQWNjZXB0cyBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSBzdHJpbmcgdmFsdWUgdGhhdCBwcm92aWRlcyBhIHVzZXItZnJpZW5kbHkgbmFtZSBmb3IgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHNsaWRlci5cbiAgICogVGhpcyBpcyBpbXBvcnRhbnQgZm9yIHNjcmVlbiByZWFkZXIgdXNlcnMuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSBUaGUgdGh1bWIgbGFiZWwncyB2YWx1ZSB0byBmb3JtYXQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBUaGUgdGh1bWIgbGFiZWwncyBpbmRleCB0byBmb3JtYXQuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBnZXRBcmlhVmFsdWVUZXh0OiBQcm9wVHlwZXMuZnVuYyxcbiAgLyoqXG4gICAqIE1hcmtzIGluZGljYXRlIHByZWRldGVybWluZWQgdmFsdWVzIHRvIHdoaWNoIHRoZSB1c2VyIGNhbiBtb3ZlIHRoZSBzbGlkZXIuXG4gICAqIElmIGB0cnVlYCB0aGUgbWFya3MgYXJlIHNwYWNlZCBhY2NvcmRpbmcgdGhlIHZhbHVlIG9mIHRoZSBgc3RlcGAgcHJvcC5cbiAgICogSWYgYW4gYXJyYXksIGl0IHNob3VsZCBjb250YWluIG9iamVjdHMgd2l0aCBgdmFsdWVgIGFuZCBhbiBvcHRpb25hbCBgbGFiZWxgIGtleXMuXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICBtYXJrczogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLnNoYXBlKHtcbiAgICBsYWJlbDogUHJvcFR5cGVzLm5vZGUsXG4gICAgdmFsdWU6IFByb3BUeXBlcy5udW1iZXIuaXNSZXF1aXJlZFxuICB9KSksIFByb3BUeXBlcy5ib29sXSksXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBhbGxvd2VkIHZhbHVlIG9mIHRoZSBzbGlkZXIuXG4gICAqIFNob3VsZCBub3QgYmUgZXF1YWwgdG8gbWluLlxuICAgKiBAZGVmYXVsdCAxMDBcbiAgICovXG4gIG1heDogUHJvcFR5cGVzLm51bWJlcixcbiAgLyoqXG4gICAqIFRoZSBtaW5pbXVtIGFsbG93ZWQgdmFsdWUgb2YgdGhlIHNsaWRlci5cbiAgICogU2hvdWxkIG5vdCBiZSBlcXVhbCB0byBtYXguXG4gICAqIEBkZWZhdWx0IDBcbiAgICovXG4gIG1pbjogUHJvcFR5cGVzLm51bWJlcixcbiAgLyoqXG4gICAqIE5hbWUgYXR0cmlidXRlIG9mIHRoZSBoaWRkZW4gYGlucHV0YCBlbGVtZW50LlxuICAgKi9cbiAgbmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgLyoqXG4gICAqIENhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgZmlyZWQgd2hlbiB0aGUgc2xpZGVyJ3MgdmFsdWUgY2hhbmdlZC5cbiAgICpcbiAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgVGhlIGV2ZW50IHNvdXJjZSBvZiB0aGUgY2FsbGJhY2suXG4gICAqIFlvdSBjYW4gcHVsbCBvdXQgdGhlIG5ldyB2YWx1ZSBieSBhY2Nlc3NpbmcgYGV2ZW50LnRhcmdldC52YWx1ZWAgKGFueSkuXG4gICAqICoqV2FybmluZyoqOiBUaGlzIGlzIGEgZ2VuZXJpYyBldmVudCBub3QgYSBjaGFuZ2UgZXZlbnQuXG4gICAqIEBwYXJhbSB7bnVtYmVyIHwgbnVtYmVyW119IHZhbHVlIFRoZSBuZXcgdmFsdWUuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBhY3RpdmVUaHVtYiBJbmRleCBvZiB0aGUgY3VycmVudGx5IG1vdmVkIHRodW1iLlxuICAgKi9cbiAgb25DaGFuZ2U6IFByb3BUeXBlcy5mdW5jLFxuICAvKipcbiAgICogQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBpcyBmaXJlZCB3aGVuIHRoZSBgbW91c2V1cGAgaXMgdHJpZ2dlcmVkLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0LlN5bnRoZXRpY0V2ZW50IHwgRXZlbnR9IGV2ZW50IFRoZSBldmVudCBzb3VyY2Ugb2YgdGhlIGNhbGxiYWNrLiAqKldhcm5pbmcqKjogVGhpcyBpcyBhIGdlbmVyaWMgZXZlbnQgbm90IGEgY2hhbmdlIGV2ZW50LlxuICAgKiBAcGFyYW0ge251bWJlciB8IG51bWJlcltdfSB2YWx1ZSBUaGUgbmV3IHZhbHVlLlxuICAgKi9cbiAgb25DaGFuZ2VDb21taXR0ZWQ6IFByb3BUeXBlcy5mdW5jLFxuICAvKipcbiAgICogVGhlIGNvbXBvbmVudCBvcmllbnRhdGlvbi5cbiAgICogQGRlZmF1bHQgJ2hvcml6b250YWwnXG4gICAqL1xuICBvcmllbnRhdGlvbjogUHJvcFR5cGVzLm9uZU9mKFsnaG9yaXpvbnRhbCcsICd2ZXJ0aWNhbCddKSxcbiAgLyoqXG4gICAqIEEgdHJhbnNmb3JtYXRpb24gZnVuY3Rpb24sIHRvIGNoYW5nZSB0aGUgc2NhbGUgb2YgdGhlIHNsaWRlci5cbiAgICogQHBhcmFtIHthbnl9IHhcbiAgICogQHJldHVybnMge2FueX1cbiAgICogQGRlZmF1bHQgZnVuY3Rpb24gSWRlbnRpdHkoeCkge1xuICAgKiAgIHJldHVybiB4O1xuICAgKiB9XG4gICAqL1xuICBzY2FsZTogUHJvcFR5cGVzLmZ1bmMsXG4gIC8qKlxuICAgKiBUaGUgc2l6ZSBvZiB0aGUgc2xpZGVyLlxuICAgKiBAZGVmYXVsdCAnbWVkaXVtJ1xuICAgKi9cbiAgc2l6ZTogUHJvcFR5cGVzIC8qIEB0eXBlc2NyaXB0LXRvLXByb3B0eXBlcy1pZ25vcmUgKi8ub25lT2ZUeXBlKFtQcm9wVHlwZXMub25lT2YoWydzbWFsbCcsICdtZWRpdW0nXSksIFByb3BUeXBlcy5zdHJpbmddKSxcbiAgLyoqXG4gICAqIFRoZSBwcm9wcyB1c2VkIGZvciBlYWNoIHNsb3QgaW5zaWRlIHRoZSBTbGlkZXIuXG4gICAqIEBkZWZhdWx0IHt9XG4gICAqL1xuICBzbG90UHJvcHM6IFByb3BUeXBlcy5zaGFwZSh7XG4gICAgaW5wdXQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMub2JqZWN0XSksXG4gICAgbWFyazogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5vYmplY3RdKSxcbiAgICBtYXJrTGFiZWw6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMub2JqZWN0XSksXG4gICAgcmFpbDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5vYmplY3RdKSxcbiAgICByb290OiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm9iamVjdF0pLFxuICAgIHRodW1iOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm9iamVjdF0pLFxuICAgIHRyYWNrOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm9iamVjdF0pLFxuICAgIHZhbHVlTGFiZWw6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMuc2hhcGUoe1xuICAgICAgY2hpbGRyZW46IFByb3BUeXBlcy5lbGVtZW50LFxuICAgICAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgb3BlbjogUHJvcFR5cGVzLmJvb2wsXG4gICAgICBzdHlsZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgIHZhbHVlOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgdmFsdWVMYWJlbERpc3BsYXk6IFByb3BUeXBlcy5vbmVPZihbJ2F1dG8nLCAnb2ZmJywgJ29uJ10pXG4gICAgfSldKVxuICB9KSxcbiAgLyoqXG4gICAqIFRoZSBjb21wb25lbnRzIHVzZWQgZm9yIGVhY2ggc2xvdCBpbnNpZGUgdGhlIFNsaWRlci5cbiAgICogRWl0aGVyIGEgc3RyaW5nIHRvIHVzZSBhIEhUTUwgZWxlbWVudCBvciBhIGNvbXBvbmVudC5cbiAgICogQGRlZmF1bHQge31cbiAgICovXG4gIHNsb3RzOiBQcm9wVHlwZXMuc2hhcGUoe1xuICAgIGlucHV0OiBQcm9wVHlwZXMuZWxlbWVudFR5cGUsXG4gICAgbWFyazogUHJvcFR5cGVzLmVsZW1lbnRUeXBlLFxuICAgIG1hcmtMYWJlbDogUHJvcFR5cGVzLmVsZW1lbnRUeXBlLFxuICAgIHJhaWw6IFByb3BUeXBlcy5lbGVtZW50VHlwZSxcbiAgICByb290OiBQcm9wVHlwZXMuZWxlbWVudFR5cGUsXG4gICAgdGh1bWI6IFByb3BUeXBlcy5lbGVtZW50VHlwZSxcbiAgICB0cmFjazogUHJvcFR5cGVzLmVsZW1lbnRUeXBlLFxuICAgIHZhbHVlTGFiZWw6IFByb3BUeXBlcy5lbGVtZW50VHlwZVxuICB9KSxcbiAgLyoqXG4gICAqIFRoZSBncmFudWxhcml0eSB3aXRoIHdoaWNoIHRoZSBzbGlkZXIgY2FuIHN0ZXAgdGhyb3VnaCB2YWx1ZXMuIChBIFwiZGlzY3JldGVcIiBzbGlkZXIuKVxuICAgKiBUaGUgYG1pbmAgcHJvcCBzZXJ2ZXMgYXMgdGhlIG9yaWdpbiBmb3IgdGhlIHZhbGlkIHZhbHVlcy5cbiAgICogV2UgcmVjb21tZW5kIChtYXggLSBtaW4pIHRvIGJlIGV2ZW5seSBkaXZpc2libGUgYnkgdGhlIHN0ZXAuXG4gICAqXG4gICAqIFdoZW4gc3RlcCBpcyBgbnVsbGAsIHRoZSB0aHVtYiBjYW4gb25seSBiZSBzbGlkIG9udG8gbWFya3MgcHJvdmlkZWQgd2l0aCB0aGUgYG1hcmtzYCBwcm9wLlxuICAgKiBAZGVmYXVsdCAxXG4gICAqL1xuICBzdGVwOiBQcm9wVHlwZXMubnVtYmVyLFxuICAvKipcbiAgICogVGhlIHN5c3RlbSBwcm9wIHRoYXQgYWxsb3dzIGRlZmluaW5nIHN5c3RlbSBvdmVycmlkZXMgYXMgd2VsbCBhcyBhZGRpdGlvbmFsIENTUyBzdHlsZXMuXG4gICAqL1xuICBzeDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmFycmF5T2YoUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLmZ1bmMsIFByb3BUeXBlcy5vYmplY3QsIFByb3BUeXBlcy5ib29sXSkpLCBQcm9wVHlwZXMuZnVuYywgUHJvcFR5cGVzLm9iamVjdF0pLFxuICAvKipcbiAgICogVGFiIGluZGV4IGF0dHJpYnV0ZSBvZiB0aGUgaGlkZGVuIGBpbnB1dGAgZWxlbWVudC5cbiAgICovXG4gIHRhYkluZGV4OiBQcm9wVHlwZXMubnVtYmVyLFxuICAvKipcbiAgICogVGhlIHRyYWNrIHByZXNlbnRhdGlvbjpcbiAgICpcbiAgICogLSBgbm9ybWFsYCB0aGUgdHJhY2sgd2lsbCByZW5kZXIgYSBiYXIgcmVwcmVzZW50aW5nIHRoZSBzbGlkZXIgdmFsdWUuXG4gICAqIC0gYGludmVydGVkYCB0aGUgdHJhY2sgd2lsbCByZW5kZXIgYSBiYXIgcmVwcmVzZW50aW5nIHRoZSByZW1haW5pbmcgc2xpZGVyIHZhbHVlLlxuICAgKiAtIGBmYWxzZWAgdGhlIHRyYWNrIHdpbGwgcmVuZGVyIHdpdGhvdXQgYSBiYXIuXG4gICAqIEBkZWZhdWx0ICdub3JtYWwnXG4gICAqL1xuICB0cmFjazogUHJvcFR5cGVzLm9uZU9mKFsnaW52ZXJ0ZWQnLCAnbm9ybWFsJywgZmFsc2VdKSxcbiAgLyoqXG4gICAqIFRoZSB2YWx1ZSBvZiB0aGUgc2xpZGVyLlxuICAgKiBGb3IgcmFuZ2VkIHNsaWRlcnMsIHByb3ZpZGUgYW4gYXJyYXkgd2l0aCB0d28gdmFsdWVzLlxuICAgKi9cbiAgdmFsdWU6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5udW1iZXIpLCBQcm9wVHlwZXMubnVtYmVyXSksXG4gIC8qKlxuICAgKiBDb250cm9scyB3aGVuIHRoZSB2YWx1ZSBsYWJlbCBpcyBkaXNwbGF5ZWQ6XG4gICAqXG4gICAqIC0gYGF1dG9gIHRoZSB2YWx1ZSBsYWJlbCB3aWxsIGRpc3BsYXkgd2hlbiB0aGUgdGh1bWIgaXMgaG92ZXJlZCBvciBmb2N1c2VkLlxuICAgKiAtIGBvbmAgd2lsbCBkaXNwbGF5IHBlcnNpc3RlbnRseS5cbiAgICogLSBgb2ZmYCB3aWxsIG5ldmVyIGRpc3BsYXkuXG4gICAqIEBkZWZhdWx0ICdvZmYnXG4gICAqL1xuICB2YWx1ZUxhYmVsRGlzcGxheTogUHJvcFR5cGVzLm9uZU9mKFsnYXV0bycsICdvZmYnLCAnb24nXSksXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IGZ1bmN0aW9uIHRoZSB2YWx1ZSBsYWJlbCdzIHZhbHVlLlxuICAgKlxuICAgKiBXaGVuIGEgZnVuY3Rpb24gaXMgcHJvdmlkZWQsIGl0IHNob3VsZCBoYXZlIHRoZSBmb2xsb3dpbmcgc2lnbmF0dXJlOlxuICAgKlxuICAgKiAtIHtudW1iZXJ9IHZhbHVlIFRoZSB2YWx1ZSBsYWJlbCdzIHZhbHVlIHRvIGZvcm1hdFxuICAgKiAtIHtudW1iZXJ9IGluZGV4IFRoZSB2YWx1ZSBsYWJlbCdzIGluZGV4IHRvIGZvcm1hdFxuICAgKiBAcGFyYW0ge2FueX0geFxuICAgKiBAcmV0dXJucyB7YW55fVxuICAgKiBAZGVmYXVsdCBmdW5jdGlvbiBJZGVudGl0eSh4KSB7XG4gICAqICAgcmV0dXJuIHg7XG4gICAqIH1cbiAgICovXG4gIHZhbHVlTGFiZWxGb3JtYXQ6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5mdW5jLCBQcm9wVHlwZXMuc3RyaW5nXSlcbn0gOiB2b2lkIDA7XG5leHBvcnQgZGVmYXVsdCBTbGlkZXI7IiwiaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJztcbmltcG9ydCBjbHN4IGZyb20gJ2Nsc3gnO1xuaW1wb3J0IHNsaWRlckNsYXNzZXMgZnJvbSAnLi9zbGlkZXJDbGFzc2VzJztcbmltcG9ydCB7IGpzeCBhcyBfanN4IH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5pbXBvcnQgeyBqc3hzIGFzIF9qc3hzIH0gZnJvbSBcInJlYWN0L2pzeC1ydW50aW1lXCI7XG5jb25zdCB1c2VWYWx1ZUxhYmVsQ2xhc3NlcyA9IHByb3BzID0+IHtcbiAgY29uc3Qge1xuICAgIG9wZW5cbiAgfSA9IHByb3BzO1xuICBjb25zdCB1dGlsaXR5Q2xhc3NlcyA9IHtcbiAgICBvZmZzZXQ6IGNsc3gob3BlbiAmJiBzbGlkZXJDbGFzc2VzLnZhbHVlTGFiZWxPcGVuKSxcbiAgICBjaXJjbGU6IHNsaWRlckNsYXNzZXMudmFsdWVMYWJlbENpcmNsZSxcbiAgICBsYWJlbDogc2xpZGVyQ2xhc3Nlcy52YWx1ZUxhYmVsTGFiZWxcbiAgfTtcbiAgcmV0dXJuIHV0aWxpdHlDbGFzc2VzO1xufTtcblxuLyoqXG4gKiBAaWdub3JlIC0gaW50ZXJuYWwgY29tcG9uZW50LlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTbGlkZXJWYWx1ZUxhYmVsKHByb3BzKSB7XG4gIGNvbnN0IHtcbiAgICBjaGlsZHJlbixcbiAgICBjbGFzc05hbWUsXG4gICAgdmFsdWVcbiAgfSA9IHByb3BzO1xuICBjb25zdCBjbGFzc2VzID0gdXNlVmFsdWVMYWJlbENsYXNzZXMocHJvcHMpO1xuICBpZiAoIWNoaWxkcmVuKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jbG9uZUVsZW1lbnQoY2hpbGRyZW4sIHtcbiAgICBjbGFzc05hbWU6IGNsc3goY2hpbGRyZW4ucHJvcHMuY2xhc3NOYW1lKVxuICB9LCAvKiNfX1BVUkVfXyovX2pzeHMoUmVhY3QuRnJhZ21lbnQsIHtcbiAgICBjaGlsZHJlbjogW2NoaWxkcmVuLnByb3BzLmNoaWxkcmVuLCAvKiNfX1BVUkVfXyovX2pzeChcInNwYW5cIiwge1xuICAgICAgY2xhc3NOYW1lOiBjbHN4KGNsYXNzZXMub2Zmc2V0LCBjbGFzc05hbWUpLFxuICAgICAgXCJhcmlhLWhpZGRlblwiOiB0cnVlLFxuICAgICAgY2hpbGRyZW46IC8qI19fUFVSRV9fKi9fanN4KFwic3BhblwiLCB7XG4gICAgICAgIGNsYXNzTmFtZTogY2xhc3Nlcy5jaXJjbGUsXG4gICAgICAgIGNoaWxkcmVuOiAvKiNfX1BVUkVfXyovX2pzeChcInNwYW5cIiwge1xuICAgICAgICAgIGNsYXNzTmFtZTogY2xhc3Nlcy5sYWJlbCxcbiAgICAgICAgICBjaGlsZHJlbjogdmFsdWVcbiAgICAgICAgfSlcbiAgICAgIH0pXG4gICAgfSldXG4gIH0pKTtcbn1cbnByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIiA/IFNsaWRlclZhbHVlTGFiZWwucHJvcFR5cGVzID0ge1xuICBjaGlsZHJlbjogUHJvcFR5cGVzLmVsZW1lbnQuaXNSZXF1aXJlZCxcbiAgY2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICB2YWx1ZTogUHJvcFR5cGVzLm5vZGVcbn0gOiB2b2lkIDA7IiwiaW1wb3J0IHsgdW5zdGFibGVfZ2VuZXJhdGVVdGlsaXR5Q2xhc3NlcyBhcyBnZW5lcmF0ZVV0aWxpdHlDbGFzc2VzIH0gZnJvbSAnQG11aS91dGlscyc7XG5pbXBvcnQgZ2VuZXJhdGVVdGlsaXR5Q2xhc3MgZnJvbSAnLi4vZ2VuZXJhdGVVdGlsaXR5Q2xhc3MnO1xuZXhwb3J0IGZ1bmN0aW9uIGdldFNsaWRlclV0aWxpdHlDbGFzcyhzbG90KSB7XG4gIHJldHVybiBnZW5lcmF0ZVV0aWxpdHlDbGFzcygnTXVpU2xpZGVyJywgc2xvdCk7XG59XG5jb25zdCBzbGlkZXJDbGFzc2VzID0gZ2VuZXJhdGVVdGlsaXR5Q2xhc3NlcygnTXVpU2xpZGVyJywgWydyb290JywgJ2FjdGl2ZScsICdjb2xvclByaW1hcnknLCAnY29sb3JTZWNvbmRhcnknLCAnZGlzYWJsZWQnLCAnZHJhZ2dpbmcnLCAnZm9jdXNWaXNpYmxlJywgJ21hcmsnLCAnbWFya0FjdGl2ZScsICdtYXJrZWQnLCAnbWFya0xhYmVsJywgJ21hcmtMYWJlbEFjdGl2ZScsICdyYWlsJywgJ3NpemVTbWFsbCcsICd0aHVtYicsICd0aHVtYkNvbG9yUHJpbWFyeScsICd0aHVtYkNvbG9yU2Vjb25kYXJ5JywgJ3RyYWNrJywgJ3RyYWNrSW52ZXJ0ZWQnLCAndHJhY2tGYWxzZScsICd0aHVtYlNpemVTbWFsbCcsICd2YWx1ZUxhYmVsJywgJ3ZhbHVlTGFiZWxPcGVuJywgJ3ZhbHVlTGFiZWxDaXJjbGUnLCAndmFsdWVMYWJlbExhYmVsJywgJ3ZlcnRpY2FsJ10pO1xuZXhwb3J0IGRlZmF1bHQgc2xpZGVyQ2xhc3NlczsiLCJpbXBvcnQgeyB1bnN0YWJsZV9yZXF1aXJlUHJvcEZhY3RvcnkgYXMgcmVxdWlyZVByb3BGYWN0b3J5IH0gZnJvbSAnQG11aS91dGlscyc7XG5leHBvcnQgZGVmYXVsdCByZXF1aXJlUHJvcEZhY3Rvcnk7IiwiaW1wb3J0IHsgaXNIb3N0Q29tcG9uZW50IH0gZnJvbSAnQG11aS9iYXNlJztcbmNvbnN0IHNob3VsZFNwcmVhZEFkZGl0aW9uYWxQcm9wcyA9IFNsb3QgPT4ge1xuICByZXR1cm4gIVNsb3QgfHwgIWlzSG9zdENvbXBvbmVudChTbG90KTtcbn07XG5leHBvcnQgZGVmYXVsdCBzaG91bGRTcHJlYWRBZGRpdGlvbmFsUHJvcHM7IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3duZXJEb2N1bWVudChub2RlKSB7XG4gIHJldHVybiBub2RlICYmIG5vZGUub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudDtcbn0iLCJpbXBvcnQgX2V4dGVuZHMgZnJvbSBcIkBiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlcXVpcmVQcm9wRmFjdG9yeShjb21wb25lbnROYW1lSW5FcnJvciwgQ29tcG9uZW50KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcmV0dXJuICgpID0+IG51bGw7XG4gIH1cblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QvZm9yYmlkLWZvcmVpZ24tcHJvcC10eXBlc1xuICBjb25zdCBwcmV2UHJvcFR5cGVzID0gQ29tcG9uZW50ID8gX2V4dGVuZHMoe30sIENvbXBvbmVudC5wcm9wVHlwZXMpIDogbnVsbDtcbiAgY29uc3QgcmVxdWlyZVByb3AgPSByZXF1aXJlZFByb3AgPT4gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgLi4uYXJncykgPT4ge1xuICAgIGNvbnN0IHByb3BGdWxsTmFtZVNhZmUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG4gICAgY29uc3QgZGVmYXVsdFR5cGVDaGVja2VyID0gcHJldlByb3BUeXBlcyA9PSBudWxsID8gdm9pZCAwIDogcHJldlByb3BUeXBlc1twcm9wRnVsbE5hbWVTYWZlXTtcbiAgICBpZiAoZGVmYXVsdFR5cGVDaGVja2VyKSB7XG4gICAgICBjb25zdCB0eXBlQ2hlY2tlclJlc3VsdCA9IGRlZmF1bHRUeXBlQ2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIC4uLmFyZ3MpO1xuICAgICAgaWYgKHR5cGVDaGVja2VyUmVzdWx0KSB7XG4gICAgICAgIHJldHVybiB0eXBlQ2hlY2tlclJlc3VsdDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBwcm9wc1twcm9wTmFtZV0gIT09ICd1bmRlZmluZWQnICYmICFwcm9wc1tyZXF1aXJlZFByb3BdKSB7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKGBUaGUgcHJvcCBcXGAke3Byb3BGdWxsTmFtZVNhZmV9XFxgIG9mIGAgKyBgXFxgJHtjb21wb25lbnROYW1lSW5FcnJvcn1cXGAgY2FuIG9ubHkgYmUgdXNlZCB0b2dldGhlciB3aXRoIHRoZSBcXGAke3JlcXVpcmVkUHJvcH1cXGAgcHJvcC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIHJldHVybiByZXF1aXJlUHJvcDtcbn0iLCIvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1ob29rcy9ydWxlcy1vZi1ob29rcywgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzICovXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1c2VDb250cm9sbGVkKHtcbiAgY29udHJvbGxlZCxcbiAgZGVmYXVsdDogZGVmYXVsdFByb3AsXG4gIG5hbWUsXG4gIHN0YXRlID0gJ3ZhbHVlJ1xufSkge1xuICAvLyBpc0NvbnRyb2xsZWQgaXMgaWdub3JlZCBpbiB0aGUgaG9vayBkZXBlbmRlbmN5IGxpc3RzIGFzIGl0IHNob3VsZCBuZXZlciBjaGFuZ2UuXG4gIGNvbnN0IHtcbiAgICBjdXJyZW50OiBpc0NvbnRyb2xsZWRcbiAgfSA9IFJlYWN0LnVzZVJlZihjb250cm9sbGVkICE9PSB1bmRlZmluZWQpO1xuICBjb25zdCBbdmFsdWVTdGF0ZSwgc2V0VmFsdWVdID0gUmVhY3QudXNlU3RhdGUoZGVmYXVsdFByb3ApO1xuICBjb25zdCB2YWx1ZSA9IGlzQ29udHJvbGxlZCA/IGNvbnRyb2xsZWQgOiB2YWx1ZVN0YXRlO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoaXNDb250cm9sbGVkICE9PSAoY29udHJvbGxlZCAhPT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKFtgTVVJOiBBIGNvbXBvbmVudCBpcyBjaGFuZ2luZyB0aGUgJHtpc0NvbnRyb2xsZWQgPyAnJyA6ICd1bid9Y29udHJvbGxlZCAke3N0YXRlfSBzdGF0ZSBvZiAke25hbWV9IHRvIGJlICR7aXNDb250cm9sbGVkID8gJ3VuJyA6ICcnfWNvbnRyb2xsZWQuYCwgJ0VsZW1lbnRzIHNob3VsZCBub3Qgc3dpdGNoIGZyb20gdW5jb250cm9sbGVkIHRvIGNvbnRyb2xsZWQgKG9yIHZpY2UgdmVyc2EpLicsIGBEZWNpZGUgYmV0d2VlbiB1c2luZyBhIGNvbnRyb2xsZWQgb3IgdW5jb250cm9sbGVkICR7bmFtZX0gYCArICdlbGVtZW50IGZvciB0aGUgbGlmZXRpbWUgb2YgdGhlIGNvbXBvbmVudC4nLCBcIlRoZSBuYXR1cmUgb2YgdGhlIHN0YXRlIGlzIGRldGVybWluZWQgZHVyaW5nIHRoZSBmaXJzdCByZW5kZXIuIEl0J3MgY29uc2lkZXJlZCBjb250cm9sbGVkIGlmIHRoZSB2YWx1ZSBpcyBub3QgYHVuZGVmaW5lZGAuXCIsICdNb3JlIGluZm86IGh0dHBzOi8vZmIubWUvcmVhY3QtY29udHJvbGxlZC1jb21wb25lbnRzJ10uam9pbignXFxuJykpO1xuICAgICAgfVxuICAgIH0sIFtzdGF0ZSwgbmFtZSwgY29udHJvbGxlZF0pO1xuICAgIGNvbnN0IHtcbiAgICAgIGN1cnJlbnQ6IGRlZmF1bHRWYWx1ZVxuICAgIH0gPSBSZWFjdC51c2VSZWYoZGVmYXVsdFByb3ApO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICBpZiAoIWlzQ29udHJvbGxlZCAmJiBkZWZhdWx0VmFsdWUgIT09IGRlZmF1bHRQcm9wKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoW2BNVUk6IEEgY29tcG9uZW50IGlzIGNoYW5naW5nIHRoZSBkZWZhdWx0ICR7c3RhdGV9IHN0YXRlIG9mIGFuIHVuY29udHJvbGxlZCAke25hbWV9IGFmdGVyIGJlaW5nIGluaXRpYWxpemVkLiBgICsgYFRvIHN1cHByZXNzIHRoaXMgd2FybmluZyBvcHQgdG8gdXNlIGEgY29udHJvbGxlZCAke25hbWV9LmBdLmpvaW4oJ1xcbicpKTtcbiAgICAgIH1cbiAgICB9LCBbSlNPTi5zdHJpbmdpZnkoZGVmYXVsdFByb3ApXSk7XG4gIH1cbiAgY29uc3Qgc2V0VmFsdWVJZlVuY29udHJvbGxlZCA9IFJlYWN0LnVzZUNhbGxiYWNrKG5ld1ZhbHVlID0+IHtcbiAgICBpZiAoIWlzQ29udHJvbGxlZCkge1xuICAgICAgc2V0VmFsdWUobmV3VmFsdWUpO1xuICAgIH1cbiAgfSwgW10pO1xuICByZXR1cm4gW3ZhbHVlLCBzZXRWYWx1ZUlmVW5jb250cm9sbGVkXTtcbn0iLCJjb25zdCB2aXN1YWxseUhpZGRlbiA9IHtcbiAgYm9yZGVyOiAwLFxuICBjbGlwOiAncmVjdCgwIDAgMCAwKScsXG4gIGhlaWdodDogJzFweCcsXG4gIG1hcmdpbjogLTEsXG4gIG92ZXJmbG93OiAnaGlkZGVuJyxcbiAgcGFkZGluZzogMCxcbiAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gIHdoaXRlU3BhY2U6ICdub3dyYXAnLFxuICB3aWR0aDogJzFweCdcbn07XG5leHBvcnQgZGVmYXVsdCB2aXN1YWxseUhpZGRlbjsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=